<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR32 UC3 - FSACCESS Services: fat_unusual.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>fat_unusual.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
FAT services. 
<p>
This file is a set of rarely-used FAT functions.<p>
<ul>
<li>Compiler: IAR EWAVR32 and GNU GCC for AVR32</li><li>Supported devices: All AVR32 devices can be used. The example is written for UC3 and EVK1100.</li><li>AppNote:</li></ul>
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support and FAQ: <a href="http://support.atmel.no/">http://support.atmel.no/</a> </dd></dl>

<p>
Definition in file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
<code>#include &quot;<a class="el" href="a00030.html">conf_explorer.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="a00038.html">fs_com.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="a00034.html">fat.h</a>&quot;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &quot;<a class="el" href="a00032.html">ctrl_access.h</a>&quot;</code><br>

<p>
<a href="a00035.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">st_fs_format_table</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struture for the tables format.  <a href="a00011.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00011.html">st_fs_format_table</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#8f4af6dbd9d7623aae42558121aa1a20">Fs_format_table</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struture for the tables format.  <a href="#8f4af6dbd9d7623aae42558121aa1a20"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#1fa62b2728e71cff2e95556db7ed1b9c">fat_allocfreespace</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction alloc a continue segment in free space.  <a href="#1fa62b2728e71cff2e95556db7ed1b9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#6cc9ee9a14553be84990df27709f51a6">fat_clear_cluster</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction clear a cluster.  <a href="#6cc9ee9a14553be84990df27709f51a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#9503329592cf7484faf77ca95a6a21aa">fat_clear_info_fat_mod</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction clear the informations about FAT modification.  <a href="#9503329592cf7484faf77ca95a6a21aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#da2110d711208b46e93eb269da40bdf1">fat_create_entry_file_name</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction create a entry file with only the name fields.  <a href="#da2110d711208b46e93eb269da40bdf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#797fc629a4a513e6a5f2951720da5d47">fat_delete_file</a> (Bool b_cluster_list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction delete the file entrys and cluster list.  <a href="#797fc629a4a513e6a5f2951720da5d47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a03d2728f28964e1eb4d78c2bb831718">fat_entry_label</a> (Bool b_action, <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_label)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction to read or to write a label.  <a href="#a03d2728f28964e1eb4d78c2bb831718"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#6099b0e8fafcc01b8c1769c94c827325">fat_format</a> (U8 u8_fat_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction format the current drive.  <a href="#6099b0e8fafcc01b8c1769c94c827325"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#51041500c2e36ab39aad19b54e93d504">fat_get_date</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_date, Bool type_date)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction read the informations about the dates.  <a href="#51041500c2e36ab39aad19b54e93d504"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#e23270781477be5e6c89b90531c01651">fat_getfreespace</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction return the space free in the current drive partition.  <a href="#e23270781477be5e6c89b90531c01651"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#14426d5552b72b88ea0d61828c57d6c6">fat_getfreespace_percent</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction return the space free in percent.  <a href="#14426d5552b72b88ea0d61828c57d6c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#9510bd193c1e70f2307c5b9b07078511">fat_initialize_dir</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction write the directory informations.  <a href="#9510bd193c1e70f2307c5b9b07078511"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#c0108ea608b547e8d3a405c70644c1e9">fat_mount</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction mount a partition file system (FAT12, FAT16 or FAT32) of drive selected.  <a href="#c0108ea608b547e8d3a405c70644c1e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#0a8beb16a074b07828fc725e0c0ae500">fat_read_fat32_FSInfo</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction return the space free in the drive partition FAT32 selected.  <a href="#0a8beb16a074b07828fc725e0c0ae500"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#2ff43f97db7a5d76f46f4fb1b683d192">fat_serialnumber</a> (Bool b_action, U8 _MEM_TYPE_SLOW_ *a_u8_sn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction to read or to write a serial number.  <a href="#2ff43f97db7a5d76f46f4fb1b683d192"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#838253d384d03898e6fcb2b3a7687e43">fat_set_date</a> (const <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_date, Bool type_date)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction change the informations about date.  <a href="#838253d384d03898e6fcb2b3a7687e43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#8145cff91620fc1b70aa0eef5750db72">fat_update_fat2</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction copy the modification of first FAT to second FAT.  <a href="#8145cff91620fc1b70aa0eef5750db72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#9cf154ffe36bc2c00b1d589e523b449c">fat_write_fat32_FSInfo</a> (U32 u32_nb_free_cluster)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction write the space free number in drive partition FAT32 selected.  <a href="#9cf154ffe36bc2c00b1d589e523b449c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sub routine used to create a entry file</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a2b4dadfd961b4547fd67f7ebe8a5c5d">fat_alloc_entry_free</a> (U8 u8_nb_entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction alloc the number of entry in directory.  <a href="#a2b4dadfd961b4547fd67f7ebe8a5c5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#8849a8388de3f116fd53fd9ec07747b2">fat_check_name</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction check the character of name AND computed the number of entry file for the name.  <a href="#8849a8388de3f116fd53fd9ec07747b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#70a6be69645d22685e0ec6b52b93d9b2">fat_create_long_name_entry</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_name, U8 u8_crc, U8 u8_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction create a long entry file in the current entry.  <a href="#70a6be69645d22685e0ec6b52b93d9b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#49163f06665633236c432aa1a1163f01">fat_create_short_entry_name</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_name, <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> short_name, U8 nb, Bool mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction create a short name entry in the cache sector OR in a string.  <a href="#49163f06665633236c432aa1a1163f01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#19c7a66123aba4a4a705623085c03f6f">fat_entry_shortname_compare</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> short_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction compare the short name with current entry.  <a href="#19c7a66123aba4a4a705623085c03f6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#24d01b29254a31c7b331935fd8288037">fat_find_short_entry_name</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction research a unique short name.  <a href="#24d01b29254a31c7b331935fd8288037"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#bb2561113110b35fac032431243f8bb0">fat_translate_char_shortname</a> (U8 character)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction translate the character to short name character autorized.  <a href="#bb2561113110b35fac032431243f8bb0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sub routines used by format routine</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad6177926c645c867ea1d23c727d9097">fat_clean_zone</a> (Bool b_MBR)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction clean the reserved zone, FAT zone, and root dir zone.  <a href="#ad6177926c645c867ea1d23c727d9097"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#6ab74fa9e68a4379a3ea33465d835277">fat_initialize_fat</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction initialize the fat one and two.  <a href="#6ab74fa9e68a4379a3ea33465d835277"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#477e90a97f3fcb8361020feb2557098d">fat_select_filesystem</a> (U8 u8_fat_type, Bool b_MBR)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction compute the file system type to use for the disk selected.  <a href="#477e90a97f3fcb8361020feb2557098d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#9075855486dc53d38dd64e068b512027">fat_write_MBR</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction write the MBR.  <a href="#9075855486dc53d38dd64e068b512027"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#89d56497bd58d7d6553b7e319f3ee863">fat_write_PBR</a> (Bool b_MBR)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction write the PBR.  <a href="#89d56497bd58d7d6553b7e319f3ee863"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sub routines used by date read-write routines</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a> (const <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_ascii_number, U8 u8_size_number_ascii)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction translate a ASCII number to a digital number.  <a href="#f138eb34db69daa5d51e33d130d85424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_ascii_number, U8 u8_size_number_ascii, U8 u8_nb_increment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction translate a digital number to a ASCII number.  <a href="#1a3ce899100c1b2a7798140852d9f22b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#f2d2b930b3953ad1cfc996de5970a138">fat_translatedate_ascii_to_number</a> (const <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_date, <a class="el" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_date, Bool enable_ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction translate a date and time ascii string to FAT value.  <a href="#f2d2b930b3953ad1cfc996de5970a138"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#015e44f70b92d8b39e00ababfdb6bc24">fat_translatedate_number_to_ascii</a> (<a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> sz_date, <a class="el" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_date, Bool enable_ms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This fonction translate a date and time FAT value to ascii string.  <a href="#015e44f70b92d8b39e00ababfdb6bc24"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#6b6070b3785c1dcfd6b94c639a1039c3">const_header_pbr</a> []</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constante for <a class="el" href="a00019.html#89d56497bd58d7d6553b7e319f3ee863">fat_write_PBR()</a> routine.  <a href="#6b6070b3785c1dcfd6b94c639a1039c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#89cf8e55b9308a287d4f24c28f8278ed">fs_s_execption_char</a> [] = {'+',',','.',';','=','[',']'}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Table of character no supported in short name.  <a href="#89cf8e55b9308a287d4f24c28f8278ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#6584c61d6d4c16ebe9f92c92a53e96bf">fs_s_tab_incorrect_char</a> [] = {':','*','?','&quot;','&lt;','&gt;','|'}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Table of characters no supported in a name.  <a href="#6584c61d6d4c16ebe9f92c92a53e96bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_MEM_TYPE_SLOW_ U32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global variable to optimize the code of format routines.  <a href="#045dd8cfc387ec4ecf5c278bd239a5cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ <a class="el" href="a00011.html">Fs_format_table</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#12c9e9d2a4cbd29f35072cccecc0f0d5">TableFAT12</a> []</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Table format for FAT12.  <a href="#12c9e9d2a4cbd29f35072cccecc0f0d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ <a class="el" href="a00011.html">Fs_format_table</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#e060256d5bbd91d6412e3601893935b4">TableFAT16</a> []</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Table format for FAT16.  <a href="#e060256d5bbd91d6412e3601893935b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ <a class="el" href="a00011.html">Fs_format_table</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#c25415e8010641385456353f4c1c5eec">TableFAT32</a> []</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Table format for FAT32.  <a href="#c25415e8010641385456353f4c1c5eec"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constante of "FAT32 FSInfo Sector"</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a> []</td></tr>

<tr><td colspan="2"><div class="groupHeader">Constante for fat_initialize_fat() fonction</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#d7b8480b30e94480383a615e9304dee1">const_header_fat12</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#96762bd73caa7d1fdc8c92db0b777f1a">const_header_fat16</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">_CONST_TYPE_ U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#94831debe0600f19945c3239dc3634e7">const_header_fat32</a> []</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="8f4af6dbd9d7623aae42558121aa1a20"></a><!-- doxytag: member="fat_unusual.c::Fs_format_table" ref="8f4af6dbd9d7623aae42558121aa1a20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00011.html">st_fs_format_table</a>  <a class="el" href="a00011.html">Fs_format_table</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Struture for the tables format. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a2b4dadfd961b4547fd67f7ebe8a5c5d"></a><!-- doxytag: member="fat_unusual.c::fat_alloc_entry_free" ref="a2b4dadfd961b4547fd67f7ebe8a5c5d" args="(U8 u8_nb_entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_alloc_entry_free           </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_nb_entry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction alloc the number of entry in directory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u8_nb_entry</em>&nbsp;</td><td>number of entry to alloc</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! OUT: Initialise the system on the last alloc free entry
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01872">1872</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00035.html#l02145">fat_allocfreespace()</a>, <a class="el" href="a00035.html#l02319">fat_clear_cluster()</a>, <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00033.html#l01184">fat_read_dir()</a>, <a class="el" href="a00034.html#l00186">FS_ENTRY_END</a>, <a class="el" href="a00038.html#l00217">FS_ERR_OUT_LIST</a>, <a class="el" href="a00034.html#l00370">fs_g_nav_fast</a>, <a class="el" href="a00034.html#l00375">fs_g_seg</a>, <a class="el" href="a00038.html#l00257">fs_g_status</a>, <a class="el" href="a00034.html#l00279">Fs_management_fast::u16_entry_pos_sel_file</a>, and <a class="el" href="a00034.html#l00300">Fs_segment::u32_size_or_pos</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01470">fat_create_entry_file_name()</a>.<div class="fragment"><pre class="fragment"><a name="l01873"></a>01873 {
<a name="l01874"></a>01874    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01875"></a>01875 
<a name="l01876"></a>01876    <span class="comment">// start at the beginning of dir</span>
<a name="l01877"></a>01877    <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04">u16_entry_pos_sel_file</a>=0;   <span class="comment">// go to beginning of directory</span>
<a name="l01878"></a>01878    <span class="comment">// loop in directory</span>
<a name="l01879"></a>01879    <span class="keywordflow">while</span>( 1 )
<a name="l01880"></a>01880    {
<a name="l01881"></a>01881       <span class="comment">// Read current sector directory</span>
<a name="l01882"></a>01882       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#1a35321a99150ba643f87cb6c79ec3e5">fat_read_dir</a>() )
<a name="l01883"></a>01883       {
<a name="l01884"></a>01884          <span class="keywordflow">if</span>( <a class="code" href="a00022.html#e8798a89bfc4f49da50fc55b14a5b07f">FS_ERR_OUT_LIST</a> != <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> )
<a name="l01885"></a>01885             <span class="keywordflow">return</span> FALSE;
<a name="l01886"></a>01886 
<a name="l01887"></a>01887          <span class="comment">// The position is at out off the cluster list</span>
<a name="l01888"></a>01888             
<a name="l01889"></a>01889          <span class="comment">// Alloc a new sector (= new cluster)</span>
<a name="l01890"></a>01890          <span class="comment">// Remark: The fs_g_seg.u32_addr containt the last cluster value of a directory list to link with the new list</span>
<a name="l01891"></a>01891          <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae">u32_size_or_pos</a> = 1;
<a name="l01892"></a>01892          <span class="keywordflow">if</span>( !<a class="code" href="a00018.html#1fa62b2728e71cff2e95556db7ed1b9c">fat_allocfreespace</a>())
<a name="l01893"></a>01893             <span class="keywordflow">return</span> FALSE;
<a name="l01894"></a>01894          
<a name="l01895"></a>01895          <span class="comment">// Clean this new cluster</span>
<a name="l01896"></a>01896          <span class="comment">// Remark: The fs_g_seg.u32_addr containt the new cluster value</span>
<a name="l01897"></a>01897          <span class="keywordflow">if</span>( !<a class="code" href="a00018.html#6cc9ee9a14553be84990df27709f51a6">fat_clear_cluster</a>())
<a name="l01898"></a>01898             <span class="keywordflow">return</span> FALSE;
<a name="l01899"></a>01899             
<a name="l01900"></a>01900          <span class="keywordflow">continue</span>;  <span class="comment">// Rescan the directory list for found the new sector</span>
<a name="l01901"></a>01901       }
<a name="l01902"></a>01902 
<a name="l01903"></a>01903       <span class="comment">// Check entry</span>
<a name="l01904"></a>01904       ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01905"></a>01905       <span class="keywordflow">if</span> ( <a class="code" href="a00018.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> == *ptr_entry )
<a name="l01906"></a>01906       {  <span class="comment">// the entry is free</span>
<a name="l01907"></a>01907          u8_nb_entry--;
<a name="l01908"></a>01908          <span class="keywordflow">if</span>( 0 == u8_nb_entry )
<a name="l01909"></a>01909          {
<a name="l01910"></a>01910             <span class="keywordflow">return</span> TRUE;  <span class="comment">// All free entry is alloc</span>
<a name="l01911"></a>01911          }
<a name="l01912"></a>01912       }
<a name="l01913"></a>01913          
<a name="l01914"></a>01914       <span class="comment">// go to next entry</span>
<a name="l01915"></a>01915       <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04">u16_entry_pos_sel_file</a>++;
<a name="l01916"></a>01916    }  <span class="comment">// end of while(1)</span>
<a name="l01917"></a>01917 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1fa62b2728e71cff2e95556db7ed1b9c"></a><!-- doxytag: member="fat_unusual.c::fat_allocfreespace" ref="1fa62b2728e71cff2e95556db7ed1b9c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_allocfreespace           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction alloc a continue segment in free space. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! Global variables used
//! IN : 
//!   fs_g_seg.u32_addr          Last cluster value of a other list to link with the new list
//!                              If no link then set MSB0(fs_g_seg.u32_addr) to 0xFF
//!   fs_g_seg.u32_size_or_pos   Maximum size of segment alloc (unit sector)
//! OUT:
//!   fs_g_seg.u32_addr          Return the first cluster value of the new list
//!   fs_g_seg.u32_size_or_pos   The number of sector remainning
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l02145">2145</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00035.html#l02269">fat_clear_info_fat_mod()</a>, <a class="el" href="a00033.html#l00619">fat_cluster_val()</a>, <a class="el" href="a00035.html#l00840">fat_write_fat32_FSInfo()</a>, <a class="el" href="a00034.html#l00236">FS_CLUST_VAL_READ</a>, <a class="el" href="a00034.html#l00237">FS_CLUST_VAL_WRITE</a>, <a class="el" href="a00034.html#l00378">fs_g_cluster</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00370">fs_g_nav_fast</a>, <a class="el" href="a00034.html#l00375">fs_g_seg</a>, <a class="el" href="a00034.html#l00341">FS_TYPE_FAT_32</a>, <a class="el" href="a00034.html#l00087">Is_fat32</a>, <a class="el" href="a00034.html#l00269">Fs_management::rootdir</a>, <a class="el" href="a00034.html#l00299">Fs_segment::u32_addr</a>, <a class="el" href="a00034.html#l00248">Fs_rootdir::u32_cluster</a>, <a class="el" href="a00034.html#l00266">Fs_management::u32_CountofCluster</a>, <a class="el" href="a00034.html#l00306">st_fs_cluster::u32_pos</a>, <a class="el" href="a00034.html#l00307">st_fs_cluster::u32_val</a>, and <a class="el" href="a00034.html#l00278">Fs_management_fast::u8_type_fat</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01872">fat_alloc_entry_free()</a>, <a class="el" href="a00033.html#l01108">fat_write_file()</a>, and <a class="el" href="a00042.html#l01253">nav_dir_make()</a>.<div class="fragment"><pre class="fragment"><a name="l02146"></a>02146 {
<a name="l02147"></a>02147    Bool first_cluster_free_is_found = FALSE; <span class="comment">// Flag to signal the first step</span>
<a name="l02148"></a>02148    Bool b_quick_find = TRUE;  <span class="comment">// Flag to signal the first step</span>
<a name="l02149"></a>02149 
<a name="l02150"></a>02150    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02151"></a>02151    {
<a name="l02152"></a>02152       <span class="comment">// Clear info about free space</span>
<a name="l02153"></a>02153       <span class="keywordflow">if</span>( !<a class="code" href="a00018.html#9cf154ffe36bc2c00b1d589e523b449c">fat_write_fat32_FSInfo</a>( 0xFFFFFFFF ))
<a name="l02154"></a>02154          <span class="keywordflow">return</span> FALSE;
<a name="l02155"></a>02155    }
<a name="l02156"></a>02156    
<a name="l02157"></a>02157    <span class="keywordflow">if</span>( 0xFF == MSB0(<a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172">u32_addr</a>) )
<a name="l02158"></a>02158    {
<a name="l02159"></a>02159 fat_allocfreespace_start:
<a name="l02160"></a>02160       <span class="comment">// New cluster list, then research at the beginning</span>
<a name="l02161"></a>02161       <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> = 2;
<a name="l02162"></a>02162    }<span class="keywordflow">else</span>{
<a name="l02163"></a>02163       <span class="comment">// increment a list then start at the next cluster of end of list</span>
<a name="l02164"></a>02164       <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> = <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172">u32_addr</a>+1;
<a name="l02165"></a>02165    }
<a name="l02166"></a>02166       
<a name="l02167"></a>02167    <a class="code" href="a00018.html#9503329592cf7484faf77ca95a6a21aa">fat_clear_info_fat_mod</a>();
<a name="l02168"></a>02168    
<a name="l02169"></a>02169    <span class="comment">// Read ALL FAT1</span>
<a name="l02170"></a>02170    <span class="keywordflow">for</span>(  
<a name="l02171"></a>02171    ;     <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> &lt; <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a>
<a name="l02172"></a>02172    ;     <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a>++ )
<a name="l02173"></a>02173    {
<a name="l02174"></a>02174       <span class="comment">// Get the value of the cluster</span>
<a name="l02175"></a>02175       <span class="keywordflow">if</span> ( !<a class="code" href="a00017.html#1be84552293d174f534b2fb8d0a4e737">fat_cluster_val</a>( <a class="code" href="a00018.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ) )
<a name="l02176"></a>02176          <span class="keywordflow">return</span> FALSE;
<a name="l02177"></a>02177 
<a name="l02178"></a>02178       <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#4f323a1ec38e3c0f1b57bf4fe07842b7">u32_val</a> )
<a name="l02179"></a>02179       {
<a name="l02180"></a>02180          <span class="comment">// Link the new cluster with previous cluster </span>
<a name="l02181"></a>02181          <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#4f323a1ec38e3c0f1b57bf4fe07842b7">u32_val</a> = <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a>; <span class="comment">// value of the cluster is the new free cluster</span>
<a name="l02182"></a>02182          <span class="keywordflow">if</span>( TRUE == first_cluster_free_is_found )
<a name="l02183"></a>02183          {
<a name="l02184"></a>02184             <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a>--;                      <span class="comment">// select the previous cluster</span>
<a name="l02185"></a>02185             if ( !<a class="code" href="a00017.html#1be84552293d174f534b2fb8d0a4e737">fat_cluster_val</a>( <a class="code" href="a00018.html#c11d0331723bc237aac4d6c7a4fe7496">FS_CLUST_VAL_WRITE</a> ) )
<a name="l02186"></a>02186                <span class="keywordflow">return</span> FALSE;
<a name="l02187"></a>02187          }
<a name="l02188"></a>02188          <span class="keywordflow">else</span>
<a name="l02189"></a>02189          {
<a name="l02190"></a>02190             <span class="comment">// It is the first cluster of the new list</span>
<a name="l02191"></a>02191             first_cluster_free_is_found = TRUE;
<a name="l02192"></a>02192             
<a name="l02193"></a>02193             <span class="keywordflow">if</span>( 0xFF != MSB0(<a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172">u32_addr</a>) )
<a name="l02194"></a>02194             {
<a name="l02195"></a>02195                <span class="comment">// Link this new list with other cluster list</span>
<a name="l02196"></a>02196                <span class="comment">// select the last cluster of the previous list</span>
<a name="l02197"></a>02197                <span class="keywordflow">if</span>( 0 == <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172">u32_addr</a> )
<a name="l02198"></a>02198                {  <span class="comment">// The previous list is the first cluster of root dir</span>
<a name="l02199"></a>02199                   <span class="keywordflow">if</span>( <a class="code" href="a00018.html#bed7b1e094b19dac8efa753f59f84fc6">FS_TYPE_FAT_32</a> != <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> )
<a name="l02200"></a>02200                   {
<a name="l02201"></a>02201                      <span class="keywordflow">break</span>; <span class="comment">// Impossible to increment ROOT DIR size of FAT12 or FAT16</span>
<a name="l02202"></a>02202                   }
<a name="l02203"></a>02203                   <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b">u32_cluster</a>;
<a name="l02204"></a>02204                }
<a name="l02205"></a>02205                <span class="keywordflow">else</span>
<a name="l02206"></a>02206                {
<a name="l02207"></a>02207                   <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> = <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172">u32_addr</a>;
<a name="l02208"></a>02208                }
<a name="l02209"></a>02209                <span class="keywordflow">if</span> ( !<a class="code" href="a00017.html#1be84552293d174f534b2fb8d0a4e737">fat_cluster_val</a>( <a class="code" href="a00018.html#c11d0331723bc237aac4d6c7a4fe7496">FS_CLUST_VAL_WRITE</a> ) )
<a name="l02210"></a>02210                   <span class="keywordflow">return</span> FALSE;
<a name="l02211"></a>02211             }  <span class="comment">// else no writing the first cluster value in FAT because no previous cluster</span>
<a name="l02212"></a>02212             <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172">u32_addr</a> = <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#4f323a1ec38e3c0f1b57bf4fe07842b7">u32_val</a>;    <span class="comment">// save the first cluster value</span>
<a name="l02213"></a>02213          }
<a name="l02214"></a>02214             
<a name="l02215"></a>02215          <span class="comment">// Write in new cluster the end of list</span>
<a name="l02216"></a>02216          <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> = <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#4f323a1ec38e3c0f1b57bf4fe07842b7">u32_val</a>; <span class="comment">// select the new cluster</span>
<a name="l02217"></a>02217          <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#4f323a1ec38e3c0f1b57bf4fe07842b7">u32_val</a> = <a class="code" href="a00018.html#6a0f491ab351899993a4171f5ff526f3">FS_CLUST_VAL_EOL</a>;     <span class="comment">// value of the cluster is flag end of list</span>
<a name="l02218"></a>02218          <span class="keywordflow">if</span> ( !<a class="code" href="a00017.html#1be84552293d174f534b2fb8d0a4e737">fat_cluster_val</a>( <a class="code" href="a00018.html#c11d0331723bc237aac4d6c7a4fe7496">FS_CLUST_VAL_WRITE</a> ) )
<a name="l02219"></a>02219             <span class="keywordflow">return</span> FALSE;
<a name="l02220"></a>02220          
<a name="l02221"></a>02221          <span class="comment">// Compute the remaining of sector</span>
<a name="l02222"></a>02222          <span class="keywordflow">if</span> ( <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae">u32_size_or_pos</a> &lt;= <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a> )
<a name="l02223"></a>02223          {
<a name="l02224"></a>02224             <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae">u32_size_or_pos</a> = 0; <span class="comment">// All space found </span>
<a name="l02225"></a>02225             <span class="keywordflow">break</span>; <span class="comment">// stop loop</span>
<a name="l02226"></a>02226          }
<a name="l02227"></a>02227          <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae">u32_size_or_pos</a> -= <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>;
<a name="l02228"></a>02228       }
<a name="l02229"></a>02229       <span class="keywordflow">else</span>
<a name="l02230"></a>02230       {
<a name="l02231"></a>02231          <span class="keywordflow">if</span>( TRUE == first_cluster_free_is_found )
<a name="l02232"></a>02232          {
<a name="l02233"></a>02233             <span class="comment">// End of continue segment free</span>
<a name="l02234"></a>02234             <span class="keywordflow">break</span>; <span class="comment">// stop loop</span>
<a name="l02235"></a>02235          }
<a name="l02236"></a>02236          <span class="keywordflow">else</span>
<a name="l02237"></a>02237          {
<a name="l02238"></a>02238             <span class="comment">// It is the first step (find the first free cluster)</span>
<a name="l02239"></a>02239             <span class="comment">// ignore this cluster no free</span>
<a name="l02240"></a>02240             <span class="keywordflow">if</span>( b_quick_find )
<a name="l02241"></a>02241             {
<a name="l02242"></a>02242                <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> += 500;
<a name="l02243"></a>02243             }
<a name="l02244"></a>02244          }
<a name="l02245"></a>02245       }
<a name="l02246"></a>02246    }
<a name="l02247"></a>02247    
<a name="l02248"></a>02248    <span class="comment">// End of alloc</span>
<a name="l02249"></a>02249    <span class="keywordflow">if</span>( FALSE == first_cluster_free_is_found )
<a name="l02250"></a>02250    {
<a name="l02251"></a>02251       <span class="keywordflow">if</span>( b_quick_find )
<a name="l02252"></a>02252       {  
<a name="l02253"></a>02253          <span class="comment">// Retry in no quick mode</span>
<a name="l02254"></a>02254          b_quick_find = FALSE;
<a name="l02255"></a>02255          <span class="keywordflow">goto</span> fat_allocfreespace_start;
<a name="l02256"></a>02256       }
<a name="l02257"></a>02257       <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#660c831b30ffc47ef997a2e8ddc66c0d">FS_ERR_NO_FREE_SPACE</a>; <span class="comment">// NO FREE CLUSTER FIND</span>
<a name="l02258"></a>02258       <span class="keywordflow">return</span> FALSE;
<a name="l02259"></a>02259    }
<a name="l02260"></a>02260 
<a name="l02261"></a>02261    <span class="keywordflow">return</span> <a class="code" href="a00018.html#8145cff91620fc1b70aa0eef5750db72">fat_update_fat2</a>();
<a name="l02262"></a>02262 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8849a8388de3f116fd53fd9ec07747b2"></a><!-- doxytag: member="fat_unusual.c::fat_check_name" ref="8849a8388de3f116fd53fd9ec07747b2" args="(FS_STRING sz_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 fat_check_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction check the character of name AND computed the number of entry file for the name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_name</em>&nbsp;</td><td>long name to create</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of entry file necessary incluing the short name entry <br>
 if a caracter isn't supported then 0. </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01797">1797</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01710">fat_check_eof_name()</a>, <a class="el" href="a00034.html#l00196">FS_SIZE_LFN_ENTRY</a>, <a class="el" href="a00034.html#l00094">Is_unicode</a>, and <a class="el" href="a00033.html#l00351">u8_i</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01470">fat_create_entry_file_name()</a>.<div class="fragment"><pre class="fragment"><a name="l01798"></a>01798 {
<a name="l01799"></a>01799    U8 u8_nb_entry, <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a>, u8_j;
<a name="l01800"></a>01800    U16 u16_character;
<a name="l01801"></a>01801 
<a name="l01802"></a>01802    <span class="comment">// Compute the number of entry for this name</span>
<a name="l01803"></a>01803    u8_nb_entry = 2;     <span class="comment">// a short entry + one long name entry minimum</span>
<a name="l01804"></a>01804    u8_i = <a class="code" href="a00018.html#bbdca2b90701f373bf6c865c88c99697">FS_SIZE_LFN_ENTRY</a>;
<a name="l01805"></a>01805    <span class="keywordflow">while</span>( 1 )
<a name="l01806"></a>01806    {
<a name="l01807"></a>01807       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a> )
<a name="l01808"></a>01808       {
<a name="l01809"></a>01809          u16_character = ((<a class="code" href="a00022.html#4b07eeef6c66c629ec6708f8eee35f58">FS_STR_UNICODE</a>)sz_name)[0];
<a name="l01810"></a>01810       }<span class="keywordflow">else</span>{
<a name="l01811"></a>01811          u16_character = sz_name[0];
<a name="l01812"></a>01812       }
<a name="l01813"></a>01813       <span class="keywordflow">if</span>( <a class="code" href="a00017.html#452e159ed5e2a4d8ea88f0515a3a6e10">fat_check_eof_name</a>( u16_character ) )
<a name="l01814"></a>01814          <span class="keywordflow">break</span>;
<a name="l01815"></a>01815 
<a name="l01816"></a>01816       <span class="keywordflow">for</span>( u8_j = 0 ; u8_j &lt; <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#6584c61d6d4c16ebe9f92c92a53e96bf">fs_s_tab_incorrect_char</a>) ; u8_j++ )
<a name="l01817"></a>01817       {
<a name="l01818"></a>01818          <span class="keywordflow">if</span>( u16_character == <a class="code" href="a00019.html#6584c61d6d4c16ebe9f92c92a53e96bf">fs_s_tab_incorrect_char</a>[u8_j] )
<a name="l01819"></a>01819             <span class="keywordflow">return</span> 0;   <span class="comment">// incorrect character</span>
<a name="l01820"></a>01820       }
<a name="l01821"></a>01821       <span class="keywordflow">if</span>( 0 == u8_i )
<a name="l01822"></a>01822       {
<a name="l01823"></a>01823          u8_nb_entry++;
<a name="l01824"></a>01824          u8_i = <a class="code" href="a00018.html#bbdca2b90701f373bf6c865c88c99697">FS_SIZE_LFN_ENTRY</a>;
<a name="l01825"></a>01825       }
<a name="l01826"></a>01826       u8_i--;
<a name="l01827"></a>01827       sz_name += (<a class="code" href="a00018.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01828"></a>01828    }
<a name="l01829"></a>01829    <span class="keywordflow">return</span> u8_nb_entry;
<a name="l01830"></a>01830 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ad6177926c645c867ea1d23c727d9097"></a><!-- doxytag: member="fat_unusual.c::fat_clean_zone" ref="ad6177926c645c867ea1d23c727d9097" args="(Bool b_MBR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_clean_zone           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>b_MBR</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction clean the reserved zone, FAT zone, and root dir zone. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b_MBR</em>&nbsp;</td><td>TRUE, include a MBR on disk</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l00915">915</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01790">fat_cache_clear()</a>, <a class="el" href="a00033.html#l01810">fat_cache_flush()</a>, <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00034.html#l00087">Is_fat32</a>, <a class="el" href="a00034.html#l00265">Fs_management::u16_fat_size</a>, and <a class="el" href="a00034.html#l00263">Fs_management::u8_BPB_SecPerClus</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00335">fat_format()</a>.<div class="fragment"><pre class="fragment"><a name="l00916"></a>00916 {
<a name="l00917"></a>00917    U16 u16_nb_sector_clean;
<a name="l00918"></a>00918    
<a name="l00919"></a>00919    <span class="comment">// Force the flush before clear the buffer</span>
<a name="l00920"></a>00920    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#578ab4800128cde17c0820a5027c1c06">fat_cache_flush</a>())
<a name="l00921"></a>00921       <span class="keywordflow">return</span> FALSE;
<a name="l00922"></a>00922    <a class="code" href="a00017.html#5948c1de515852418670d3fb8ae1e832">fat_cache_clear</a>();
<a name="l00923"></a>00923    
<a name="l00924"></a>00924    <span class="comment">// remark: this zones are storage after the PBR and are continue</span>
<a name="l00925"></a>00925    <span class="comment">// Start after PBR</span>
<a name="l00926"></a>00926    <span class="keywordflow">if</span>( b_MBR )
<a name="l00927"></a>00927    {
<a name="l00928"></a>00928       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = 2; <span class="comment">// Jump MBR and PBR</span>
<a name="l00929"></a>00929    }<span class="keywordflow">else</span>{
<a name="l00930"></a>00930       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = 1; <span class="comment">// Jump only a PBR (no MBR create)</span>
<a name="l00931"></a>00931    }
<a name="l00932"></a>00932    
<a name="l00933"></a>00933    <span class="comment">// Compute reserved zone an root dir zone</span>
<a name="l00934"></a>00934    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00935"></a>00935    {  <span class="comment">// FAT 32</span>
<a name="l00936"></a>00936       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>++;   <span class="comment">// Jump FAT32 FSInfo Sector</span>
<a name="l00937"></a>00937       <span class="comment">// root dir size = cluster size, reserved zone = 32 - 2 (2 = PBR + FSInfo)</span>
<a name="l00938"></a>00938       u16_nb_sector_clean = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a> + 30;
<a name="l00939"></a>00939    }
<a name="l00940"></a>00940    <span class="keywordflow">else</span>
<a name="l00941"></a>00941    {  <span class="comment">// FAT 12 or 16</span>
<a name="l00942"></a>00942       <span class="comment">// root dir size = 512 entrys = 32 sectors, reserved zone = 1 - 1(PBR)</span>
<a name="l00943"></a>00943       u16_nb_sector_clean = 32;
<a name="l00944"></a>00944    }
<a name="l00945"></a>00945    u16_nb_sector_clean += (<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>*2);  <span class="comment">// Add FAT size</span>
<a name="l00946"></a>00946 
<a name="l00947"></a>00947    <span class="comment">// loop to clean</span>
<a name="l00948"></a>00948    <span class="keywordflow">for</span>( ; u16_nb_sector_clean!=0; u16_nb_sector_clean-- )
<a name="l00949"></a>00949    {
<a name="l00950"></a>00950       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l00951"></a>00951          <span class="keywordflow">return</span> FALSE;
<a name="l00952"></a>00952       <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l00953"></a>00953       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>++;   <span class="comment">// Next sector</span>
<a name="l00954"></a>00954    }
<a name="l00955"></a>00955    <span class="keywordflow">return</span> TRUE;
<a name="l00956"></a>00956 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6cc9ee9a14553be84990df27709f51a6"></a><!-- doxytag: member="fat_unusual.c::fat_clear_cluster" ref="6cc9ee9a14553be84990df27709f51a6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_clear_cluster           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction clear a cluster. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! Global variables used
//! IN : 
//!   fs_g_seg.u32_addr          Cluster value to clear
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l02319">2319</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01790">fat_cache_clear()</a>, <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00033.html#l00374">fat_cluster_list()</a>, <a class="el" href="a00034.html#l00230">FS_CLUST_ACT_ONE</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00375">fs_g_seg</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00034.html#l00299">Fs_segment::u32_addr</a>, <a class="el" href="a00034.html#l00300">Fs_segment::u32_size_or_pos</a>, and <a class="el" href="a00034.html#l00263">Fs_management::u8_BPB_SecPerClus</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01872">fat_alloc_entry_free()</a>, and <a class="el" href="a00035.html#l01154">fat_initialize_dir()</a>.<div class="fragment"><pre class="fragment"><a name="l02320"></a>02320 {
<a name="l02321"></a>02321    U8 u8_loop;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323    <span class="comment">// Compute the address sector of cluster</span>
<a name="l02324"></a>02324    <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae">u32_size_or_pos</a>  = 0; <span class="comment">// Select the beginning of cluster</span>
<a name="l02325"></a>02325    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#dd96ad16d133974463fd6a5c4bc8bd5f">fat_cluster_list</a>( <a class="code" href="a00018.html#b24c1ca2a8bc9c3e264eb923d3b90666">FS_CLUST_ACT_ONE</a> ))
<a name="l02326"></a>02326       <span class="keywordflow">return</span> FALSE;
<a name="l02327"></a>02327    
<a name="l02328"></a>02328    <span class="comment">// Loop in the cluster (start at the last sector of cluster)</span>
<a name="l02329"></a>02329    <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#6d934f26f97b442c30712e57ee8b21e5">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172">u32_addr</a> + (<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a> -1);
<a name="l02330"></a>02330    <span class="keywordflow">for</span>(  u8_loop = 0
<a name="l02331"></a>02331    ;     <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a> != u8_loop
<a name="l02332"></a>02332    ;     u8_loop++ )
<a name="l02333"></a>02333    {
<a name="l02334"></a>02334       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l02335"></a>02335          <span class="keywordflow">return</span> FALSE;
<a name="l02336"></a>02336       
<a name="l02337"></a>02337       <span class="keywordflow">if</span>(0 == u8_loop)
<a name="l02338"></a>02338       {  <span class="comment">// Clean buffer only for the first shot</span>
<a name="l02339"></a>02339          <a class="code" href="a00017.html#5948c1de515852418670d3fb8ae1e832">fat_cache_clear</a>();
<a name="l02340"></a>02340       }
<a name="l02341"></a>02341       <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l02342"></a>02342       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>--;   <span class="comment">// go to previous sector</span>
<a name="l02343"></a>02343    }
<a name="l02344"></a>02344    <span class="keywordflow">return</span> TRUE;
<a name="l02345"></a>02345 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9503329592cf7484faf77ca95a6a21aa"></a><!-- doxytag: member="fat_unusual.c::fat_clear_info_fat_mod" ref="9503329592cf7484faf77ca95a6a21aa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_clear_info_fat_mod           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction clear the informations about FAT modification. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l02269">2269</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00034.html#l00383">fs_g_u16_first_mod_fat</a>, and <a class="el" href="a00034.html#l00384">fs_g_u16_last_mod_fat</a>.
<p>
Referenced by <a class="el" href="a00035.html#l02145">fat_allocfreespace()</a>, and <a class="el" href="a00033.html#l00374">fat_cluster_list()</a>.<div class="fragment"><pre class="fragment"><a name="l02270"></a>02270 {
<a name="l02271"></a>02271    <a class="code" href="a00018.html#b55b94c50b63cf8b83e2afcf2e0c2981">fs_g_u16_first_mod_fat</a> = 0xFFFF;
<a name="l02272"></a>02272    <a class="code" href="a00018.html#e8c6fce6d75eb9ddbf1e63e46659e9cc">fs_g_u16_last_mod_fat</a> = 0;
<a name="l02273"></a>02273 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da2110d711208b46e93eb269da40bdf1"></a><!-- doxytag: member="fat_unusual.c::fat_create_entry_file_name" ref="da2110d711208b46e93eb269da40bdf1" args="(FS_STRING sz_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_create_entry_file_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction create a entry file with only the name fields. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_name</em>&nbsp;</td><td>name to create (ASCII or UNICODE)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! IN:
//! b_unicode is a global flag to select UNICODE or ASCII
//! The name must be terminate by NULL and it can't have two '.' character.
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01470">1470</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00035.html#l01872">fat_alloc_entry_free()</a>, <a class="el" href="a00035.html#l01797">fat_check_name()</a>, <a class="el" href="a00035.html#l01526">fat_create_long_name_entry()</a>, <a class="el" href="a00035.html#l01601">fat_create_short_entry_name()</a>, <a class="el" href="a00035.html#l01723">fat_find_short_entry_name()</a>, <a class="el" href="a00033.html#l01184">fat_read_dir()</a>, <a class="el" href="a00034.html#l00188">FS_ENTRY_LFN_LAST</a>, <a class="el" href="a00038.html#l00219">FS_ERR_INCORRECT_NAME</a>, <a class="el" href="a00034.html#l00370">fs_g_nav_fast</a>, <a class="el" href="a00038.html#l00257">fs_g_status</a>, <a class="el" href="a00034.html#l00196">FS_SIZE_LFN_ENTRY</a>, <a class="el" href="a00034.html#l00094">Is_unicode</a>, <a class="el" href="a00034.html#l00279">Fs_management_fast::u16_entry_pos_sel_file</a>, and <a class="el" href="a00033.html#l00351">u8_i</a>.
<p>
Referenced by <a class="el" href="a00042.html#l01994">nav_file_create()</a>.<div class="fragment"><pre class="fragment"><a name="l01471"></a>01471 {
<a name="l01472"></a>01472    U8 <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a>, u8_nb;
<a name="l01473"></a>01473    U8 u8_crc, u8_nb_entry;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475    <span class="comment">// Compute the number of entry for this name</span>
<a name="l01476"></a>01476    u8_nb_entry = <a class="code" href="a00019.html#8849a8388de3f116fd53fd9ec07747b2">fat_check_name</a>( sz_name  );
<a name="l01477"></a>01477    <span class="keywordflow">if</span>( 0 == u8_nb_entry )
<a name="l01478"></a>01478    {
<a name="l01479"></a>01479       <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#6d9fef9edb8adfcebf36e94deab317a2">FS_ERR_INCORRECT_NAME</a>;
<a name="l01480"></a>01480       <span class="keywordflow">return</span> FALSE;
<a name="l01481"></a>01481    }
<a name="l01482"></a>01482    
<a name="l01483"></a>01483    <span class="comment">// search a unik short entry</span>
<a name="l01484"></a>01484    u8_nb = <a class="code" href="a00019.html#24d01b29254a31c7b331935fd8288037">fat_find_short_entry_name</a>( sz_name  );
<a name="l01485"></a>01485    
<a name="l01486"></a>01486    <span class="comment">// Alloc a space for the entrys</span>
<a name="l01487"></a>01487    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a2b4dadfd961b4547fd67f7ebe8a5c5d">fat_alloc_entry_free</a>( u8_nb_entry ))
<a name="l01488"></a>01488       <span class="keywordflow">return</span> FALSE;
<a name="l01489"></a>01489    <span class="comment">// Remark: here the pointer of entry is on the last free entry of new space entry</span>
<a name="l01490"></a>01490 
<a name="l01491"></a>01491    <span class="comment">// Add short name entry</span>
<a name="l01492"></a>01492    u8_crc = <a class="code" href="a00019.html#49163f06665633236c432aa1a1163f01">fat_create_short_entry_name</a>( sz_name , 0 , u8_nb, FALSE  );
<a name="l01493"></a>01493    u8_nb_entry--;
<a name="l01494"></a>01494    
<a name="l01495"></a>01495    <span class="comment">// For each long name entry</span>
<a name="l01496"></a>01496    <span class="keywordflow">for</span>( u8_i=1 ; u8_i&lt;=u8_nb_entry ; u8_i++ )
<a name="l01497"></a>01497    {
<a name="l01498"></a>01498       <span class="comment">// Go to previous entry</span>
<a name="l01499"></a>01499       <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04">u16_entry_pos_sel_file</a>--;
<a name="l01500"></a>01500       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#1a35321a99150ba643f87cb6c79ec3e5">fat_read_dir</a>())
<a name="l01501"></a>01501          <span class="keywordflow">return</span> FALSE;
<a name="l01502"></a>01502       <span class="comment">// create a long name entry</span>
<a name="l01503"></a>01503       <span class="keywordflow">if</span>( u8_i == u8_nb_entry )
<a name="l01504"></a>01504       {
<a name="l01505"></a>01505          u8_i += <a class="code" href="a00018.html#bf0fa999d28907c3742656b6407aca78">FS_ENTRY_LFN_LAST</a>;
<a name="l01506"></a>01506       }
<a name="l01507"></a>01507       <a class="code" href="a00019.html#70a6be69645d22685e0ec6b52b93d9b2">fat_create_long_name_entry</a>( sz_name , u8_crc , u8_i );
<a name="l01508"></a>01508       sz_name += <a class="code" href="a00018.html#bbdca2b90701f373bf6c865c88c99697">FS_SIZE_LFN_ENTRY</a>*(<a class="code" href="a00018.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01509"></a>01509   }
<a name="l01510"></a>01510   <span class="comment">// go back to the short entry</span>
<a name="l01511"></a>01511   <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04">u16_entry_pos_sel_file</a> += u8_nb_entry;
<a name="l01512"></a>01512   <span class="keywordflow">return</span> TRUE;
<a name="l01513"></a>01513 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="70a6be69645d22685e0ec6b52b93d9b2"></a><!-- doxytag: member="fat_unusual.c::fat_create_long_name_entry" ref="70a6be69645d22685e0ec6b52b93d9b2" args="(FS_STRING sz_name, U8 u8_crc, U8 u8_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_create_long_name_entry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction create a long entry file in the current entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_name</em>&nbsp;</td><td>name to create (ASCII or UNICODE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u8_crc</em>&nbsp;</td><td>crc corresponding at short name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u8_id</em>&nbsp;</td><td>long entry number (1 to n + FS_ENTRY_LFN_LAST)</td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment">
//! OUT: Update the entry in cache sector with the long name entry
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01526">1526</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00038.html#l00136">FS_ATTR_LFN_ENTRY</a>, <a class="el" href="a00034.html#l00194">FS_SIZE_FILE_ENTRY</a>, and <a class="el" href="a00034.html#l00094">Is_unicode</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01470">fat_create_entry_file_name()</a>.<div class="fragment"><pre class="fragment"><a name="l01527"></a>01527 {
<a name="l01528"></a>01528    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01529"></a>01529    Bool b_end_of_name = FALSE;
<a name="l01530"></a>01530   
<a name="l01531"></a>01531    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01532"></a>01532    ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01533"></a>01533    *ptr_entry = u8_id;
<a name="l01534"></a>01534    ptr_entry++; <span class="comment">// The long name start at offset 1 of the entry file</span>
<a name="l01535"></a>01535 
<a name="l01536"></a>01536    <span class="keywordflow">for</span>( u8_id=1; u8_id&lt;<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a> ; u8_id++ , ptr_entry++ )
<a name="l01537"></a>01537    {
<a name="l01538"></a>01538       <span class="comment">// fields with no characters</span>
<a name="l01539"></a>01539       <span class="keywordflow">if</span>( 11 == u8_id)
<a name="l01540"></a>01540       {
<a name="l01541"></a>01541          *ptr_entry = <a class="code" href="a00022.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a>;  <span class="comment">// attribut field</span>
<a name="l01542"></a>01542          <span class="keywordflow">continue</span>;
<a name="l01543"></a>01543       }
<a name="l01544"></a>01544       <span class="keywordflow">if</span>( (12 == u8_id)
<a name="l01545"></a>01545       ||  (26 == u8_id)
<a name="l01546"></a>01546       ||  (27 == u8_id) )
<a name="l01547"></a>01547       {
<a name="l01548"></a>01548          <span class="comment">// Reserved field</span>
<a name="l01549"></a>01549          <span class="comment">// *ptr_entry = 0x00; // Not necessary because the cache must be clean</span>
<a name="l01550"></a>01550          <span class="keywordflow">continue</span>;
<a name="l01551"></a>01551       }
<a name="l01552"></a>01552       <span class="keywordflow">if</span>( 13 == u8_id)
<a name="l01553"></a>01553       {
<a name="l01554"></a>01554          *ptr_entry = u8_crc;          <span class="comment">// CRC field</span>
<a name="l01555"></a>01555          <span class="keywordflow">continue</span>;
<a name="l01556"></a>01556       }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558       <span class="comment">// fields with characters</span>
<a name="l01559"></a>01559       <span class="keywordflow">if</span>( !b_end_of_name )
<a name="l01560"></a>01560       {
<a name="l01561"></a>01561          U16 u16_tmp;
<a name="l01562"></a>01562          <span class="keywordflow">if</span>( <a class="code" href="a00018.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a> )
<a name="l01563"></a>01563          {
<a name="l01564"></a>01564             u16_tmp = ((<a class="code" href="a00022.html#4b07eeef6c66c629ec6708f8eee35f58">FS_STR_UNICODE</a>)sz_name)[0];
<a name="l01565"></a>01565          }<span class="keywordflow">else</span>{
<a name="l01566"></a>01566             u16_tmp = sz_name[0];
<a name="l01567"></a>01567          }
<a name="l01568"></a>01568          <span class="keywordflow">if</span>((<span class="charliteral">'\\'</span> == u16_tmp )
<a name="l01569"></a>01569          || (<span class="charliteral">'/'</span>  == u16_tmp ) )
<a name="l01570"></a>01570          {  <span class="comment">// end of name</span>
<a name="l01571"></a>01571             u16_tmp = 0;   <span class="comment">// set string flag end of name</span>
<a name="l01572"></a>01572          }
<a name="l01573"></a>01573          <span class="keywordflow">if</span>( 0 == u16_tmp )
<a name="l01574"></a>01574          {
<a name="l01575"></a>01575             b_end_of_name = TRUE;
<a name="l01576"></a>01576          }
<a name="l01577"></a>01577          *ptr_entry = LSB(u16_tmp);
<a name="l01578"></a>01578          ptr_entry++;
<a name="l01579"></a>01579          *ptr_entry = MSB(u16_tmp);
<a name="l01580"></a>01580          u8_id++;
<a name="l01581"></a>01581          sz_name += (Is_unicode? 2 : 1 );
<a name="l01582"></a>01582       }
<a name="l01583"></a>01583       <span class="keywordflow">else</span>
<a name="l01584"></a>01584       {  <span class="comment">// end of name</span>
<a name="l01585"></a>01585          *ptr_entry = 0xFF;         <span class="comment">// Padding mandatory</span>
<a name="l01586"></a>01586       }
<a name="l01587"></a>01587    } <span class="comment">// end of loop in long entry</span>
<a name="l01588"></a>01588 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="49163f06665633236c432aa1a1163f01"></a><!-- doxytag: member="fat_unusual.c::fat_create_short_entry_name" ref="49163f06665633236c432aa1a1163f01" args="(FS_STRING sz_name, FS_STRING short_name, U8 nb, Bool mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 fat_create_short_entry_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>short_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction create a short name entry in the cache sector OR in a string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_name</em>&nbsp;</td><td>name to create (ASCII or UNICODE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>short_name</em>&nbsp;</td><td>short name format entry ( = 8+3 Bytes) (used only if mode = TRUE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb</em>&nbsp;</td><td>number add at short name (ex: name~nb) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>TRUE to give the short name <br>
 FALSE to create a entry in the entry in cache sector</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the CRC of the short name </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01601">1601</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00033.html#l01710">fat_check_eof_name()</a>, <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00035.html#l01842">fat_translate_char_shortname()</a>, <a class="el" href="a00034.html#l00197">FS_SIZE_SFNAME</a>, <a class="el" href="a00034.html#l00198">FS_SIZE_SFNAME_WITHOUT_EXT</a>, <a class="el" href="a00034.html#l00094">Is_unicode</a>, and <a class="el" href="a00033.html#l00351">u8_i</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01470">fat_create_entry_file_name()</a>, and <a class="el" href="a00035.html#l01723">fat_find_short_entry_name()</a>.<div class="fragment"><pre class="fragment"><a name="l01602"></a>01602 {
<a name="l01603"></a>01603    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry = 0;
<a name="l01604"></a>01604    U8 <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a>, u8_step, character;
<a name="l01605"></a>01605    U8 crc;
<a name="l01606"></a>01606 
<a name="l01607"></a>01607    <span class="keywordflow">if</span>( !mode )
<a name="l01608"></a>01608    {
<a name="l01609"></a>01609       <span class="comment">// Modify entry to create short entry in the current entry </span>
<a name="l01610"></a>01610       <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01611"></a>01611       <span class="comment">// Get entry to store the short name</span>
<a name="l01612"></a>01612       ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01613"></a>01613    }
<a name="l01614"></a>01614 
<a name="l01615"></a>01615    crc = u8_step = u8_i = 0;
<a name="l01616"></a>01616    <span class="keywordflow">while</span>( 1 )
<a name="l01617"></a>01617    {
<a name="l01618"></a>01618       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a> )
<a name="l01619"></a>01619       {
<a name="l01620"></a>01620          character = ((<a class="code" href="a00022.html#4b07eeef6c66c629ec6708f8eee35f58">FS_STR_UNICODE</a>)sz_name)[0];
<a name="l01621"></a>01621       }<span class="keywordflow">else</span>{
<a name="l01622"></a>01622          character = sz_name[0];
<a name="l01623"></a>01623       }
<a name="l01624"></a>01624 
<a name="l01625"></a>01625       <span class="keywordflow">if</span>( 0 == u8_step )
<a name="l01626"></a>01626       {  <span class="comment">// step 1 = translate the name</span>
<a name="l01627"></a>01627          <span class="keywordflow">if</span>( ((<a class="code" href="a00018.html#18e4c969985c697213c58a67e7c20795">FS_SIZE_SFNAME_WITHOUT_EXT</a>-2) == u8_i)    <span class="comment">// name field is full (-2 for "~1")</span>
<a name="l01628"></a>01628          ||  (<span class="charliteral">'.'</span>    == character)                       <span class="comment">// is the end of name without extension</span>
<a name="l01629"></a>01629          ||  <a class="code" href="a00017.html#452e159ed5e2a4d8ea88f0515a3a6e10">fat_check_eof_name</a>(character)            )  <span class="comment">// is the end of name</span>
<a name="l01630"></a>01630          {
<a name="l01631"></a>01631             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01632"></a>01632             <span class="keywordflow">continue</span>;
<a name="l01633"></a>01633          }
<a name="l01634"></a>01634       }
<a name="l01635"></a>01635       <span class="keywordflow">if</span>( 5 == u8_step )
<a name="l01636"></a>01636       {  <span class="comment">// step 6 = translate the extension</span>
<a name="l01637"></a>01637          <span class="keywordflow">if</span>( (u8_i == <a class="code" href="a00018.html#69da5456f1f42a68c03ac860e33ac75b">FS_SIZE_SFNAME</a>)                    <span class="comment">// name field is full</span>
<a name="l01638"></a>01638          ||  <a class="code" href="a00017.html#452e159ed5e2a4d8ea88f0515a3a6e10">fat_check_eof_name</a>(character)            )  <span class="comment">// is the end of name</span>
<a name="l01639"></a>01639          {
<a name="l01640"></a>01640             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01641"></a>01641             <span class="keywordflow">continue</span>;
<a name="l01642"></a>01642          }
<a name="l01643"></a>01643       }
<a name="l01644"></a>01644       <span class="keywordflow">if</span>( (0==u8_step) || (5==u8_step) )
<a name="l01645"></a>01645       {  <span class="comment">// steps to translate name</span>
<a name="l01646"></a>01646          character = <a class="code" href="a00019.html#bb2561113110b35fac032431243f8bb0">fat_translate_char_shortname</a>( character );
<a name="l01647"></a>01647          sz_name += (<a class="code" href="a00018.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01648"></a>01648          <span class="keywordflow">if</span>( 0 == character )
<a name="l01649"></a>01649          {
<a name="l01650"></a>01650             <span class="keywordflow">continue</span>;                                    <span class="comment">// Bad character, ignore this one</span>
<a name="l01651"></a>01651          }
<a name="l01652"></a>01652       }
<a name="l01653"></a>01653       <span class="keywordflow">if</span>( 4 == u8_step )
<a name="l01654"></a>01654       {  <span class="comment">// step 5 = find character '.'</span>
<a name="l01655"></a>01655          <span class="keywordflow">if</span>( (<span class="charliteral">'.'</span>    == character)                       <span class="comment">// is the end of name without extension</span>
<a name="l01656"></a>01656          ||  <a class="code" href="a00017.html#452e159ed5e2a4d8ea88f0515a3a6e10">fat_check_eof_name</a>(character)            )  <span class="comment">// is the end of name</span>
<a name="l01657"></a>01657          {
<a name="l01658"></a>01658             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01659"></a>01659          } <span class="keywordflow">else</span> {
<a name="l01660"></a>01660             sz_name += (<a class="code" href="a00018.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01661"></a>01661          }
<a name="l01662"></a>01662          <span class="keywordflow">continue</span>;                                       <span class="comment">// this step don't add a character in the short name</span>
<a name="l01663"></a>01663       }
<a name="l01664"></a>01664       <span class="keywordflow">if</span>( 3 == u8_step )
<a name="l01665"></a>01665       {  <span class="comment">// step 4 = add padding</span>
<a name="l01666"></a>01666          <span class="keywordflow">if</span>( u8_i == <a class="code" href="a00018.html#18e4c969985c697213c58a67e7c20795">FS_SIZE_SFNAME_WITHOUT_EXT</a> )        <span class="comment">// end of field name without extension</span>
<a name="l01667"></a>01667          {
<a name="l01668"></a>01668             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01669"></a>01669             <span class="keywordflow">continue</span>;
<a name="l01670"></a>01670          }
<a name="l01671"></a>01671          character = <span class="charliteral">' '</span>;
<a name="l01672"></a>01672       }
<a name="l01673"></a>01673       <span class="keywordflow">if</span>( 6 == u8_step )
<a name="l01674"></a>01674       {  <span class="comment">// step 7 = add padding in extension name</span>
<a name="l01675"></a>01675          <span class="keywordflow">if</span>( u8_i == <a class="code" href="a00018.html#69da5456f1f42a68c03ac860e33ac75b">FS_SIZE_SFNAME</a> )                    <span class="comment">// end of field name with extension</span>
<a name="l01676"></a>01676          {
<a name="l01677"></a>01677             <span class="keywordflow">break</span>;                                       <span class="comment">// end of loop while(1)</span>
<a name="l01678"></a>01678          }
<a name="l01679"></a>01679          character = <span class="charliteral">' '</span>;
<a name="l01680"></a>01680       }
<a name="l01681"></a>01681       <span class="keywordflow">if</span>( 2 == u8_step )
<a name="l01682"></a>01682       {  <span class="comment">// step 3 = add the last caracter (it is a number)</span>
<a name="l01683"></a>01683          character = <span class="charliteral">'0'</span>+(nb%10);
<a name="l01684"></a>01684          u8_step++;                                      <span class="comment">// go to next step</span>
<a name="l01685"></a>01685       }
<a name="l01686"></a>01686       <span class="keywordflow">if</span>( 1 == u8_step )
<a name="l01687"></a>01687       {  <span class="comment">// step 2 = add character '~' or number</span>
<a name="l01688"></a>01688          <span class="keywordflow">if</span>( nb&lt;10 )
<a name="l01689"></a>01689          {
<a name="l01690"></a>01690             character = <span class="charliteral">'~'</span>;
<a name="l01691"></a>01691          }<span class="keywordflow">else</span>{
<a name="l01692"></a>01692             character = <span class="charliteral">'0'</span>+(nb/10);
<a name="l01693"></a>01693          }
<a name="l01694"></a>01694          u8_step++;                                      <span class="comment">// go to next step</span>
<a name="l01695"></a>01695       }
<a name="l01696"></a>01696       
<a name="l01697"></a>01697       <span class="keywordflow">if</span>( mode )
<a name="l01698"></a>01698       {
<a name="l01699"></a>01699          <span class="comment">// Record the short name in buffer</span>
<a name="l01700"></a>01700          *short_name = character;
<a name="l01701"></a>01701          short_name++;
<a name="l01702"></a>01702       }<span class="keywordflow">else</span>{
<a name="l01703"></a>01703          <span class="comment">// Record the character in short entry file</span>
<a name="l01704"></a>01704          *ptr_entry = character;
<a name="l01705"></a>01705          ptr_entry++;
<a name="l01706"></a>01706       }
<a name="l01707"></a>01707       u8_i++;
<a name="l01708"></a>01708       
<a name="l01709"></a>01709       <span class="comment">// Compute the CRC of the short name</span>
<a name="l01710"></a>01710       crc = (crc &gt;&gt; 1) + ((crc &amp; 1) &lt;&lt; 7);               <span class="comment">// rotate</span>
<a name="l01711"></a>01711       crc += character;                                  <span class="comment">// add next char</span>
<a name="l01712"></a>01712    } <span class="comment">// End of loop while</span>
<a name="l01713"></a>01713    <span class="keywordflow">return</span> crc;
<a name="l01714"></a>01714 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="797fc629a4a513e6a5f2951720da5d47"></a><!-- doxytag: member="fat_unusual.c::fat_delete_file" ref="797fc629a4a513e6a5f2951720da5d47" args="(Bool b_cluster_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_delete_file           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>b_cluster_list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction delete the file entrys and cluster list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b_cluster_list</em>&nbsp;</td><td>TRUE, delete entrys file and cluster list FALSE, delete only entrys file</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01928">1928</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00033.html#l01184">fat_read_dir()</a>, <a class="el" href="a00033.html#l01026">fat_read_file()</a>, <a class="el" href="a00038.html#l00136">FS_ATTR_LFN_ENTRY</a>, <a class="el" href="a00034.html#l00231">FS_CLUST_ACT_CLR</a>, <a class="el" href="a00034.html#l00187">FS_ENTRY_DEL</a>, <a class="el" href="a00034.html#l00188">FS_ENTRY_LFN_LAST</a>, <a class="el" href="a00034.html#l00371">fs_g_nav_entry</a>, <a class="el" href="a00034.html#l00370">fs_g_nav_fast</a>, <a class="el" href="a00034.html#l00279">Fs_management_fast::u16_entry_pos_sel_file</a>, and <a class="el" href="a00034.html#l00289">Fs_management_entry::u32_pos_in_file</a>.
<p>
Referenced by <a class="el" href="a00042.html#l01855">nav_file_del()</a>, and <a class="el" href="a00042.html#l01933">nav_file_rename()</a>.<div class="fragment"><pre class="fragment"><a name="l01929"></a>01929 {
<a name="l01930"></a>01930    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01931"></a>01931    U8 u8_tmp;
<a name="l01932"></a>01932    Bool b_short_del = FALSE;
<a name="l01933"></a>01933 
<a name="l01934"></a>01934    <span class="comment">// loop in directory</span>
<a name="l01935"></a>01935    <span class="keywordflow">while</span>( 1 )
<a name="l01936"></a>01936    {
<a name="l01937"></a>01937       <span class="comment">// Read current sector directory</span>
<a name="l01938"></a>01938       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#1a35321a99150ba643f87cb6c79ec3e5">fat_read_dir</a>() )
<a name="l01939"></a>01939          <span class="keywordflow">return</span> FALSE;
<a name="l01940"></a>01940 
<a name="l01941"></a>01941       <span class="comment">// Get entry</span>
<a name="l01942"></a>01942       ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01943"></a>01943       u8_tmp = ptr_entry[0];
<a name="l01944"></a>01944 
<a name="l01945"></a>01945       <span class="keywordflow">if</span>( (<a class="code" href="a00022.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a> != ptr_entry[11])
<a name="l01946"></a>01946       &amp;&amp;  (b_short_del) )
<a name="l01947"></a>01947       {
<a name="l01948"></a>01948          <span class="comment">// Only a short entry to del, no long entry exist</span>
<a name="l01949"></a>01949          <span class="keywordflow">break</span>;   <span class="comment">// Go to del cluster list</span>
<a name="l01950"></a>01950       }
<a name="l01951"></a>01951 
<a name="l01952"></a>01952       <span class="comment">// Delete entry</span>
<a name="l01953"></a>01953       b_short_del = TRUE;
<a name="l01954"></a>01954       ptr_entry[0] = <a class="code" href="a00018.html#303c1237fa5a61ddc015c0365eedd008">FS_ENTRY_DEL</a>;
<a name="l01955"></a>01955       <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01956"></a>01956 
<a name="l01957"></a>01957       <span class="keywordflow">if</span>( (<a class="code" href="a00022.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a> == ptr_entry[11])        <span class="comment">// a entry long name</span>
<a name="l01958"></a>01958       &amp;&amp;  ( 0 != (<a class="code" href="a00018.html#bf0fa999d28907c3742656b6407aca78">FS_ENTRY_LFN_LAST</a> &amp; u8_tmp)) )      <span class="comment">// last entry long name</span>
<a name="l01959"></a>01959       {
<a name="l01960"></a>01960          <span class="keywordflow">break</span>;   <span class="comment">// Go to del cluster list</span>
<a name="l01961"></a>01961       }
<a name="l01962"></a>01962 
<a name="l01963"></a>01963       <span class="comment">// go to previous entry</span>
<a name="l01964"></a>01964       <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04">u16_entry_pos_sel_file</a>--;
<a name="l01965"></a>01965    }  <span class="comment">// end of while(1)</span>
<a name="l01966"></a>01966 
<a name="l01967"></a>01967    <span class="keywordflow">if</span>( b_cluster_list )
<a name="l01968"></a>01968    {
<a name="l01969"></a>01969       <span class="comment">// Delete cluster list</span>
<a name="l01970"></a>01970       <a class="code" href="a00018.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#1e1dae249ae6839c1b8cce0fecbbf7af">u32_pos_in_file</a>=0;   <span class="comment">// Del ALL list (start at begining)</span>
<a name="l01971"></a>01971       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#d8c9c9a63c821e8cea06c340c029668d">fat_read_file</a>( <a class="code" href="a00018.html#b314d14ba33772e9bcbae993a8d17e9f">FS_CLUST_ACT_CLR</a> ))
<a name="l01972"></a>01972          <span class="keywordflow">return</span> FALSE;
<a name="l01973"></a>01973    }
<a name="l01974"></a>01974 
<a name="l01975"></a>01975    <span class="keywordflow">return</span> TRUE;
<a name="l01976"></a>01976 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a03d2728f28964e1eb4d78c2bb831718"></a><!-- doxytag: member="fat_unusual.c::fat_entry_label" ref="a03d2728f28964e1eb4d78c2bb831718" args="(Bool b_action, FS_STRING sz_label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_entry_label           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>b_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_label</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction to read or to write a label. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b_action</em>&nbsp;</td><td>choose action (FS_LABEL_READ or FS_LABEL_WRITE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sz_label</em>&nbsp;</td><td>string ASCII to store labe (11B min) or to get new label (11B max)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01061">1061</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01810">fat_cache_flush()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00038.html#l00133">FS_ATTR_VOLUME_ID</a>, <a class="el" href="a00034.html#l00186">FS_ENTRY_END</a>, <a class="el" href="a00038.html#l00202">FS_ERR_ENTRY_BAD</a>, <a class="el" href="a00038.html#l00201">FS_ERR_ENTRY_EMPTY</a>, <a class="el" href="a00038.html#l00213">FS_ERR_NAME_INCORRECT</a>, <a class="el" href="a00038.html#l00257">fs_g_status</a>, <a class="el" href="a00038.html#l00098">FS_LABEL_READ</a>, and <a class="el" href="a00038.html#l00099">FS_LABEL_WRITE</a>.
<p>
Referenced by <a class="el" href="a00042.html#l00441">nav_partition_label()</a>.<div class="fragment"><pre class="fragment"><a name="l01062"></a>01062 {
<a name="l01063"></a>01063    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01064"></a>01064    U8 u8_pos_name;
<a name="l01065"></a>01065    U8 u8_char;
<a name="l01066"></a>01066    
<a name="l01067"></a>01067    ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01068"></a>01068    
<a name="l01069"></a>01069    <span class="keywordflow">if</span>( <a class="code" href="a00022.html#c1570dd392605e8ff8f7d4cb16487830">FS_LABEL_READ</a> == b_action)
<a name="l01070"></a>01070    {   
<a name="l01071"></a>01071       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> == ptr_entry[0] )          <span class="comment">// end of directory</span>
<a name="l01072"></a>01072       {
<a name="l01073"></a>01073          <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#33817136df196a5f0146574b4e1775b6">FS_ERR_ENTRY_EMPTY</a>;
<a name="l01074"></a>01074          <span class="keywordflow">return</span> FALSE;
<a name="l01075"></a>01075       }
<a name="l01076"></a>01076       <span class="keywordflow">if</span>( <a class="code" href="a00022.html#4ed995c53b13fcf1694ae3ba6da61eba">FS_ATTR_VOLUME_ID</a> != ptr_entry[11])   <span class="comment">// no system label</span>
<a name="l01077"></a>01077       {
<a name="l01078"></a>01078          <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#934f48a8e1cb558d75ec00bbd242030d">FS_ERR_ENTRY_BAD</a>;
<a name="l01079"></a>01079          <span class="keywordflow">return</span> FALSE;
<a name="l01080"></a>01080       }
<a name="l01081"></a>01081       <span class="keywordflow">if</span>( NULL == sz_label )
<a name="l01082"></a>01082          <span class="keywordflow">return</span> TRUE;
<a name="l01083"></a>01083       <span class="keywordflow">for</span>( u8_pos_name=0; u8_pos_name&lt;11; u8_pos_name++ )
<a name="l01084"></a>01084       {  
<a name="l01085"></a>01085          u8_char = *ptr_entry;
<a name="l01086"></a>01086          <span class="keywordflow">if</span>( 0x20 == u8_char )
<a name="l01087"></a>01087             u8_char = 0;
<a name="l01088"></a>01088          *sz_label = u8_char; 
<a name="l01089"></a>01089          <span class="keywordflow">if</span>( 0 == u8_char )
<a name="l01090"></a>01090             <span class="keywordflow">return</span> TRUE;   <span class="comment">// Finish to read name</span>
<a name="l01091"></a>01091          ptr_entry++;
<a name="l01092"></a>01092          sz_label++;
<a name="l01093"></a>01093       }
<a name="l01094"></a>01094       *sz_label = 0; 
<a name="l01095"></a>01095       <span class="keywordflow">return</span> TRUE;
<a name="l01096"></a>01096    }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098    <span class="keywordflow">if</span>( <a class="code" href="a00022.html#c5e191f04380ef238255929695f8efcb">FS_LABEL_WRITE</a> == b_action)
<a name="l01099"></a>01099    {   
<a name="l01100"></a>01100       <span class="comment">// Autorize write label only on empty entry or system label entry</span>
<a name="l01101"></a>01101       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> != ptr_entry[0] )          <span class="comment">// end of directory</span>
<a name="l01102"></a>01102       {
<a name="l01103"></a>01103          <span class="keywordflow">if</span>( <a class="code" href="a00022.html#4ed995c53b13fcf1694ae3ba6da61eba">FS_ATTR_VOLUME_ID</a> != ptr_entry[11])   <span class="comment">// no system label</span>
<a name="l01104"></a>01104          {
<a name="l01105"></a>01105             <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#934f48a8e1cb558d75ec00bbd242030d">FS_ERR_ENTRY_BAD</a>;
<a name="l01106"></a>01106             <span class="keywordflow">return</span> FALSE;
<a name="l01107"></a>01107          }
<a name="l01108"></a>01108       }
<a name="l01109"></a>01109       <span class="keywordflow">if</span>( 0 == *sz_label )
<a name="l01110"></a>01110       {
<a name="l01111"></a>01111          <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#5ea145bbe1eb7413020b5e6b6f12a1ba">FS_ERR_NAME_INCORRECT</a>;
<a name="l01112"></a>01112          <span class="keywordflow">return</span> FALSE;
<a name="l01113"></a>01113       }
<a name="l01114"></a>01114       ptr_entry[11] = <a class="code" href="a00022.html#4ed995c53b13fcf1694ae3ba6da61eba">FS_ATTR_VOLUME_ID</a>;
<a name="l01115"></a>01115       <span class="keywordflow">for</span>( u8_pos_name=0; u8_pos_name&lt;11; u8_pos_name++ )
<a name="l01116"></a>01116       {  
<a name="l01117"></a>01117          u8_char = *sz_label; 
<a name="l01118"></a>01118          <span class="keywordflow">if</span>( (<span class="charliteral">'a'</span>&lt;=u8_char) &amp;&amp; (u8_char&lt;=<span class="charliteral">'z'</span>) )
<a name="l01119"></a>01119          {
<a name="l01120"></a>01120             u8_char -= (<span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>);   <span class="comment">// Change to upper case</span>
<a name="l01121"></a>01121          }
<a name="l01122"></a>01122          <span class="keywordflow">if</span>( 0 == u8_char )
<a name="l01123"></a>01123          {
<a name="l01124"></a>01124             u8_char = 0x20;
<a name="l01125"></a>01125          }
<a name="l01126"></a>01126          *ptr_entry = u8_char;
<a name="l01127"></a>01127          ptr_entry++;
<a name="l01128"></a>01128          <span class="keywordflow">if</span>( 0x20 == u8_char )
<a name="l01129"></a>01129             <span class="keywordflow">continue</span>;
<a name="l01130"></a>01130          sz_label++;
<a name="l01131"></a>01131       }
<a name="l01132"></a>01132       <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01133"></a>01133       <span class="keywordflow">return</span> <a class="code" href="a00017.html#578ab4800128cde17c0820a5027c1c06">fat_cache_flush</a>();
<a name="l01134"></a>01134    }
<a name="l01135"></a>01135    <span class="keywordflow">return</span> FALSE;  <span class="comment">// To del a warning compilation</span>
<a name="l01136"></a>01136 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="19c7a66123aba4a4a705623085c03f6f"></a><!-- doxytag: member="fat_unusual.c::fat_entry_shortname_compare" ref="19c7a66123aba4a4a705623085c03f6f" args="(FS_STRING short_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_entry_shortname_compare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>short_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction compare the short name with current entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>short_name</em>&nbsp;</td><td>short name format entry (= 8+3 Bytes)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE it is the same <p>
FALSE in case of error, see global value "fs_g_status" for more detail </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01767">1767</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00038.html#l00136">FS_ATTR_LFN_ENTRY</a>, <a class="el" href="a00034.html#l00187">FS_ENTRY_DEL</a>, <a class="el" href="a00034.html#l00186">FS_ENTRY_END</a>, <a class="el" href="a00038.html#l00202">FS_ERR_ENTRY_BAD</a>, <a class="el" href="a00038.html#l00201">FS_ERR_ENTRY_EMPTY</a>, and <a class="el" href="a00038.html#l00257">fs_g_status</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01723">fat_find_short_entry_name()</a>.<div class="fragment"><pre class="fragment"><a name="l01768"></a>01768 {
<a name="l01769"></a>01769    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01770"></a>01770 
<a name="l01771"></a>01771    ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01772"></a>01772    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> == *ptr_entry )             <span class="comment">// end of directory</span>
<a name="l01773"></a>01773    {
<a name="l01774"></a>01774       <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#33817136df196a5f0146574b4e1775b6">FS_ERR_ENTRY_EMPTY</a>;
<a name="l01775"></a>01775       <span class="keywordflow">return</span> FALSE;
<a name="l01776"></a>01776    }
<a name="l01777"></a>01777    <span class="keywordflow">if</span>( (<a class="code" href="a00018.html#303c1237fa5a61ddc015c0365eedd008">FS_ENTRY_DEL</a> == *ptr_entry )            <span class="comment">// entry deleted</span>
<a name="l01778"></a>01778    ||  (<a class="code" href="a00022.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a> == ptr_entry[11]) )   <span class="comment">// long file name</span>
<a name="l01779"></a>01779    {
<a name="l01780"></a>01780       <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#934f48a8e1cb558d75ec00bbd242030d">FS_ERR_ENTRY_BAD</a>;
<a name="l01781"></a>01781       <span class="keywordflow">return</span> FALSE;
<a name="l01782"></a>01782    }
<a name="l01783"></a>01783    <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#934f48a8e1cb558d75ec00bbd242030d">FS_ERR_ENTRY_BAD</a>;  <span class="comment">// by default this entry is different then bad</span>
<a name="l01784"></a>01784    <span class="keywordflow">return</span> (0==memcmp_ram2ram(ptr_entry , short_name , 8+3 ));
<a name="l01785"></a>01785 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="24d01b29254a31c7b331935fd8288037"></a><!-- doxytag: member="fat_unusual.c::fat_find_short_entry_name" ref="24d01b29254a31c7b331935fd8288037" args="(FS_STRING sz_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 fat_find_short_entry_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction research a unique short name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_name</em>&nbsp;</td><td>long name to use</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number used for the short name </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01723">1723</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00035.html#l01601">fat_create_short_entry_name()</a>, <a class="el" href="a00035.html#l01767">fat_entry_shortname_compare()</a>, <a class="el" href="a00033.html#l01184">fat_read_dir()</a>, <a class="el" href="a00038.html#l00201">FS_ERR_ENTRY_EMPTY</a>, <a class="el" href="a00038.html#l00217">FS_ERR_OUT_LIST</a>, <a class="el" href="a00034.html#l00370">fs_g_nav_fast</a>, <a class="el" href="a00038.html#l00257">fs_g_status</a>, and <a class="el" href="a00034.html#l00279">Fs_management_fast::u16_entry_pos_sel_file</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01470">fat_create_entry_file_name()</a>.<div class="fragment"><pre class="fragment"><a name="l01724"></a>01724 {
<a name="l01725"></a>01725    U8 u8_nb = 0;
<a name="l01726"></a>01726    U8 _MEM_TYPE_SLOW_ short_name[11];
<a name="l01727"></a>01727 
<a name="l01728"></a>01728    u8_nb = 0; <span class="comment">// Init to first shprt name</span>
<a name="l01729"></a>01729 
<a name="l01730"></a>01730    <span class="keywordflow">while</span>(1)
<a name="l01731"></a>01731    {
<a name="l01732"></a>01732       u8_nb++; <span class="comment">// Try next short name</span>
<a name="l01733"></a>01733       <span class="comment">// Compute the short name</span>
<a name="l01734"></a>01734       <a class="code" href="a00019.html#49163f06665633236c432aa1a1163f01">fat_create_short_entry_name</a>( sz_name , short_name , u8_nb , TRUE  );
<a name="l01735"></a>01735       <span class="comment">// Go to beginning of directory</span>
<a name="l01736"></a>01736       <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04">u16_entry_pos_sel_file</a> = 0;
<a name="l01737"></a>01737       <span class="comment">// Scan directory to find a short entry</span>
<a name="l01738"></a>01738       <span class="keywordflow">while</span>(1)
<a name="l01739"></a>01739       {
<a name="l01740"></a>01740          <span class="comment">// Read directory</span>
<a name="l01741"></a>01741          <span class="keywordflow">if</span> ( !<a class="code" href="a00017.html#1a35321a99150ba643f87cb6c79ec3e5">fat_read_dir</a>())
<a name="l01742"></a>01742          {
<a name="l01743"></a>01743             <span class="keywordflow">if</span>( <a class="code" href="a00022.html#e8798a89bfc4f49da50fc55b14a5b07f">FS_ERR_OUT_LIST</a> == <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> )
<a name="l01744"></a>01744                <span class="keywordflow">return</span> u8_nb;  <span class="comment">// short name not exist, then good number</span>
<a name="l01745"></a>01745             <span class="keywordflow">else</span>
<a name="l01746"></a>01746                <span class="keywordflow">return</span> 1; <span class="comment">// Error but ignore</span>
<a name="l01747"></a>01747          }
<a name="l01748"></a>01748          <span class="comment">// check entry</span>
<a name="l01749"></a>01749          <span class="keywordflow">if</span>( <a class="code" href="a00019.html#19c7a66123aba4a4a705623085c03f6f">fat_entry_shortname_compare</a>( short_name ) )
<a name="l01750"></a>01750             <span class="keywordflow">break</span>; <span class="comment">// short name exist</span>
<a name="l01751"></a>01751          <span class="keywordflow">if</span>( <a class="code" href="a00022.html#33817136df196a5f0146574b4e1775b6">FS_ERR_ENTRY_EMPTY</a> == <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> )
<a name="l01752"></a>01752             <span class="keywordflow">return</span> u8_nb;  <span class="comment">// short name not exist, then good number</span>
<a name="l01753"></a>01753          <span class="comment">// Go to next entry</span>
<a name="l01754"></a>01754          <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04">u16_entry_pos_sel_file</a>++;
<a name="l01755"></a>01755       }
<a name="l01756"></a>01756    }
<a name="l01757"></a>01757 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6099b0e8fafcc01b8c1769c94c827325"></a><!-- doxytag: member="fat_unusual.c::fat_format" ref="6099b0e8fafcc01b8c1769c94c827325" args="(U8 u8_fat_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_format           </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_fat_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction format the current drive. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u8_fat_type</em>&nbsp;</td><td>Select the type of format <br>
 FS_FORMAT_DEFAULT, The file system module choose the better FAT format for the drive space <br>
 FS_FORMAT_FAT, The FAT12 or FAT16 is used to format the drive, if possible (disk space &lt;2GB) <br>
 FS_FORMAT_FAT32, The FAT32 is used to format the drive, if possible (disk space &gt;32MB) <br>
 FS_FORMAT_NOMBR_FLAG, if you don't want a MRB in disk then add this flag (e.g. FAT format on a CD support)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! Global variables used
//! IN : 
//! fs_g_nav.u8_lun        indicate the drive to foramt
//!
//! This routine can't format a multi-partiton, if the disk containt as a multi-partition
//! then the multi-partition is erase and replace by a single partition on ALL disk space.
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l00335">335</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01810">fat_cache_flush()</a>, <a class="el" href="a00035.html#l00915">fat_clean_zone()</a>, <a class="el" href="a00035.html#l00979">fat_initialize_fat()</a>, <a class="el" href="a00035.html#l00477">fat_select_filesystem()</a>, <a class="el" href="a00035.html#l00611">fat_write_MBR()</a>, <a class="el" href="a00035.html#l00719">fat_write_PBR()</a>, <a class="el" href="a00038.html#l00161">FS_FORMAT_NOMBR_FLAG</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00035.html#l00313">fs_s_u32_size_partition</a>, <a class="el" href="a00031.html#l00295">mem_read_capacity()</a>, <a class="el" href="a00034.html#l00259">Fs_management::u8_lun</a>, and <a class="el" href="a00034.html#l00261">Fs_management::u8_partition</a>.
<p>
Referenced by <a class="el" href="a00042.html#l00311">nav_drive_format()</a>.<div class="fragment"><pre class="fragment"><a name="l00336"></a>00336 {
<a name="l00337"></a>00337    Bool b_MBR;
<a name="l00338"></a>00338 <span class="preprocessor">#if (FS_MULTI_PARTITION == ENABLED)</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span><span class="preprocessor">#error NOT SUPPORTED</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span>   <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af482bc02a186c363c37c93e169fbbd4">u8_partition</a> = 0;
<a name="l00341"></a>00341 <span class="preprocessor">#endif</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span>   
<a name="l00343"></a>00343     
<a name="l00344"></a>00344    <span class="comment">// Read capacity of drive (last LBA)</span>
<a name="l00345"></a>00345    <a class="code" href="a00015.html#0bafaa7d437e08a1727e2124db423f18">mem_read_capacity</a>( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#43065262a1a7560b143e0b48cbf5ccbd">u8_lun</a> , &amp;<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> );
<a name="l00346"></a>00346  
<a name="l00347"></a>00347    <span class="keywordflow">if</span>( u8_fat_type &amp; <a class="code" href="a00022.html#31e4d71ce14847632a35192fae12705e">FS_FORMAT_NOMBR_FLAG</a> )
<a name="l00348"></a>00348    {
<a name="l00349"></a>00349       b_MBR = FALSE;
<a name="l00350"></a>00350       u8_fat_type &amp;= ~FS_FORMAT_NOMBR_FLAG;
<a name="l00351"></a>00351       <span class="comment">// Here size of partition = size disk = last LBA + 1</span>
<a name="l00352"></a>00352       <a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>++;
<a name="l00353"></a>00353    }<span class="keywordflow">else</span>{
<a name="l00354"></a>00354       b_MBR = TRUE;
<a name="l00355"></a>00355       <span class="comment">// Here size of partition = size disk -1 = last LBA</span>
<a name="l00356"></a>00356    }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358    <span class="comment">// Initialise the file system for this device</span>
<a name="l00359"></a>00359    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#477e90a97f3fcb8361020feb2557098d">fat_select_filesystem</a>( u8_fat_type , b_MBR ))
<a name="l00360"></a>00360       <span class="keywordflow">return</span> FALSE;
<a name="l00361"></a>00361    
<a name="l00362"></a>00362    <span class="comment">// Write the MBR sector (first sector)</span>
<a name="l00363"></a>00363    <span class="keywordflow">if</span>( b_MBR )
<a name="l00364"></a>00364       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#9075855486dc53d38dd64e068b512027">fat_write_MBR</a>())
<a name="l00365"></a>00365          <span class="keywordflow">return</span> FALSE;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367    <span class="comment">// Write the PBR sector</span>
<a name="l00368"></a>00368    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#89d56497bd58d7d6553b7e319f3ee863">fat_write_PBR</a>( b_MBR ))
<a name="l00369"></a>00369       <span class="keywordflow">return</span> FALSE;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371    <span class="comment">// Clear reserved zone, FAT zone, and Root dir zone</span>
<a name="l00372"></a>00372    <span class="comment">// Remark: the reserve zone of FAT32 isn't initialized, because BPB_FSInfo is egal to 0</span>
<a name="l00373"></a>00373    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#ad6177926c645c867ea1d23c727d9097">fat_clean_zone</a>( b_MBR ))
<a name="l00374"></a>00374       <span class="keywordflow">return</span> FALSE;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376    <span class="comment">// Initialization of the FAT 1 and 2</span>
<a name="l00377"></a>00377    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#6ab74fa9e68a4379a3ea33465d835277">fat_initialize_fat</a>())
<a name="l00378"></a>00378       <span class="keywordflow">return</span> FALSE;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380    <span class="comment">// Force the flush of last write sector</span>
<a name="l00381"></a>00381    <span class="keywordflow">return</span> <a class="code" href="a00017.html#578ab4800128cde17c0820a5027c1c06">fat_cache_flush</a>();
<a name="l00382"></a>00382 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="51041500c2e36ab39aad19b54e93d504"></a><!-- doxytag: member="fat_unusual.c::fat_get_date" ref="51041500c2e36ab39aad19b54e93d504" args="(FS_STRING sz_date, Bool type_date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_get_date           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>type_date</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction read the informations about the dates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type_date</em>&nbsp;</td><td>choose date to read (FS_DATE_LAST_WRITE or FS_DATE_CREATION) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sz_date</em>&nbsp;</td><td>table to store the information about date <br>
 storage format (ASCII) = "YYYYMMDDHHMMSSMS" = year, month, day, hour, minute, seconde, miliseconde </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00035.html#l01194">1194</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00035.html#l01217">fat_translatedate_number_to_ascii()</a>, and <a class="el" href="a00038.html#l00112">FS_DATE_LAST_WRITE</a>.
<p>
Referenced by <a class="el" href="a00042.html#l01768">nav_file_dateget()</a>.<div class="fragment"><pre class="fragment"><a name="l01195"></a>01195 {
<a name="l01196"></a>01196    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198    ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01199"></a>01199    <span class="keywordflow">if</span>( <a class="code" href="a00022.html#fbbd68bf71e1e73a9162dd04f3dec8fe">FS_DATE_LAST_WRITE</a> == type_date )
<a name="l01200"></a>01200    {
<a name="l01201"></a>01201       <a class="code" href="a00019.html#015e44f70b92d8b39e00ababfdb6bc24">fat_translatedate_number_to_ascii</a>( sz_date , &amp;ptr_entry[22] , FALSE );
<a name="l01202"></a>01202    }
<a name="l01203"></a>01203    <span class="keywordflow">else</span>
<a name="l01204"></a>01204    {
<a name="l01205"></a>01205       <a class="code" href="a00019.html#015e44f70b92d8b39e00ababfdb6bc24">fat_translatedate_number_to_ascii</a>( sz_date , &amp;ptr_entry[13] , TRUE );
<a name="l01206"></a>01206    }
<a name="l01207"></a>01207 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e23270781477be5e6c89b90531c01651"></a><!-- doxytag: member="fat_unusual.c::fat_getfreespace" ref="e23270781477be5e6c89b90531c01651" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 fat_getfreespace           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction return the space free in the current drive partition. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of sector free <br>
 if 0, then error or full </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01986">1986</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l00815">fat_cluster_readnext()</a>, <a class="el" href="a00033.html#l00619">fat_cluster_val()</a>, <a class="el" href="a00035.html#l00874">fat_read_fat32_FSInfo()</a>, <a class="el" href="a00035.html#l00840">fat_write_fat32_FSInfo()</a>, <a class="el" href="a00034.html#l00236">FS_CLUST_VAL_READ</a>, <a class="el" href="a00034.html#l00378">fs_g_cluster</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00077">Is_fat12</a>, <a class="el" href="a00034.html#l00087">Is_fat32</a>, <a class="el" href="a00034.html#l00266">Fs_management::u32_CountofCluster</a>, <a class="el" href="a00034.html#l00306">st_fs_cluster::u32_pos</a>, <a class="el" href="a00034.html#l00307">st_fs_cluster::u32_val</a>, and <a class="el" href="a00034.html#l00263">Fs_management::u8_BPB_SecPerClus</a>.
<p>
Referenced by <a class="el" href="a00035.html#l02049">fat_getfreespace_percent()</a>, and <a class="el" href="a00042.html#l00519">nav_partition_freespace()</a>.<div class="fragment"><pre class="fragment"><a name="l01987"></a>01987 {
<a name="l01988"></a>01988    U32 u32_nb_free_cluster = 0;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990    <span class="comment">// Read ALL FAT1</span>
<a name="l01991"></a>01991    <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> = 2;
<a name="l01992"></a>01992 
<a name="l01993"></a>01993    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l01994"></a>01994    {  <span class="comment">// FAT12 only</span>
<a name="l01995"></a>01995       <span class="keywordflow">for</span>(
<a name="l01996"></a>01996       ;     <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> &lt; <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a>
<a name="l01997"></a>01997       ;     <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a>++ )
<a name="l01998"></a>01998       {
<a name="l01999"></a>01999          <span class="comment">// Get the value of the cluster</span>
<a name="l02000"></a>02000          <span class="keywordflow">if</span> ( !<a class="code" href="a00017.html#1be84552293d174f534b2fb8d0a4e737">fat_cluster_val</a>( <a class="code" href="a00018.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ) )
<a name="l02001"></a>02001             <span class="keywordflow">return</span> 0;
<a name="l02002"></a>02002    
<a name="l02003"></a>02003          <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#4f323a1ec38e3c0f1b57bf4fe07842b7">u32_val</a> )
<a name="l02004"></a>02004             u32_nb_free_cluster++;
<a name="l02005"></a>02005       }
<a name="l02006"></a>02006    }
<a name="l02007"></a>02007    <span class="keywordflow">else</span>
<a name="l02008"></a>02008    {
<a name="l02009"></a>02009       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02010"></a>02010       {
<a name="l02011"></a>02011          u32_nb_free_cluster = <a class="code" href="a00018.html#0a8beb16a074b07828fc725e0c0ae500">fat_read_fat32_FSInfo</a>();
<a name="l02012"></a>02012          <span class="keywordflow">if</span>( 0xFFFFFFFF != u32_nb_free_cluster )
<a name="l02013"></a>02013             <span class="keywordflow">goto</span> endof_fat_getfreespace;      
<a name="l02014"></a>02014          u32_nb_free_cluster = 0;
<a name="l02015"></a>02015       }
<a name="l02016"></a>02016       <span class="comment">// Speed optimization only for FAT16 and FAT32</span>
<a name="l02017"></a>02017       <span class="comment">// init first value used by fat_cluster_readnext()</span>
<a name="l02018"></a>02018       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#1be84552293d174f534b2fb8d0a4e737">fat_cluster_val</a>( <a class="code" href="a00018.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ))
<a name="l02019"></a>02019          <span class="keywordflow">return</span> FALSE;
<a name="l02020"></a>02020       <span class="keywordflow">for</span>(
<a name="l02021"></a>02021       ;     <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> &lt; <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a>
<a name="l02022"></a>02022       ;     <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a>++ )
<a name="l02023"></a>02023       {
<a name="l02024"></a>02024          <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#4f323a1ec38e3c0f1b57bf4fe07842b7">u32_val</a> )
<a name="l02025"></a>02025             u32_nb_free_cluster++;
<a name="l02026"></a>02026          <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#e28958d1a5e3ed006edf937e6b7dacc7">fat_cluster_readnext</a>() )
<a name="l02027"></a>02027             <span class="keywordflow">return</span> FALSE;
<a name="l02028"></a>02028       }
<a name="l02029"></a>02029       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02030"></a>02030       {
<a name="l02031"></a>02031          <span class="comment">// Save value for next call</span>
<a name="l02032"></a>02032          <a class="code" href="a00018.html#9cf154ffe36bc2c00b1d589e523b449c">fat_write_fat32_FSInfo</a>( u32_nb_free_cluster );
<a name="l02033"></a>02033       }
<a name="l02034"></a>02034    }
<a name="l02035"></a>02035 endof_fat_getfreespace:
<a name="l02036"></a>02036    <span class="keywordflow">return</span> (u32_nb_free_cluster * <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>);
<a name="l02037"></a>02037 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="14426d5552b72b88ea0d61828c57d6c6"></a><!-- doxytag: member="fat_unusual.c::fat_getfreespace_percent" ref="14426d5552b72b88ea0d61828c57d6c6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 fat_getfreespace_percent           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction return the space free in percent. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>percent of free space (1 to 100) if 0, then error or full</dd></dl>
<div class="fragment"><pre class="fragment">
//! More speed than fat_getfreespace() routine but delta error 1%
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l02049">2049</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l00619">fat_cluster_val()</a>, <a class="el" href="a00035.html#l01986">fat_getfreespace()</a>, <a class="el" href="a00035.html#l00874">fat_read_fat32_FSInfo()</a>, <a class="el" href="a00034.html#l00236">FS_CLUST_VAL_READ</a>, <a class="el" href="a00034.html#l00378">fs_g_cluster</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00034.html#l00077">Is_fat12</a>, <a class="el" href="a00034.html#l00082">Is_fat16</a>, <a class="el" href="a00034.html#l00087">Is_fat32</a>, <a class="el" href="a00034.html#l00265">Fs_management::u16_fat_size</a>, <a class="el" href="a00034.html#l00266">Fs_management::u32_CountofCluster</a>, <a class="el" href="a00034.html#l00306">st_fs_cluster::u32_pos</a>, and <a class="el" href="a00034.html#l00263">Fs_management::u8_BPB_SecPerClus</a>.
<p>
Referenced by <a class="el" href="a00042.html#l00539">nav_partition_freespace_percent()</a>.<div class="fragment"><pre class="fragment"><a name="l02050"></a>02050 {
<a name="l02051"></a>02051    U32 u32_nb_free_cluster = 0;
<a name="l02052"></a>02052    U16 u16_tmp, u16_pos;
<a name="l02053"></a>02053 
<a name="l02054"></a>02054    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l02055"></a>02055    {  <span class="comment">// No speed optimization necessary on FAT12</span>
<a name="l02056"></a>02056       <span class="keywordflow">return</span> (((<a class="code" href="a00018.html#e23270781477be5e6c89b90531c01651">fat_getfreespace</a>()/<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>)*100) / <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a>);
<a name="l02057"></a>02057    }
<a name="l02058"></a>02058    
<a name="l02059"></a>02059 
<a name="l02060"></a>02060    <a class="code" href="a00018.html#f1ca07cf6181c8e6af3fa988a0b0539d">fs_g_cluster</a>.<a class="code" href="a00010.html#06879786792eeefd3b45527499ed1174">u32_pos</a> = 2;
<a name="l02061"></a>02061    <span class="comment">// init first value used by fat_cluster_readnext()</span>
<a name="l02062"></a>02062    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#1be84552293d174f534b2fb8d0a4e737">fat_cluster_val</a>( <a class="code" href="a00018.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ))
<a name="l02063"></a>02063       <span class="keywordflow">return</span> FALSE;
<a name="l02064"></a>02064 
<a name="l02065"></a>02065    <span class="comment">// The optimization is to </span>
<a name="l02066"></a>02066    <span class="comment">// - read only the LSB byte of cluster</span>
<a name="l02067"></a>02067    <span class="comment">// - read only 1 cluster for 2 clusters</span>
<a name="l02068"></a>02068    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02069"></a>02069    {  
<a name="l02070"></a>02070       u32_nb_free_cluster = <a class="code" href="a00018.html#0a8beb16a074b07828fc725e0c0ae500">fat_read_fat32_FSInfo</a>();
<a name="l02071"></a>02071       <span class="keywordflow">if</span>( 0xFFFFFFFF != u32_nb_free_cluster )
<a name="l02072"></a>02072          <span class="keywordflow">goto</span> endof_fat_getfreespace_percent;
<a name="l02073"></a>02073       u32_nb_free_cluster = 0;
<a name="l02074"></a>02074       
<a name="l02075"></a>02075       u16_pos = 2*4;
<a name="l02076"></a>02076       <span class="keywordflow">for</span>(  u16_tmp = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>
<a name="l02077"></a>02077       ;     u16_tmp!=0
<a name="l02078"></a>02078       ;     u16_tmp-- )
<a name="l02079"></a>02079       {
<a name="l02080"></a>02080          <span class="keywordflow">for</span>( ; u16_pos &lt; 512 ; u16_pos += (2*4) )
<a name="l02081"></a>02081          {
<a name="l02082"></a>02082             <span class="keywordflow">if</span>( 0 == <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[u16_pos] )
<a name="l02083"></a>02083                u32_nb_free_cluster+=2;
<a name="l02084"></a>02084          }         
<a name="l02085"></a>02085          <span class="comment">// Read next sector in FAT</span>
<a name="l02086"></a>02086          u16_pos = 0;
<a name="l02087"></a>02087          <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>++;
<a name="l02088"></a>02088          <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( TRUE ))
<a name="l02089"></a>02089             <span class="keywordflow">return</span> 0;
<a name="l02090"></a>02090       }
<a name="l02091"></a>02091    }
<a name="l02092"></a>02092 
<a name="l02093"></a>02093    <span class="keywordflow">if</span> ( <a class="code" href="a00018.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l02094"></a>02094    {  
<a name="l02095"></a>02095       u16_pos = 2*2;
<a name="l02096"></a>02096 
<a name="l02097"></a>02097       <span class="keywordflow">for</span>(  u16_tmp = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>
<a name="l02098"></a>02098       ;     u16_tmp!=0
<a name="l02099"></a>02099       ;     u16_tmp-- )
<a name="l02100"></a>02100       {
<a name="l02101"></a>02101          <span class="keywordflow">for</span>( ; u16_pos &lt; 512 ; u16_pos += (2*2) )
<a name="l02102"></a>02102          {
<a name="l02103"></a>02103             <span class="keywordflow">if</span>( 0 == <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[u16_pos] )
<a name="l02104"></a>02104                u32_nb_free_cluster+=2;
<a name="l02105"></a>02105          }         
<a name="l02106"></a>02106          <span class="comment">// Read next sector in FAT</span>
<a name="l02107"></a>02107          u16_pos = 0;
<a name="l02108"></a>02108          <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>++;
<a name="l02109"></a>02109          <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( TRUE ))
<a name="l02110"></a>02110             <span class="keywordflow">return</span> 0;
<a name="l02111"></a>02111       }
<a name="l02112"></a>02112    }
<a name="l02113"></a>02113 
<a name="l02114"></a>02114    <span class="comment">// Compute percent</span>
<a name="l02115"></a>02115    <span class="keywordflow">if</span>( u32_nb_free_cluster &gt; <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a> )
<a name="l02116"></a>02116       <span class="keywordflow">return</span> 100;
<a name="l02117"></a>02117    <span class="keywordflow">if</span>( u32_nb_free_cluster &gt; ((<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a>-u32_nb_free_cluster)/256) )
<a name="l02118"></a>02118    {
<a name="l02119"></a>02119       <span class="comment">// Compute and add a delta error</span>
<a name="l02120"></a>02120       u32_nb_free_cluster -= ((<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a>-u32_nb_free_cluster)/256);
<a name="l02121"></a>02121    }
<a name="l02122"></a>02122 endof_fat_getfreespace_percent:
<a name="l02123"></a>02123    <span class="keywordflow">return</span> ((u32_nb_free_cluster * 100) / <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a>);
<a name="l02124"></a>02124 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9510bd193c1e70f2307c5b9b07078511"></a><!-- doxytag: member="fat_unusual.c::fat_initialize_dir" ref="9510bd193c1e70f2307c5b9b07078511" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_initialize_dir           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction write the directory informations. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! Global variables used
//! IN : 
//!   fs_g_seg.u32_addr          cluster value of a directory
//! OUT:
//!   update the sector cache with init directory datas
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01154">1154</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00035.html#l02319">fat_clear_cluster()</a>, <a class="el" href="a00038.html#l00134">FS_ATTR_DIRECTORY</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00371">fs_g_nav_entry</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00194">FS_SIZE_FILE_ENTRY</a>, <a class="el" href="a00034.html#l00287">Fs_management_entry::u32_cluster</a>, <a class="el" href="a00034.html#l00270">Fs_management::u32_cluster_sel_dir</a>, and <a class="el" href="a00033.html#l00351">u8_i</a>.
<p>
Referenced by <a class="el" href="a00042.html#l01253">nav_dir_make()</a>.<div class="fragment"><pre class="fragment"><a name="l01155"></a>01155 {
<a name="l01156"></a>01156    U8 <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a>;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158    <span class="keywordflow">if</span>( !<a class="code" href="a00018.html#6cc9ee9a14553be84990df27709f51a6">fat_clear_cluster</a>())
<a name="l01159"></a>01159       <span class="keywordflow">return</span> FALSE;
<a name="l01160"></a>01160    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01161"></a>01161    <span class="comment">// remark: here, the fat clear cluster have open and clear the first sector of cluster</span>
<a name="l01162"></a>01162 
<a name="l01163"></a>01163    <span class="comment">// Create the dot "." entry, this one is a directory that points to itself</span>
<a name="l01164"></a>01164    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[0]=<span class="charliteral">'.'</span>;
<a name="l01165"></a>01165    <span class="keywordflow">for</span>( u8_i=1 ; u8_i&lt;11 ; u8_i++ )
<a name="l01166"></a>01166       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[u8_i]=<span class="charliteral">' '</span>;
<a name="l01167"></a>01167    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[11]=<a class="code" href="a00022.html#99004e3e756391a7ac1c4dde4db6864c">FS_ATTR_DIRECTORY</a>;
<a name="l01168"></a>01168    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[26]= LSB0( <a class="code" href="a00018.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87">u32_cluster</a> );
<a name="l01169"></a>01169    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[27]= LSB1( <a class="code" href="a00018.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87">u32_cluster</a> );
<a name="l01170"></a>01170    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[20]= LSB2( <a class="code" href="a00018.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87">u32_cluster</a> );
<a name="l01171"></a>01171    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[21]= LSB3( <a class="code" href="a00018.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87">u32_cluster</a> );
<a name="l01172"></a>01172    <span class="comment">// Create the dotdot ".." entry, this one points to the starting cluster of the parent directory</span>
<a name="l01173"></a>01173    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+0]=<span class="charliteral">'.'</span>;
<a name="l01174"></a>01174    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+1]=<span class="charliteral">'.'</span>;
<a name="l01175"></a>01175    <span class="keywordflow">for</span>( u8_i=2 ; u8_i&lt;11 ; u8_i++ )
<a name="l01176"></a>01176       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+u8_i]=<span class="charliteral">' '</span>;
<a name="l01177"></a>01177    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+11]=<a class="code" href="a00022.html#99004e3e756391a7ac1c4dde4db6864c">FS_ATTR_DIRECTORY</a>;
<a name="l01178"></a>01178    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+26]= LSB0( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f">u32_cluster_sel_dir</a> );
<a name="l01179"></a>01179    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+27]= LSB1( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f">u32_cluster_sel_dir</a> );
<a name="l01180"></a>01180    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+20]= LSB2( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f">u32_cluster_sel_dir</a> );
<a name="l01181"></a>01181    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+21]= LSB3( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f">u32_cluster_sel_dir</a> );
<a name="l01182"></a>01182    
<a name="l01183"></a>01183    <span class="keywordflow">return</span> TRUE;
<a name="l01184"></a>01184 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6ab74fa9e68a4379a3ea33465d835277"></a><!-- doxytag: member="fat_unusual.c::fat_initialize_fat" ref="6ab74fa9e68a4379a3ea33465d835277" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_initialize_fat           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction initialize the fat one and two. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l00979">979</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00034.html#l00077">Is_fat12</a>, <a class="el" href="a00034.html#l00082">Is_fat16</a>, <a class="el" href="a00034.html#l00087">Is_fat32</a>, <a class="el" href="a00034.html#l00265">Fs_management::u16_fat_size</a>, and <a class="el" href="a00034.html#l00267">Fs_management::u32_ptr_fat</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00335">fat_format()</a>.<div class="fragment"><pre class="fragment"><a name="l00980"></a>00980 {
<a name="l00981"></a>00981    <span class="comment">// Init and reset the cache at the beginning of memory</span>
<a name="l00982"></a>00982    <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a>;
<a name="l00983"></a>00983    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l00984"></a>00984       <span class="keywordflow">return</span> FALSE;
<a name="l00985"></a>00985    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l00986"></a>00986 
<a name="l00987"></a>00987    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00988"></a>00988    {
<a name="l00989"></a>00989       memcpy_code2ram( <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>, <a class="code" href="a00019.html#94831debe0600f19945c3239dc3634e7">const_header_fat32</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#94831debe0600f19945c3239dc3634e7">const_header_fat32</a>) );
<a name="l00990"></a>00990    }
<a name="l00991"></a>00991    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l00992"></a>00992    {
<a name="l00993"></a>00993       memcpy_code2ram( <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>, <a class="code" href="a00019.html#96762bd73caa7d1fdc8c92db0b777f1a">const_header_fat16</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#96762bd73caa7d1fdc8c92db0b777f1a">const_header_fat16</a>) );
<a name="l00994"></a>00994    }
<a name="l00995"></a>00995    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l00996"></a>00996    {
<a name="l00997"></a>00997       memcpy_code2ram( <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>, <a class="code" href="a00019.html#d7b8480b30e94480383a615e9304dee1">const_header_fat12</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#d7b8480b30e94480383a615e9304dee1">const_header_fat12</a>) );
<a name="l00998"></a>00998    }
<a name="l00999"></a>00999 
<a name="l01000"></a>01000    <span class="comment">// copy this first sector FAT in second FAT</span>
<a name="l01001"></a>01001    <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> + <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>;
<a name="l01002"></a>01002    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l01003"></a>01003       <span class="keywordflow">return</span> FALSE;
<a name="l01004"></a>01004    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01005"></a>01005    <span class="keywordflow">return</span> TRUE;
<a name="l01006"></a>01006 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c0108ea608b547e8d3a405c70644c1e9"></a><!-- doxytag: member="fat_unusual.c::fat_mount" ref="c0108ea608b547e8d3a405c70644c1e9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_mount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction mount a partition file system (FAT12, FAT16 or FAT32) of drive selected. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! Global variables used
//! IN : 
//!   fs_g_nav.u8_lun            Indicate the drive to mount    
//!   fs_g_nav.u8_partition      Indicate the partition to mount (if FS_MULTI_PARTITION =  ENABLED )
//! OUT:
//!   fs_g_nav                   update structure
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l00106">106</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l00099">fat_check_device()</a>, <a class="el" href="a00033.html#l01382">fat_clear_entry_info_and_ptr()</a>, <a class="el" href="a00034.html#l00146">FS_BR_SIGNATURE_HIGH</a>, <a class="el" href="a00034.html#l00145">FS_BR_SIGNATURE_LOW</a>, <a class="el" href="a00038.html#l00193">FS_ERR_NO_FORMAT</a>, <a class="el" href="a00038.html#l00194">FS_ERR_NO_PART</a>, <a class="el" href="a00038.html#l00195">FS_ERR_NO_SUPPORT_PART</a>, <a class="el" href="a00034.html#l00180">FS_FAT12_MAX_CLUSTERS</a>, <a class="el" href="a00034.html#l00181">FS_FAT16_MAX_CLUSTERS</a>, <a class="el" href="a00030.html#l00061">FS_FAT_12</a>, <a class="el" href="a00030.html#l00062">FS_FAT_16</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00370">fs_g_nav_fast</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00038.html#l00257">fs_g_status</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00034.html#l00110">FS_MBR_OFFSET_PART_ENTRY</a>, <a class="el" href="a00030.html#l00070">FS_MULTI_PARTITION</a>, <a class="el" href="a00034.html#l00205">FS_NB_FAT</a>, <a class="el" href="a00034.html#l00166">FS_PART_TYPE_FAT12</a>, <a class="el" href="a00034.html#l00167">FS_PART_TYPE_FAT16_INF32M</a>, <a class="el" href="a00034.html#l00168">FS_PART_TYPE_FAT16_SUP32M</a>, <a class="el" href="a00034.html#l00169">FS_PART_TYPE_FAT16_SUP32M_BIS</a>, <a class="el" href="a00034.html#l00170">FS_PART_TYPE_FAT32</a>, <a class="el" href="a00034.html#l00171">FS_PART_TYPE_FAT32_BIS</a>, <a class="el" href="a00034.html#l00165">FS_PARTITION_ACTIVE</a>, <a class="el" href="a00034.html#l00194">FS_SIZE_FILE_ENTRY</a>, <a class="el" href="a00034.html#l00206">FS_SIZE_OF_SECTOR</a>, <a class="el" href="a00034.html#l00339">FS_TYPE_FAT_12</a>, <a class="el" href="a00034.html#l00340">FS_TYPE_FAT_16</a>, <a class="el" href="a00034.html#l00341">FS_TYPE_FAT_32</a>, <a class="el" href="a00034.html#l00338">FS_TYPE_FAT_UNM</a>, <a class="el" href="a00034.html#l00117">HIGH_16_BPB_BytsPerSec</a>, <a class="el" href="a00034.html#l00122">HIGH_16_BPB_FATSz16</a>, <a class="el" href="a00034.html#l00134">HIGH_16_BPB_ResvSecCnt</a>, <a class="el" href="a00034.html#l00120">HIGH_16_BPB_RootEntCnt</a>, <a class="el" href="a00034.html#l00128">HIGH_16_BPB_TotSec16</a>, <a class="el" href="a00034.html#l00123">LOW0_32_BPB_FATSz32</a>, <a class="el" href="a00034.html#l00136">LOW0_32_BPB_RootClus</a>, <a class="el" href="a00034.html#l00129">LOW0_32_BPB_TotSec32</a>, <a class="el" href="a00034.html#l00124">LOW1_32_BPB_FATSz32</a>, <a class="el" href="a00034.html#l00137">LOW1_32_BPB_RootClus</a>, <a class="el" href="a00034.html#l00130">LOW1_32_BPB_TotSec32</a>, <a class="el" href="a00034.html#l00125">LOW2_32_BPB_FATSz32</a>, <a class="el" href="a00034.html#l00138">LOW2_32_BPB_RootClus</a>, <a class="el" href="a00034.html#l00131">LOW2_32_BPB_TotSec32</a>, <a class="el" href="a00034.html#l00126">LOW3_32_BPB_FATSz32</a>, <a class="el" href="a00034.html#l00139">LOW3_32_BPB_RootClus</a>, <a class="el" href="a00034.html#l00132">LOW3_32_BPB_TotSec32</a>, <a class="el" href="a00034.html#l00116">LOW_16_BPB_BytsPerSec</a>, <a class="el" href="a00034.html#l00121">LOW_16_BPB_FATSz16</a>, <a class="el" href="a00034.html#l00133">LOW_16_BPB_ResvSecCnt</a>, <a class="el" href="a00034.html#l00119">LOW_16_BPB_RootEntCnt</a>, <a class="el" href="a00034.html#l00127">LOW_16_BPB_TotSec16</a>, <a class="el" href="a00034.html#l00269">Fs_management::rootdir</a>, <a class="el" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428">Fs_rootdir::seg</a>, <a class="el" href="a00034.html#l00265">Fs_management::u16_fat_size</a>, <a class="el" href="a00034.html#l00268">Fs_management::u16_offset_data</a>, <a class="el" href="a00034.html#l00251">Fs_rootdir::u16_pos</a>, <a class="el" href="a00034.html#l00252">Fs_rootdir::u16_size</a>, <a class="el" href="a00034.html#l00248">Fs_rootdir::u32_cluster</a>, <a class="el" href="a00034.html#l00270">Fs_management::u32_cluster_sel_dir</a>, <a class="el" href="a00034.html#l00266">Fs_management::u32_CountofCluster</a>, <a class="el" href="a00034.html#l00267">Fs_management::u32_ptr_fat</a>, <a class="el" href="a00034.html#l00135">U8_BPB_NumFATs</a>, <a class="el" href="a00034.html#l00118">U8_BPB_SecPerClus</a>, <a class="el" href="a00034.html#l00263">Fs_management::u8_BPB_SecPerClus</a>, <a class="el" href="a00034.html#l00261">Fs_management::u8_partition</a>, and <a class="el" href="a00034.html#l00278">Fs_management_fast::u8_type_fat</a>.
<p>
Referenced by <a class="el" href="a00042.html#l00311">nav_drive_format()</a>, and <a class="el" href="a00042.html#l00373">nav_partition_mount()</a>.<div class="fragment"><pre class="fragment"><a name="l00107"></a>00107 {
<a name="l00108"></a>00108    U8  u8_tmp;
<a name="l00109"></a>00109    U16 u16_tmp;
<a name="l00110"></a>00110    U32 u32_tmp;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112    <span class="comment">// the current dir is the root directory</span>
<a name="l00113"></a>00113    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f">u32_cluster_sel_dir</a>   = 0;
<a name="l00114"></a>00114    <span class="comment">// No file is selected</span>
<a name="l00115"></a>00115    <a class="code" href="a00017.html#56d9a210bc2d4b0b5c46cb24a2e9f690">fat_clear_entry_info_and_ptr</a>();
<a name="l00116"></a>00116 
<a name="l00117"></a>00117    <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> = <a class="code" href="a00018.html#429fbd0498704c3d5864877548040069">FS_TYPE_FAT_UNM</a>;
<a name="l00118"></a>00118    <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = 0;   <span class="comment">// Init ptr fat at the beginning of memory</span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120    <span class="comment">// Check if the drive is avialable</span>
<a name="l00121"></a>00121    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#eeec0bd6755a6be4c4dda2b4669eb0ae">fat_check_device</a>() )
<a name="l00122"></a>00122       <span class="keywordflow">return</span> FALSE;
<a name="l00123"></a>00123       
<a name="l00124"></a>00124    <span class="keywordflow">while</span>( 1 )  <span class="comment">// Check a correct present of the partition selected</span>
<a name="l00125"></a>00125    {
<a name="l00126"></a>00126       <span class="comment">// Read one sector</span>
<a name="l00127"></a>00127       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( TRUE ))
<a name="l00128"></a>00128          <span class="keywordflow">return</span> FALSE;
<a name="l00129"></a>00129    
<a name="l00130"></a>00130       <span class="comment">// Check PBR/MBR signature</span>
<a name="l00131"></a>00131       <span class="keywordflow">if</span> ( (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[510] != <a class="code" href="a00018.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>  )
<a name="l00132"></a>00132       &amp;&amp;   (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[511] != <a class="code" href="a00018.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a> ) )
<a name="l00133"></a>00133       {
<a name="l00134"></a>00134          <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#34de358c4f6461ed5f3f199fd5cb679f">FS_ERR_NO_FORMAT</a>;
<a name="l00135"></a>00135          <span class="keywordflow">return</span> FALSE;
<a name="l00136"></a>00136       }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138       <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> )
<a name="l00139"></a>00139       {
<a name="l00140"></a>00140          <span class="comment">//** first sector then check a MBR structure</span>
<a name="l00141"></a>00141          <span class="comment">// Search the first partition supported</span>
<a name="l00142"></a>00142 <span class="preprocessor">#if (FS_MULTI_PARTITION == ENABLED)</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span>         u16_tmp=0;  <span class="comment">// Init to "no valid partition found"</span>
<a name="l00144"></a>00144 <span class="preprocessor">#endif</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span>         <span class="keywordflow">for</span>( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
<a name="l00146"></a>00146          {
<a name="l00147"></a>00147             <span class="comment">// The first sector must be a MBR, then check the partition entry in the MBR</span>
<a name="l00148"></a>00148             <span class="keywordflow">if</span> ( ((<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+0] == <a class="code" href="a00018.html#450f174270801d9b3e2d66854b607148">FS_PARTITION_ACTIVE</a> )||
<a name="l00149"></a>00149                   (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+0] == 0x00                )  )
<a name="l00150"></a>00150             &amp;&amp;   ((<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00018.html#d8702ceb3912c09278602d3ea33224ff">FS_PART_TYPE_FAT12</a>           )||
<a name="l00151"></a>00151                   (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00018.html#b9f13193999f7bb7ea0e4be6cf5ee57b">FS_PART_TYPE_FAT16_INF32M</a>    )||
<a name="l00152"></a>00152                   (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00018.html#29856400974fc942f9cf900a44ea7389">FS_PART_TYPE_FAT16_SUP32M</a>    )||
<a name="l00153"></a>00153                   (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00018.html#c7c65caf9513f8cddd4319b334813d85">FS_PART_TYPE_FAT16_SUP32M_BIS</a>)||
<a name="l00154"></a>00154                   (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00018.html#93881dd293ba41286e413bef3212786a">FS_PART_TYPE_FAT32</a>           )||
<a name="l00155"></a>00155                   (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00018.html#3e13e837536764161f0aa9768e76b2e1">FS_PART_TYPE_FAT32_BIS</a>       )) )
<a name="l00156"></a>00156             {
<a name="l00157"></a>00157                <span class="comment">// A valid partition is found</span>
<a name="l00158"></a>00158 #<span class="keywordflow">if</span> (<a class="code" href="a00014.html#611aad16c0a7b624d4f73d4174895d1f">FS_MULTI_PARTITION</a> == ENABLED)
<a name="l00159"></a>00159                <span class="keywordflow">if</span>( u16_tmp == <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af482bc02a186c363c37c93e169fbbd4">u8_partition</a> )
<a name="l00160"></a>00160                   <span class="keywordflow">break</span>;   <span class="comment">// a valid partition correspond to number partition</span>
<a name="l00161"></a>00161                u16_tmp++;
<a name="l00162"></a>00162 #<span class="keywordflow">else</span>
<a name="l00163"></a>00163                <span class="keywordflow">break</span>;
<a name="l00164"></a>00164 #endif
<a name="l00165"></a>00165             }
<a name="l00166"></a>00166          }
<a name="l00167"></a>00167          <span class="keywordflow">if</span>( u8_tmp != 4 )
<a name="l00168"></a>00168          {  
<a name="l00169"></a>00169             <span class="comment">// Partition found -&gt; Read partition position (in sectors) at offset 8</span>
<a name="l00170"></a>00170             LSB0(<a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+8];
<a name="l00171"></a>00171             LSB1(<a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+9];
<a name="l00172"></a>00172             LSB2(<a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+10];
<a name="l00173"></a>00173             LSB3(<a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a>) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+11];
<a name="l00174"></a>00174             <span class="keywordflow">continue</span>;   <span class="comment">// Go to check PBR of partition</span>
<a name="l00175"></a>00175          }   
<a name="l00176"></a>00176 
<a name="l00177"></a>00177          <span class="comment">// No MBR found then check PBR</span>
<a name="l00178"></a>00178 <span class="preprocessor">#if (FS_MULTI_PARTITION == ENABLED)</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span>         <span class="comment">// The device don't have mutli partition, but only one</span>
<a name="l00180"></a>00180          <span class="keywordflow">if</span> ( 0 != <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af482bc02a186c363c37c93e169fbbd4">u8_partition</a> )
<a name="l00181"></a>00181          {
<a name="l00182"></a>00182             <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#bf3770f49c4ecabdec290f9238f4a906">FS_ERR_NO_PART</a>;
<a name="l00183"></a>00183             <span class="keywordflow">return</span> FALSE;
<a name="l00184"></a>00184          }
<a name="l00185"></a>00185 <span class="preprocessor">#endif</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span>      }
<a name="l00187"></a>00187       
<a name="l00188"></a>00188       <span class="comment">//** Check a PBR structure</span>
<a name="l00189"></a>00189       <span class="keywordflow">if</span> ( (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[0] == 0xEB) &amp;&amp;          <span class="comment">// PBR Byte 0</span>
<a name="l00190"></a>00190            (<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[2] == 0x90) &amp;&amp;          <span class="comment">// PBR Byte 2</span>
<a name="l00191"></a>00191            ((<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[21] &amp; 0xF0) == 0xF0) ) <span class="comment">// PBR Byte 21 : Media byte</span>
<a name="l00192"></a>00192       {  
<a name="l00193"></a>00193          <span class="keywordflow">break</span>;   <span class="comment">// valid PBR found</span>
<a name="l00194"></a>00194       }
<a name="l00195"></a>00195       <span class="comment">// PBR not found</span>
<a name="l00196"></a>00196       <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#bf3770f49c4ecabdec290f9238f4a906">FS_ERR_NO_PART</a>;
<a name="l00197"></a>00197       <span class="keywordflow">return</span> FALSE;
<a name="l00198"></a>00198    }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200    <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#76bd560138ff87de29b59767546d8bf3">FS_ERR_NO_SUPPORT_PART</a>; <span class="comment">// by default no support part error</span>
<a name="l00201"></a>00201 
<a name="l00202"></a>00202    <span class="comment">// Check the BPB_u16BytsPerSec (in bytes)</span>
<a name="l00203"></a>00203    <span class="keywordflow">if</span> (  ((<a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a> &amp; 0xFF) != <a class="code" href="a00018.html#931fb8aaa3236e5d2ee2d03424c07dc5">LOW_16_BPB_BytsPerSec</a>  )
<a name="l00204"></a>00204    ||    ((<a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a> &gt;&gt; 8)   != <a class="code" href="a00018.html#1bf0f3b3cb79deb5b7c459b5d10449d5">HIGH_16_BPB_BytsPerSec</a> )
<a name="l00205"></a>00205    ||    ( <a class="code" href="a00018.html#4d46dee315ad22b94de647e7c883edc0">FS_NB_FAT</a> != <a class="code" href="a00018.html#58a994fdcf3ee750422c9088d66033c1">U8_BPB_NumFATs</a> ) )   <span class="comment">// Check the BPB_NumFATs   </span>
<a name="l00206"></a>00206    {
<a name="l00207"></a>00207       <span class="keywordflow">return</span> FALSE;
<a name="l00208"></a>00208    }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210    <span class="comment">// Read BPB_SecPerClus (unit sector)</span>
<a name="l00211"></a>00211    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a> = <a class="code" href="a00018.html#14c055fd6f5b4bda4470668bab3694ee">U8_BPB_SecPerClus</a>;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213    <span class="comment">//** FAT Type determination (algorithm of "Hardware White Paper FAT")</span>
<a name="l00214"></a>00214    <span class="comment">// Find the size of FAT (unit sector)</span>
<a name="l00215"></a>00215    LSB( u16_tmp ) = <a class="code" href="a00018.html#fe57e984b2baf3970ac7feda02355ac9">LOW_16_BPB_FATSz16</a>;
<a name="l00216"></a>00216    MSB( u16_tmp ) = <a class="code" href="a00018.html#c7277af1ce6ee4efe860da2d1f3b1b38">HIGH_16_BPB_FATSz16</a>; 
<a name="l00217"></a>00217    <span class="keywordflow">if</span> ( 0==u16_tmp )
<a name="l00218"></a>00218    {
<a name="l00219"></a>00219       LSB( u16_tmp ) = <a class="code" href="a00018.html#c1ba95f06dfaaf3c71a5eb12dd56009c">LOW0_32_BPB_FATSz32</a>;
<a name="l00220"></a>00220       MSB( u16_tmp ) = <a class="code" href="a00018.html#dff814b0d106b4c3b3f730fbef8338ce">LOW1_32_BPB_FATSz32</a>; 
<a name="l00221"></a>00221       <span class="comment">// a big FAT32 isn't supported by this file system</span>
<a name="l00222"></a>00222       <span class="keywordflow">if</span>( (0 != <a class="code" href="a00018.html#8ef0e71139f216c7aaa15dc92f04ad74">LOW2_32_BPB_FATSz32</a> )
<a name="l00223"></a>00223       ||  (0 != <a class="code" href="a00018.html#ae445a7061c79d078f70001aa7d5ca16">LOW3_32_BPB_FATSz32</a> ) )
<a name="l00224"></a>00224       {
<a name="l00225"></a>00225          <span class="keywordflow">return</span> FALSE;
<a name="l00226"></a>00226       }
<a name="l00227"></a>00227    }
<a name="l00228"></a>00228    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a> = u16_tmp;
<a name="l00229"></a>00229    
<a name="l00230"></a>00230    <span class="comment">// Find the total count of sectors volume</span>
<a name="l00231"></a>00231    <span class="keywordflow">if</span> ( (0==<a class="code" href="a00018.html#b63400ba470fe3bf6c110a0af483ccc0">LOW_16_BPB_TotSec16</a>) &amp;&amp; (0==<a class="code" href="a00018.html#3f384bfdb0b306957dbc5f9c9b087dbe">HIGH_16_BPB_TotSec16</a>) )
<a name="l00232"></a>00232    {
<a name="l00233"></a>00233       LSB0( u32_tmp ) = <a class="code" href="a00018.html#874e06185fcba59848db370a65ffb162">LOW0_32_BPB_TotSec32</a>;
<a name="l00234"></a>00234       LSB1( u32_tmp ) = <a class="code" href="a00018.html#36c744b34bb704e3777d34a3b4c365a7">LOW1_32_BPB_TotSec32</a>; 
<a name="l00235"></a>00235       LSB2( u32_tmp ) = <a class="code" href="a00018.html#b1bff622ef1d89f52b64b80e0f04bb4c">LOW2_32_BPB_TotSec32</a>;
<a name="l00236"></a>00236       LSB3( u32_tmp ) = <a class="code" href="a00018.html#f6bd554441216cd3475dd35a23d2a282">LOW3_32_BPB_TotSec32</a>;
<a name="l00237"></a>00237    }
<a name="l00238"></a>00238    <span class="keywordflow">else</span>
<a name="l00239"></a>00239    {
<a name="l00240"></a>00240       LSB0( u32_tmp ) = <a class="code" href="a00018.html#b63400ba470fe3bf6c110a0af483ccc0">LOW_16_BPB_TotSec16</a>;
<a name="l00241"></a>00241       LSB1( u32_tmp ) = <a class="code" href="a00018.html#3f384bfdb0b306957dbc5f9c9b087dbe">HIGH_16_BPB_TotSec16</a>; 
<a name="l00242"></a>00242       LSB2( u32_tmp ) = 0;
<a name="l00243"></a>00243       LSB3( u32_tmp ) = 0;
<a name="l00244"></a>00244    }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246    <span class="comment">// Computed the offset (in sector) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR</span>
<a name="l00247"></a>00247    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428">seg</a>.<a class="code" href="a00007.html#a17ca07269fcb28d77b14e5a67d56378">u16_pos</a> = <a class="code" href="a00018.html#4d46dee315ad22b94de647e7c883edc0">FS_NB_FAT</a> * <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249    <span class="comment">// Computed the size of root directory (unit sector), for FAT32 is always 0</span>
<a name="l00250"></a>00250    LSB( u16_tmp ) = <a class="code" href="a00018.html#b1eab4cea0637f0fa8c7e521968803a2">LOW_16_BPB_RootEntCnt</a>;
<a name="l00251"></a>00251    MSB( u16_tmp ) = <a class="code" href="a00018.html#8f6e516573fdbd3ea8eadd402cc6e134">HIGH_16_BPB_RootEntCnt</a>;
<a name="l00252"></a>00252    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428">seg</a>.<a class="code" href="a00007.html#5e384bddb7393218e17f0329d1b8527f">u16_size</a> = ((u16_tmp * <a class="code" href="a00018.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>) + (<a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a>-1)) / <a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a>;
<a name="l00253"></a>00253    
<a name="l00254"></a>00254    <span class="comment">// Find the number of sector reserved</span>
<a name="l00255"></a>00255    LSB( u16_tmp ) = <a class="code" href="a00018.html#054eca177d5b03154cb95ead9e3cca0b">LOW_16_BPB_ResvSecCnt</a>;
<a name="l00256"></a>00256    MSB( u16_tmp ) = <a class="code" href="a00018.html#72679a68a6d92475a790f11861a92316">HIGH_16_BPB_ResvSecCnt</a>;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258    <span class="comment">// Computed the address (unit sector) of FAT</span>
<a name="l00259"></a>00259    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> = <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> + u16_tmp;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261    <span class="comment">// Computed the offset (in sector) between the first data cluster and the beginning of FAT</span>
<a name="l00262"></a>00262    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#d12585f4d1f75862d62ddcb9386b5d4d">u16_offset_data</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428">seg</a>.<a class="code" href="a00007.html#a17ca07269fcb28d77b14e5a67d56378">u16_pos</a> + <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428">seg</a>.<a class="code" href="a00007.html#5e384bddb7393218e17f0329d1b8527f">u16_size</a>;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264    <span class="comment">// Determine the count of SECTORS in the data region of the volume (Total - Sector used)</span>
<a name="l00265"></a>00265    u32_tmp -= (u16_tmp + <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#d12585f4d1f75862d62ddcb9386b5d4d">u16_offset_data</a>);
<a name="l00266"></a>00266 
<a name="l00267"></a>00267    <span class="comment">// Determine the count of CLUSTER in the data region of the volume</span>
<a name="l00268"></a>00268    <span class="comment">// !!!Optimization of -&gt; u32_CountofCluster / U8_BPB_SecPerClus (is a power of 2)</span>
<a name="l00269"></a>00269    <span class="keywordflow">for</span>( u8_tmp = <a class="code" href="a00018.html#14c055fd6f5b4bda4470668bab3694ee">U8_BPB_SecPerClus</a> ; u8_tmp!=1 ; u8_tmp &gt;&gt;= 1 )
<a name="l00270"></a>00270    {
<a name="l00271"></a>00271      u32_tmp  &gt;&gt;= 1;   <span class="comment">// This computation round down</span>
<a name="l00272"></a>00272    }
<a name="l00273"></a>00273    <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e">u32_CountofCluster</a> = u32_tmp+2; <span class="comment">// The total of cluster include the two reserved cluster</span>
<a name="l00274"></a>00274    
<a name="l00275"></a>00275    <span class="comment">// Determine the FAT type</span>
<a name="l00276"></a>00276    <span class="keywordflow">if</span> (u32_tmp &lt; <a class="code" href="a00018.html#2f2a41f51db7209b1e068193cd10a9d8">FS_FAT12_MAX_CLUSTERS</a>)
<a name="l00277"></a>00277    {
<a name="l00278"></a>00278       <span class="comment">// Is FAT 12</span>
<a name="l00279"></a>00279 #<span class="keywordflow">if</span> (<a class="code" href="a00014.html#4bc0b1fd476c5df6cbc3aa1e29a958cc">FS_FAT_12</a> == DISABLED)
<a name="l00280"></a>00280       <span class="keywordflow">return</span> FALSE;
<a name="l00281"></a>00281 <span class="preprocessor">#endif</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span>      <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> = <a class="code" href="a00018.html#cbc6a789e2144cbc0893187e2d665d8c">FS_TYPE_FAT_12</a>;
<a name="l00283"></a>00283    } <span class="keywordflow">else</span> {
<a name="l00284"></a>00284    <span class="keywordflow">if</span> (u32_tmp &lt; <a class="code" href="a00018.html#c1bec4fdf32e8ff9a9afc44b80607336">FS_FAT16_MAX_CLUSTERS</a>)
<a name="l00285"></a>00285    {
<a name="l00286"></a>00286       <span class="comment">// Is FAT 16</span>
<a name="l00287"></a>00287 #<span class="keywordflow">if</span> (<a class="code" href="a00014.html#b602b5d297b22da233ddd77cb62f2612">FS_FAT_16</a> == DISABLED)
<a name="l00288"></a>00288       <span class="keywordflow">return</span> FS_NO_SUPPORT_PART;
<a name="l00289"></a>00289 <span class="preprocessor">#endif</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span>      <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> = <a class="code" href="a00018.html#3433de4e69ce8d55317158ee2624e8af">FS_TYPE_FAT_16</a>;
<a name="l00291"></a>00291    } <span class="keywordflow">else</span> {
<a name="l00292"></a>00292       <span class="comment">// Is FAT 32</span>
<a name="l00293"></a>00293 <span class="preprocessor">#if (FS_FAT_32 == DISABLED)</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>      <span class="keywordflow">return</span> FALSE;
<a name="l00295"></a>00295 <span class="preprocessor">#endif</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span>      <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> = <a class="code" href="a00018.html#bed7b1e094b19dac8efa753f59f84fc6">FS_TYPE_FAT_32</a>;
<a name="l00297"></a>00297       <span class="comment">// In FAT32, the root dir is file with a start cluster</span>
<a name="l00298"></a>00298       LSB0( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b">u32_cluster</a> ) = <a class="code" href="a00018.html#0a4a06552fb3a44093ef87a09fc2840f">LOW0_32_BPB_RootClus</a>;
<a name="l00299"></a>00299       LSB1( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b">u32_cluster</a> ) = <a class="code" href="a00018.html#dd80ee1ba4292b33a35bb9794e46b91d">LOW1_32_BPB_RootClus</a>; 
<a name="l00300"></a>00300       LSB2( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b">u32_cluster</a> ) = <a class="code" href="a00018.html#47260296ce546b21bd10d3ddc963a2c7">LOW2_32_BPB_RootClus</a>;
<a name="l00301"></a>00301       LSB3( <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b">u32_cluster</a> ) = <a class="code" href="a00018.html#68f0eada6fa2bbfffcdc98fcd463d225">LOW3_32_BPB_RootClus</a>;
<a name="l00302"></a>00302    }
<a name="l00303"></a>00303    }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305    <span class="keywordflow">return</span> TRUE;
<a name="l00306"></a>00306 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0a8beb16a074b07828fc725e0c0ae500"></a><!-- doxytag: member="fat_unusual.c::fat_read_fat32_FSInfo" ref="0a8beb16a074b07828fc725e0c0ae500" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 fat_read_fat32_FSInfo           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction return the space free in the drive partition FAT32 selected. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of sector free (if 0xFFFFFFFF, then no value available in FSInfo Sector) </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l00874">874</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00034.html#l00146">FS_BR_SIGNATURE_HIGH</a>, <a class="el" href="a00034.html#l00145">FS_BR_SIGNATURE_LOW</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, and <a class="el" href="a00034.html#l00267">Fs_management::u32_ptr_fat</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01986">fat_getfreespace()</a>, and <a class="el" href="a00035.html#l02049">fat_getfreespace_percent()</a>.<div class="fragment"><pre class="fragment"><a name="l00875"></a>00875 {
<a name="l00876"></a>00876    U32 u32_nb_free_cluster;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878    <span class="comment">//* Read FAT32 FSInfo Sector</span>
<a name="l00879"></a>00879    <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> - 31;
<a name="l00880"></a>00880    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( TRUE ))
<a name="l00881"></a>00881       <span class="keywordflow">return</span> FALSE;
<a name="l00882"></a>00882    
<a name="l00883"></a>00883    <span class="comment">//* Check signature</span>
<a name="l00884"></a>00884    <span class="comment">// offset 510-511, Signature</span>
<a name="l00885"></a>00885    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[510] != <a class="code" href="a00018.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a> )
<a name="l00886"></a>00886       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00887"></a>00887    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[511] != <a class="code" href="a00018.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>)
<a name="l00888"></a>00888       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00889"></a>00889    <span class="comment">// offset 00-04, This lead signature</span>
<a name="l00890"></a>00890    <span class="keywordflow">if</span>( 0 != memcmp_code2ram( &amp;<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[0], <a class="code" href="a00019.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>) ))
<a name="l00891"></a>00891       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00892"></a>00892    <span class="comment">// offset 004-483, reserved (fill with 0)</span>
<a name="l00893"></a>00893    <span class="comment">// offset 484-487, signature</span>
<a name="l00894"></a>00894    <span class="keywordflow">if</span>( 0 != memcmp_code2ram( &amp;<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[484], <a class="code" href="a00019.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>)) )
<a name="l00895"></a>00895       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00896"></a>00896    
<a name="l00897"></a>00897    <span class="comment">//* Read value</span>
<a name="l00898"></a>00898    <span class="comment">// offset 488-491, free cluster count</span>
<a name="l00899"></a>00899    LSB0(u32_nb_free_cluster) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[488];
<a name="l00900"></a>00900    LSB1(u32_nb_free_cluster) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[489];
<a name="l00901"></a>00901    LSB2(u32_nb_free_cluster) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[490];
<a name="l00902"></a>00902    LSB3(u32_nb_free_cluster) = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[491];
<a name="l00903"></a>00903    <span class="keywordflow">return</span> u32_nb_free_cluster;
<a name="l00904"></a>00904 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="477e90a97f3fcb8361020feb2557098d"></a><!-- doxytag: member="fat_unusual.c::fat_select_filesystem" ref="477e90a97f3fcb8361020feb2557098d" args="(U8 u8_fat_type, Bool b_MBR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_select_filesystem           </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_fat_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>b_MBR</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction compute the file system type to use for the disk selected. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u8_fat_type</em>&nbsp;</td><td>Select the type of format <br>
 FS_FORMAT_DEFAULT, The file system module choose the better FAT format for the drive space <br>
 FS_FORMAT_FAT, The FAT12 or FAT16 is used to format the drive, if possible (disk space &lt;2GB) <br>
 FS_FORMAT_FAT32, The FAT32 is used to format the drive, if possible (disk space &gt;32MB) <br>
 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b_MBR</em>&nbsp;</td><td>TRUE, include a MBR on disk</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise</dd></dl>
<div class="fragment"><pre class="fragment">
//! Compute the fat type, fat position and fat size.
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l00477">477</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00038.html#l00224">FS_ERR_BAD_SIZE_FAT</a>, <a class="el" href="a00038.html#l00159">FS_FORMAT_FAT</a>, <a class="el" href="a00038.html#l00160">FS_FORMAT_FAT32</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00370">fs_g_nav_fast</a>, <a class="el" href="a00038.html#l00257">fs_g_status</a>, <a class="el" href="a00035.html#l00313">fs_s_u32_size_partition</a>, <a class="el" href="a00034.html#l00206">FS_SIZE_OF_SECTOR</a>, <a class="el" href="a00034.html#l00339">FS_TYPE_FAT_12</a>, <a class="el" href="a00034.html#l00340">FS_TYPE_FAT_16</a>, <a class="el" href="a00034.html#l00341">FS_TYPE_FAT_32</a>, <a class="el" href="a00035.html#l00394">TableFAT12</a>, <a class="el" href="a00035.html#l00413">TableFAT16</a>, <a class="el" href="a00035.html#l00439">TableFAT32</a>, <a class="el" href="a00034.html#l00263">Fs_management::u8_BPB_SecPerClus</a>, <a class="el" href="a00033.html#l00351">u8_i</a>, and <a class="el" href="a00034.html#l00278">Fs_management_fast::u8_type_fat</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00335">fat_format()</a>.<div class="fragment"><pre class="fragment"><a name="l00478"></a>00478 {
<a name="l00479"></a>00479    U8 <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a>;
<a name="l00480"></a>00480    U8 u8_tmp = 0;
<a name="l00481"></a>00481    U16  u16_tmp, u16_tmp2;
<a name="l00482"></a>00482    <a class="code" href="a00011.html">Fs_format_table</a> _CONST_TYPE_ *ptr_table;
<a name="l00483"></a>00483   
<a name="l00484"></a>00484    <span class="comment">//** Check if the default system are selected</span>
<a name="l00485"></a>00485    <span class="keywordflow">if</span>( (<a class="code" href="a00022.html#df4231c592cf152d2fa607e43ec3071e">FS_FORMAT_FAT</a>   != u8_fat_type )
<a name="l00486"></a>00486    &amp;&amp;  (<a class="code" href="a00022.html#052a9dbafcad051e18df689130f9b256">FS_FORMAT_FAT32</a> != u8_fat_type ) )
<a name="l00487"></a>00487    {  <span class="comment">// It is the default format option</span>
<a name="l00488"></a>00488       <span class="keywordflow">if</span>( (((U32)512*1024*1024)/<a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a>) &gt;= <a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>  )
<a name="l00489"></a>00489       {
<a name="l00490"></a>00490          u8_fat_type = <a class="code" href="a00022.html#df4231c592cf152d2fa607e43ec3071e">FS_FORMAT_FAT</a>;
<a name="l00491"></a>00491       } <span class="keywordflow">else</span> {
<a name="l00492"></a>00492          u8_fat_type = <a class="code" href="a00022.html#052a9dbafcad051e18df689130f9b256">FS_FORMAT_FAT32</a>;
<a name="l00493"></a>00493       }
<a name="l00494"></a>00494    }
<a name="l00495"></a>00495    
<a name="l00496"></a>00496    <span class="comment">//** Check the file system choice</span>
<a name="l00497"></a>00497    <span class="keywordflow">if</span>(<a class="code" href="a00022.html#df4231c592cf152d2fa607e43ec3071e">FS_FORMAT_FAT</a> == u8_fat_type )
<a name="l00498"></a>00498    {  
<a name="l00499"></a>00499       <span class="keywordflow">if</span>( (((U32)15*1024*1024)/<a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a>) &gt;= <a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>  )
<a name="l00500"></a>00500       {
<a name="l00501"></a>00501          <span class="comment">// FAT 12 format</span>
<a name="l00502"></a>00502          <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> = <a class="code" href="a00018.html#cbc6a789e2144cbc0893187e2d665d8c">FS_TYPE_FAT_12</a>;
<a name="l00503"></a>00503          u8_i = <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#12c9e9d2a4cbd29f35072cccecc0f0d5">TableFAT12</a>);
<a name="l00504"></a>00504          ptr_table = <a class="code" href="a00019.html#12c9e9d2a4cbd29f35072cccecc0f0d5">TableFAT12</a>;
<a name="l00505"></a>00505       }<span class="keywordflow">else</span>{
<a name="l00506"></a>00506          <span class="comment">// FAT 16 format</span>
<a name="l00507"></a>00507          <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> = <a class="code" href="a00018.html#3433de4e69ce8d55317158ee2624e8af">FS_TYPE_FAT_16</a>;
<a name="l00508"></a>00508          u8_i = <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#e060256d5bbd91d6412e3601893935b4">TableFAT16</a>);
<a name="l00509"></a>00509          ptr_table = <a class="code" href="a00019.html#e060256d5bbd91d6412e3601893935b4">TableFAT16</a>;
<a name="l00510"></a>00510       }
<a name="l00511"></a>00511    }
<a name="l00512"></a>00512    <span class="keywordflow">else</span>
<a name="l00513"></a>00513    {  <span class="comment">// FAT 32 format</span>
<a name="l00514"></a>00514       <a class="code" href="a00018.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920">u8_type_fat</a> = <a class="code" href="a00018.html#bed7b1e094b19dac8efa753f59f84fc6">FS_TYPE_FAT_32</a>;
<a name="l00515"></a>00515       u8_i = <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#c25415e8010641385456353f4c1c5eec">TableFAT32</a>);
<a name="l00516"></a>00516       ptr_table = <a class="code" href="a00019.html#c25415e8010641385456353f4c1c5eec">TableFAT32</a>;
<a name="l00517"></a>00517    }
<a name="l00518"></a>00518    <span class="keywordflow">for</span>(  ; u8_i!=0 ; u8_i-- )
<a name="l00519"></a>00519    {
<a name="l00520"></a>00520       <span class="keywordflow">if</span>( fs_s_u32_size_partition &lt;= ptr_table-&gt;u32_disk_size )
<a name="l00521"></a>00521       {
<a name="l00522"></a>00522          <span class="comment">// Size of cluster (unit sector)</span>
<a name="l00523"></a>00523          <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a> = ptr_table-&gt;u8_SecPerClusVal;
<a name="l00524"></a>00524          <span class="keywordflow">break</span>;
<a name="l00525"></a>00525       }
<a name="l00526"></a>00526       ptr_table++;
<a name="l00527"></a>00527    }
<a name="l00528"></a>00528    <span class="keywordflow">if</span>(0 == <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>)
<a name="l00529"></a>00529    {
<a name="l00530"></a>00530       <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#71c0c3d03cdea7bfff5f3a97a8020a33">FS_ERR_BAD_SIZE_FAT</a>;    <span class="comment">// The disk size is smaller than 4,1MB, or not supported by file system selected</span>
<a name="l00531"></a>00531       <span class="keywordflow">return</span> FALSE;
<a name="l00532"></a>00532    }
<a name="l00533"></a>00533    
<a name="l00534"></a>00534    <span class="comment">//** Compute fat size</span>
<a name="l00535"></a>00535    <span class="comment">// Compute PBR address</span>
<a name="l00536"></a>00536    <span class="keywordflow">if</span>( b_MBR )
<a name="l00537"></a>00537       <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> = 1;  <span class="comment">// MBR exist</span>
<a name="l00538"></a>00538    <span class="keywordflow">else</span>
<a name="l00539"></a>00539       <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> = 0;  <span class="comment">// no MBR</span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l00542"></a>00542    {  <span class="comment">// FAT 12     </span>
<a name="l00543"></a>00543       <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> += 1;  <span class="comment">// FAT address = PBR address + 1</span>
<a name="l00544"></a>00544       <span class="comment">// Try all possibility of FAT12 size</span>
<a name="l00545"></a>00545       <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>=1;
<a name="l00546"></a>00546       <span class="keywordflow">while</span>(1)
<a name="l00547"></a>00547       {
<a name="l00548"></a>00548          <span class="keywordflow">if</span>( 12 &lt; <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>)   <span class="comment">// Max FAT size in FAT12 mode (unit sector) (=0xFFE*1.5/FS_SIZE_OF_SECTOR)</span>
<a name="l00549"></a>00549          {
<a name="l00550"></a>00550             <a class="code" href="a00022.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00022.html#71c0c3d03cdea7bfff5f3a97a8020a33">FS_ERR_BAD_SIZE_FAT</a>;    <span class="comment">// The disk size is smaller than 4,1MB, or not supported by file system selected</span>
<a name="l00551"></a>00551             <span class="keywordflow">return</span> FALSE;
<a name="l00552"></a>00552          }
<a name="l00553"></a>00553          <span class="comment">// Compare the number of cluster of data zone</span>
<a name="l00554"></a>00554          <span class="comment">// Note: -1 to not compute PBR sector</span>
<a name="l00555"></a>00555          u16_tmp  = ((<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> -1 - (<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a> *2)) / <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>)+2;
<a name="l00556"></a>00556          u16_tmp2 = (<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a> *<a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a> *2) / 3;
<a name="l00557"></a>00557          <span class="keywordflow">if</span>( u16_tmp &lt;= u16_tmp2 )
<a name="l00558"></a>00558             <span class="keywordflow">break</span>;   <span class="comment">// FAT size OK</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560          <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>++;
<a name="l00561"></a>00561       }
<a name="l00562"></a>00562    }
<a name="l00563"></a>00563    <span class="keywordflow">else</span>
<a name="l00564"></a>00564    {
<a name="l00565"></a>00565       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00566"></a>00566       {  <span class="comment">// FAT 32</span>
<a name="l00567"></a>00567          <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> += 32;  <span class="comment">// FAT address = PBR address + BPB_ResvSecCnt</span>
<a name="l00568"></a>00568          <span class="comment">// RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec  1)) / BPB_BytsPerSec;</span>
<a name="l00569"></a>00569          <span class="comment">//                = (FS_SIZE_OF_SECTOR-1) / FS_SIZE_OF_SECTOR = 0</span>
<a name="l00570"></a>00570          <span class="comment">// TmpVal1        = DskSize  (BPB_ResvdSecCnt + RootDirSectors);</span>
<a name="l00571"></a>00571          <span class="comment">//                = fs_s_u32_size_partition - (32 + 0)</span>
<a name="l00572"></a>00572          <span class="comment">//                = fs_s_u32_size_partition - u8_tmp</span>
<a name="l00573"></a>00573          u8_tmp = 32;
<a name="l00574"></a>00574          <span class="comment">// TmpVal2        = ((256 * BPB_SecPerClus) + BPB_NumFATs )/2;</span>
<a name="l00575"></a>00575          <span class="comment">//                = ((((U16)fs_g_nav.u8_BPB_SecPerClus)&lt;&lt;8) + 2) &gt;&gt; 1;</span>
<a name="l00576"></a>00576          <span class="comment">//                = (((U16)fs_g_nav.u8_BPB_SecPerClus)&lt;&lt;7) + 1;</span>
<a name="l00577"></a>00577          <span class="comment">//                = u16_tmp</span>
<a name="l00578"></a>00578          u16_tmp = (((U16)<a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>)&lt;&lt;7) + 1;
<a name="l00579"></a>00579          <span class="comment">// BPB_FATSz16    = 0;</span>
<a name="l00580"></a>00580          <span class="comment">// BPB_FATSz32    = FATSz;</span>
<a name="l00581"></a>00581       }
<a name="l00582"></a>00582       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l00583"></a>00583       {  <span class="comment">// FAT 16</span>
<a name="l00584"></a>00584          <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> += 1;  <span class="comment">// FAT address = PBR address + BPB_ResvSecCnt</span>
<a name="l00585"></a>00585          <span class="comment">// RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec  1))  / BPB_BytsPerSec</span>
<a name="l00586"></a>00586          <span class="comment">//                = ((512            * 32) + (FS_SIZE_OF_SECTOR-1)) / FS_SIZE_OF_SECTOR</span>
<a name="l00587"></a>00587          <span class="comment">//                = 32</span>
<a name="l00588"></a>00588          <span class="comment">// TmpVal1        = DskSize  (BPB_ResvdSecCnt + RootDirSectors);</span>
<a name="l00589"></a>00589          <span class="comment">//                = fs_s_u32_size_partition - (1 + 32)</span>
<a name="l00590"></a>00590          <span class="comment">//                = fs_s_u32_size_partition - u8_tmp</span>
<a name="l00591"></a>00591          u8_tmp = 33;
<a name="l00592"></a>00592          <span class="comment">// TmpVal2        = ((256 * BPB_SecPerClus) + BPB_NumFATs )/2;</span>
<a name="l00593"></a>00593          <span class="comment">//                = (((U16)fs_g_nav.u8_BPB_SecPerClus)&lt;&lt;8) + 2;</span>
<a name="l00594"></a>00594          <span class="comment">//                = u16_tmp</span>
<a name="l00595"></a>00595          MSB(u16_tmp) = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>;
<a name="l00596"></a>00596          LSB(u16_tmp) = 2;
<a name="l00597"></a>00597       }
<a name="l00598"></a>00598       <span class="comment">// FATSz          = (TMPVal1 + TmpVal2  1) / TmpVal2;</span>
<a name="l00599"></a>00599       <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a> = (<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> -u8_tmp +u16_tmp -1) / u16_tmp;
<a name="l00600"></a>00600    }
<a name="l00601"></a>00601    
<a name="l00602"></a>00602    <span class="keywordflow">return</span> TRUE;
<a name="l00603"></a>00603 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ff43f97db7a5d76f46f4fb1b683d192"></a><!-- doxytag: member="fat_unusual.c::fat_serialnumber" ref="2ff43f97db7a5d76f46f4fb1b683d192" args="(Bool b_action, U8 _MEM_TYPE_SLOW_ *a_u8_sn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_serialnumber           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>b_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8 _MEM_TYPE_SLOW_ *&nbsp;</td>
          <td class="paramname"> <em>a_u8_sn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction to read or to write a serial number. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b_action</em>&nbsp;</td><td>choose action (FS_SN_READ or FS_SN_WRITE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_u8_sn</em>&nbsp;</td><td>array to store or get the serial number (U8[4])</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01017">1017</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01810">fat_cache_flush()</a>, <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00038.html#l00092">FS_SN_READ</a>, <a class="el" href="a00034.html#l00077">Is_fat12</a>, <a class="el" href="a00034.html#l00082">Is_fat16</a>, and <a class="el" href="a00034.html#l00267">Fs_management::u32_ptr_fat</a>.
<p>
Referenced by <a class="el" href="a00042.html#l00420">nav_partition_serialnumber()</a>.<div class="fragment"><pre class="fragment"><a name="l01018"></a>01018 {
<a name="l01019"></a>01019    <span class="comment">// compute address of PBR sector</span>
<a name="l01020"></a>01020    <span class="keywordflow">if</span> ( <a class="code" href="a00018.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> || <a class="code" href="a00018.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l01021"></a>01021    {  <span class="comment">// FAT 12 &amp; 16 (BPB_ResvSecCnt must be ega to 1)</span>
<a name="l01022"></a>01022       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a>-1;
<a name="l01023"></a>01023    }
<a name="l01024"></a>01024    <span class="keywordflow">else</span>
<a name="l01025"></a>01025    {  <span class="comment">// FAT 32 (BPB_ResvSecCnt must be ega to 32)</span>
<a name="l01026"></a>01026       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a>-32;
<a name="l01027"></a>01027    }
<a name="l01028"></a>01028    <span class="comment">// Read PBR</span>
<a name="l01029"></a>01029    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( TRUE ))
<a name="l01030"></a>01030       <span class="keywordflow">return</span> FALSE;
<a name="l01031"></a>01031 
<a name="l01032"></a>01032    <span class="comment">// The serial is storage at invert</span>
<a name="l01033"></a>01033    <span class="keywordflow">if</span>( b_action == <a class="code" href="a00022.html#030606a7731d280a91dd5b796e50804e">FS_SN_READ</a> )
<a name="l01034"></a>01034    {
<a name="l01035"></a>01035       <span class="comment">// Read serial number</span>
<a name="l01036"></a>01036       a_u8_sn[0] = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[42];
<a name="l01037"></a>01037       a_u8_sn[1] = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[41];
<a name="l01038"></a>01038       a_u8_sn[2] = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[40];
<a name="l01039"></a>01039       a_u8_sn[3] = <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[39];
<a name="l01040"></a>01040       <span class="keywordflow">return</span> TRUE;
<a name="l01041"></a>01041    }<span class="keywordflow">else</span>{
<a name="l01042"></a>01042       <span class="comment">// Write serial number</span>
<a name="l01043"></a>01043       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[42] = a_u8_sn[0];
<a name="l01044"></a>01044       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[41] = a_u8_sn[1];
<a name="l01045"></a>01045       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[40] = a_u8_sn[2];
<a name="l01046"></a>01046       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[39] = a_u8_sn[3];
<a name="l01047"></a>01047       <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01048"></a>01048       <span class="keywordflow">return</span> <a class="code" href="a00017.html#578ab4800128cde17c0820a5027c1c06">fat_cache_flush</a>();
<a name="l01049"></a>01049    }
<a name="l01050"></a>01050 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="838253d384d03898e6fcb2b3a7687e43"></a><!-- doxytag: member="fat_unusual.c::fat_set_date" ref="838253d384d03898e6fcb2b3a7687e43" args="(const FS_STRING sz_date, Bool type_date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_set_date           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>type_date</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction change the informations about date. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type_date</em>&nbsp;</td><td>choose date field (FS_DATE_LAST_WRITE or FS_DATE_CREATION) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sz_date</em>&nbsp;</td><td>table to store the information about date <br>
 storage format (ASCII) = "YYYYMMDDHHMMSSMS" = year, month, day, hour, minute, seconde, miliseconde</td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment">
//! OUT, update cache sector with the new date
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01321">1321</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00033.html#l01720">fat_get_ptr_entry()</a>, <a class="el" href="a00035.html#l01350">fat_translatedate_ascii_to_number()</a>, and <a class="el" href="a00038.html#l00112">FS_DATE_LAST_WRITE</a>.
<p>
Referenced by <a class="el" href="a00042.html#l01804">nav_file_dateset()</a>.<div class="fragment"><pre class="fragment"><a name="l01322"></a>01322 {
<a name="l01323"></a>01323    <a class="code" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01324"></a>01324 
<a name="l01325"></a>01325    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l01326"></a>01326    ptr_entry = <a class="code" href="a00017.html#0c24a717d004b7194e2c566522348fd5">fat_get_ptr_entry</a>();
<a name="l01327"></a>01327 
<a name="l01328"></a>01328    <span class="keywordflow">if</span>( <a class="code" href="a00022.html#fbbd68bf71e1e73a9162dd04f3dec8fe">FS_DATE_LAST_WRITE</a> == type_date )
<a name="l01329"></a>01329    {
<a name="l01330"></a>01330       <a class="code" href="a00019.html#f2d2b930b3953ad1cfc996de5970a138">fat_translatedate_ascii_to_number</a>( sz_date , &amp;ptr_entry[22] , FALSE );
<a name="l01331"></a>01331    }
<a name="l01332"></a>01332    <span class="keywordflow">else</span>
<a name="l01333"></a>01333    {
<a name="l01334"></a>01334       <a class="code" href="a00019.html#f2d2b930b3953ad1cfc996de5970a138">fat_translatedate_ascii_to_number</a>( sz_date , &amp;ptr_entry[13] , TRUE );
<a name="l01335"></a>01335    }
<a name="l01336"></a>01336 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f138eb34db69daa5d51e33d130d85424"></a><!-- doxytag: member="fat_unusual.c::fat_translate_ascii_to_number" ref="f138eb34db69daa5d51e33d130d85424" args="(const FS_STRING sz_ascii_number, U8 u8_size_number_ascii)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U16 fat_translate_ascii_to_number           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_ascii_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_size_number_ascii</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction translate a ASCII number to a digital number. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_ascii_number</em>&nbsp;</td><td>enter le initiale ascii string to increment (ex:"1907") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u8_size_number_ascii</em>&nbsp;</td><td>enter le number of digit (ex:4)</td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment">
//! OUT, update sz_ascii_number
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01411">1411</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l00351">u8_i</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01350">fat_translatedate_ascii_to_number()</a>.<div class="fragment"><pre class="fragment"><a name="l01412"></a>01412 {
<a name="l01413"></a>01413    U8 sz_ascii_number_copy[4];
<a name="l01414"></a>01414    U8 _MEM_TYPE_FAST_ *ptr_sz_ascii_number;
<a name="l01415"></a>01415    U8 <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a>;
<a name="l01416"></a>01416    U16 u16_number;
<a name="l01417"></a>01417 
<a name="l01418"></a>01418    <span class="keywordflow">for</span>( u8_i=0; u8_i &lt; u8_size_number_ascii; u8_i++ )
<a name="l01419"></a>01419    {
<a name="l01420"></a>01420       sz_ascii_number_copy[u8_i] = sz_ascii_number[u8_i];
<a name="l01421"></a>01421    }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423    u16_number=0;
<a name="l01424"></a>01424 
<a name="l01425"></a>01425    <span class="keywordflow">while</span>( 1 )
<a name="l01426"></a>01426    {
<a name="l01427"></a>01427       <span class="comment">// check if is the end of ascii number (= "0...0")</span>
<a name="l01428"></a>01428       ptr_sz_ascii_number = sz_ascii_number_copy;
<a name="l01429"></a>01429       <span class="keywordflow">for</span>( u8_i = u8_size_number_ascii; u8_i !=0; u8_i-- )
<a name="l01430"></a>01430       {
<a name="l01431"></a>01431          <span class="keywordflow">if</span>( <span class="charliteral">'0'</span> != *ptr_sz_ascii_number )
<a name="l01432"></a>01432          {
<a name="l01433"></a>01433             <span class="keywordflow">break</span>;
<a name="l01434"></a>01434          }
<a name="l01435"></a>01435          ptr_sz_ascii_number++;
<a name="l01436"></a>01436       }
<a name="l01437"></a>01437       <span class="keywordflow">if</span>( 0 == u8_i)
<a name="l01438"></a>01438          <span class="keywordflow">return</span> u16_number;
<a name="l01439"></a>01439          
<a name="l01440"></a>01440       <span class="comment">// Decrement the numbers</span>
<a name="l01441"></a>01441       ptr_sz_ascii_number = sz_ascii_number_copy + u8_size_number_ascii -1;
<a name="l01442"></a>01442       u16_number++;
<a name="l01443"></a>01443       ptr_sz_ascii_number[0]--;
<a name="l01444"></a>01444       <span class="keywordflow">while</span>( (<span class="charliteral">'0'</span>-1) == ptr_sz_ascii_number[0] )
<a name="l01445"></a>01445       {
<a name="l01446"></a>01446          *ptr_sz_ascii_number = <span class="charliteral">'9'</span>;
<a name="l01447"></a>01447          ptr_sz_ascii_number--;
<a name="l01448"></a>01448          ptr_sz_ascii_number[0]--;
<a name="l01449"></a>01449       }
<a name="l01450"></a>01450    }
<a name="l01451"></a>01451 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bb2561113110b35fac032431243f8bb0"></a><!-- doxytag: member="fat_unusual.c::fat_translate_char_shortname" ref="bb2561113110b35fac032431243f8bb0" args="(U8 character)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 fat_translate_char_shortname           </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>character</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction translate the character to short name character autorized. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>character</em>&nbsp;</td><td>character to translate</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the character translated <br>
 if no supported then 0 </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l01842">1842</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01601">fat_create_short_entry_name()</a>.<div class="fragment"><pre class="fragment"><a name="l01843"></a>01843 {
<a name="l01844"></a>01844    U8 u8_j;
<a name="l01845"></a>01845    
<a name="l01846"></a>01846    <span class="keywordflow">if</span>( (character&lt;=<span class="charliteral">' '</span>) || (<span class="charliteral">'~'</span>&lt;character) )
<a name="l01847"></a>01847       <span class="keywordflow">return</span> 0;
<a name="l01848"></a>01848    <span class="keywordflow">if</span>( (<span class="charliteral">'a'</span>&lt;=character) &amp;&amp; (character&lt;=<span class="charliteral">'z'</span>) )
<a name="l01849"></a>01849    {
<a name="l01850"></a>01850       <span class="keywordflow">return</span> (character - (<span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>)); <span class="comment">// Change to upper case</span>
<a name="l01851"></a>01851    }
<a name="l01852"></a>01852    <span class="keywordflow">for</span>( u8_j = 0 ; u8_j &lt; <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#89cf8e55b9308a287d4f24c28f8278ed">fs_s_execption_char</a>) ; u8_j++ )
<a name="l01853"></a>01853    {
<a name="l01854"></a>01854       <span class="keywordflow">if</span>( character == <a class="code" href="a00019.html#89cf8e55b9308a287d4f24c28f8278ed">fs_s_execption_char</a>[u8_j] )
<a name="l01855"></a>01855          <span class="keywordflow">return</span> 0;
<a name="l01856"></a>01856    }
<a name="l01857"></a>01857    <span class="keywordflow">return</span> character;       <span class="comment">// write the character</span>
<a name="l01858"></a>01858 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1a3ce899100c1b2a7798140852d9f22b"></a><!-- doxytag: member="fat_unusual.c::fat_translate_number_to_ascii" ref="1a3ce899100c1b2a7798140852d9f22b" args="(FS_STRING sz_ascii_number, U8 u8_size_number_ascii, U8 u8_nb_increment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_translate_number_to_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_ascii_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_size_number_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>u8_nb_increment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction translate a digital number to a ASCII number. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_ascii_number</em>&nbsp;</td><td>enter le initiale ascii string to increment (ex:"1907") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u8_size_number_ascii</em>&nbsp;</td><td>enter le number of digit (ex:4) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u8_nb_increment</em>&nbsp;</td><td>enter le number of increment (ex:"102")</td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment">
//! OUT, Update sz_ascii_number (ex:"2009")
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01290">1290</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01217">fat_translatedate_number_to_ascii()</a>.<div class="fragment"><pre class="fragment"><a name="l01291"></a>01291 {
<a name="l01292"></a>01292    <a class="code" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> ptr_sz_ascii_number;
<a name="l01293"></a>01293 
<a name="l01294"></a>01294    u8_size_number_ascii--;
<a name="l01295"></a>01295 
<a name="l01296"></a>01296    <span class="keywordflow">for</span>( ; u8_nb_increment != 0 ; u8_nb_increment-- )
<a name="l01297"></a>01297    {
<a name="l01298"></a>01298       ptr_sz_ascii_number = sz_ascii_number + u8_size_number_ascii;
<a name="l01299"></a>01299       ptr_sz_ascii_number[0]++;
<a name="l01300"></a>01300       <span class="keywordflow">while</span>( (<span class="charliteral">'9'</span>+1) == *ptr_sz_ascii_number )
<a name="l01301"></a>01301       {
<a name="l01302"></a>01302          *ptr_sz_ascii_number = <span class="charliteral">'0'</span>;
<a name="l01303"></a>01303          ptr_sz_ascii_number--;
<a name="l01304"></a>01304          ptr_sz_ascii_number[0]++;
<a name="l01305"></a>01305       }
<a name="l01306"></a>01306    }
<a name="l01307"></a>01307 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f2d2b930b3953ad1cfc996de5970a138"></a><!-- doxytag: member="fat_unusual.c::fat_translatedate_ascii_to_number" ref="f2d2b930b3953ad1cfc996de5970a138" args="(const FS_STRING sz_date, PTR_CACHE ptr_date, Bool enable_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_translatedate_ascii_to_number           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a>&nbsp;</td>
          <td class="paramname"> <em>ptr_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction translate a date and time ascii string to FAT value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_date</em>&nbsp;</td><td>table to store the information about date <br>
 storage format (ASCII) = "YYYYMMDDHHMMSSMS" = year, month, day, hour, minute, seconde, miliseconde </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr_date</em>&nbsp;</td><td>point in cache directory sector of the date to translate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable_ms</em>&nbsp;</td><td>TRUE, translate the millisecond field</td></tr>
  </table>
</dl>
<div class="fragment"><pre class="fragment">
//! OUT, write the date field at ptr_date
//! </pre></div> 
<p>
Definition at line <a class="el" href="a00035.html#l01350">1350</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00035.html#l01411">fat_translate_ascii_to_number()</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01321">fat_set_date()</a>.<div class="fragment"><pre class="fragment"><a name="l01351"></a>01351 {
<a name="l01352"></a>01352    U8 u8_tmp;
<a name="l01353"></a>01353    U8 msb_date, lsb_date, msb_time, lsb_time;
<a name="l01354"></a>01354    
<a name="l01355"></a>01355    <span class="comment">// Set the year</span>
<a name="l01356"></a>01356    msb_date  = ((U8)(<a class="code" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a>( sz_date , 4 )-1980))&lt;&lt;1;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358    <span class="comment">// Set the month</span>
<a name="l01359"></a>01359    u8_tmp    = (U8)<a class="code" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a>( &amp;sz_date[4] , 2 );
<a name="l01360"></a>01360    msb_date |= (u8_tmp &gt;&gt; 3); 
<a name="l01361"></a>01361    lsb_date  = (u8_tmp &lt;&lt; 5); 
<a name="l01362"></a>01362 
<a name="l01363"></a>01363    <span class="comment">// Set the day</span>
<a name="l01364"></a>01364    lsb_date |= (U8)<a class="code" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a>( &amp;sz_date[6] , 2 );
<a name="l01365"></a>01365 
<a name="l01366"></a>01366    <span class="comment">// Set the hour</span>
<a name="l01367"></a>01367    msb_time  = ((U8)<a class="code" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a>( &amp;sz_date[8] , 2 )) &lt;&lt; (11-8);
<a name="l01368"></a>01368 
<a name="l01369"></a>01369    <span class="comment">// Set the minute</span>
<a name="l01370"></a>01370    u8_tmp    = (U8)<a class="code" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a>( &amp;sz_date[10] , 2 );
<a name="l01371"></a>01371    msb_time |= (u8_tmp &gt;&gt; 3); 
<a name="l01372"></a>01372    lsb_time  = (u8_tmp &lt;&lt; 5);
<a name="l01373"></a>01373 
<a name="l01374"></a>01374    <span class="comment">// Set the seconde</span>
<a name="l01375"></a>01375    u8_tmp    = (U8)<a class="code" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a>( &amp;sz_date[12] , 2 );
<a name="l01376"></a>01376    lsb_time |= (u8_tmp &gt;&gt; 1);
<a name="l01377"></a>01377    
<a name="l01378"></a>01378    <span class="comment">// Set the miliseconde</span>
<a name="l01379"></a>01379    <span class="keywordflow">if</span>( enable_ms )
<a name="l01380"></a>01380    {
<a name="l01381"></a>01381       <span class="comment">// check if the seconde time is %2</span>
<a name="l01382"></a>01382       <span class="keywordflow">if</span>( u8_tmp &amp; 0x01 )
<a name="l01383"></a>01383       {  <span class="comment">// it isn't %2</span>
<a name="l01384"></a>01384          u8_tmp = 100;  <span class="comment">// add one seconde</span>
<a name="l01385"></a>01385       }
<a name="l01386"></a>01386       <span class="keywordflow">else</span>
<a name="l01387"></a>01387       {
<a name="l01388"></a>01388          u8_tmp = 0;    <span class="comment">// no more seconde</span>
<a name="l01389"></a>01389       }  
<a name="l01390"></a>01390       *ptr_date = u8_tmp + (U8)<a class="code" href="a00019.html#f138eb34db69daa5d51e33d130d85424">fat_translate_ascii_to_number</a>( &amp;sz_date[14] , 2 );
<a name="l01391"></a>01391       ptr_date++;
<a name="l01392"></a>01392    }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394    <span class="comment">// Record value</span>
<a name="l01395"></a>01395    ptr_date[0] = lsb_time; 
<a name="l01396"></a>01396    ptr_date[1] = msb_time; 
<a name="l01397"></a>01397    ptr_date[2] = lsb_date; 
<a name="l01398"></a>01398    ptr_date[3] = msb_date; 
<a name="l01399"></a>01399 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="015e44f70b92d8b39e00ababfdb6bc24"></a><!-- doxytag: member="fat_unusual.c::fat_translatedate_number_to_ascii" ref="015e44f70b92d8b39e00ababfdb6bc24" args="(FS_STRING sz_date, PTR_CACHE ptr_date, Bool enable_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fat_translatedate_number_to_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>sz_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a>&nbsp;</td>
          <td class="paramname"> <em>ptr_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction translate a date and time FAT value to ascii string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz_date</em>&nbsp;</td><td>table to store the information about date <br>
 storage format (ASCII) = "YYYYMMDDHHMMSSMS" = year, month, day, hour, minute, seconde, miliseconde </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr_date</em>&nbsp;</td><td>point in cache directory sector of the date to translate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enable_ms</em>&nbsp;</td><td>TRUE, translate the millisecond field </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00035.html#l01217">1217</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00035.html#l01290">fat_translate_number_to_ascii()</a>, and <a class="el" href="a00033.html#l00351">u8_i</a>.
<p>
Referenced by <a class="el" href="a00035.html#l01194">fat_get_date()</a>.<div class="fragment"><pre class="fragment"><a name="l01218"></a>01218 {
<a name="l01219"></a>01219    <a class="code" href="a00022.html#80aede4102ec34e739482902f716915a">FS_STRING</a> ptr_string_date;
<a name="l01220"></a>01220    U8 <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a>;
<a name="l01221"></a>01221    U8 msb_date, lsb_date, msb_time, lsb_time, u8_ms = 0;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223    <span class="comment">// Read entry value of date and time</span>
<a name="l01224"></a>01224    <span class="keywordflow">if</span>( enable_ms )
<a name="l01225"></a>01225    {
<a name="l01226"></a>01226       u8_ms = *ptr_date;
<a name="l01227"></a>01227       ptr_date++;
<a name="l01228"></a>01228    }
<a name="l01229"></a>01229    lsb_time = *ptr_date;
<a name="l01230"></a>01230    ptr_date++;
<a name="l01231"></a>01231    msb_time = *ptr_date;
<a name="l01232"></a>01232    ptr_date++;
<a name="l01233"></a>01233    lsb_date = *ptr_date;
<a name="l01234"></a>01234    ptr_date++;
<a name="l01235"></a>01235    msb_date = *ptr_date;
<a name="l01236"></a>01236 
<a name="l01237"></a>01237    <span class="comment">// Initialise the string with "1980000000000000" (Year = 1980 and other at 0)</span>
<a name="l01238"></a>01238    ptr_string_date = sz_date;
<a name="l01239"></a>01239    *ptr_string_date = <span class="charliteral">'1'</span>;
<a name="l01240"></a>01240    ptr_string_date++;
<a name="l01241"></a>01241    *ptr_string_date = <span class="charliteral">'9'</span>;
<a name="l01242"></a>01242    ptr_string_date++;
<a name="l01243"></a>01243    *ptr_string_date = <span class="charliteral">'8'</span>;
<a name="l01244"></a>01244    ptr_string_date++;
<a name="l01245"></a>01245    <span class="keywordflow">for</span>( u8_i=(15-2) ; u8_i!=0 ; u8_i-- )
<a name="l01246"></a>01246    {
<a name="l01247"></a>01247       *ptr_string_date = <span class="charliteral">'0'</span>;
<a name="l01248"></a>01248       ptr_string_date++;
<a name="l01249"></a>01249    }
<a name="l01250"></a>01250 
<a name="l01251"></a>01251    <span class="comment">// Get the year</span>
<a name="l01252"></a>01252    <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( sz_date, 4 , msb_date&gt;&gt;1 );
<a name="l01253"></a>01253 
<a name="l01254"></a>01254    <span class="comment">// Get the month</span>
<a name="l01255"></a>01255    <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( &amp;sz_date[4] , 2 , ((msb_date &amp; 0x01)&lt;&lt;3) + (lsb_date&gt;&gt;5) );
<a name="l01256"></a>01256 
<a name="l01257"></a>01257    <span class="comment">// Get the day</span>
<a name="l01258"></a>01258    <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( &amp;sz_date[6] , 2 , lsb_date &amp; 0x1F );
<a name="l01259"></a>01259 
<a name="l01260"></a>01260    <span class="comment">// Get the hour</span>
<a name="l01261"></a>01261    <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( &amp;sz_date[8] , 2 , msb_time &gt;&gt; (11-8) );
<a name="l01262"></a>01262 
<a name="l01263"></a>01263    <span class="comment">// Get the minute</span>
<a name="l01264"></a>01264    <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( &amp;sz_date[10] , 2 , ((msb_time &amp; 0x07)&lt;&lt;3) + (lsb_time&gt;&gt;5) );
<a name="l01265"></a>01265 
<a name="l01266"></a>01266    <span class="comment">// Get the seconde</span>
<a name="l01267"></a>01267    <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( &amp;sz_date[12] , 2 , (lsb_time &amp; 0x1F)&lt;&lt;1 );
<a name="l01268"></a>01268    <span class="keywordflow">if</span>( 99 &lt; u8_ms )
<a name="l01269"></a>01269    {
<a name="l01270"></a>01270      <span class="comment">// Add one seconde</span>
<a name="l01271"></a>01271      <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( &amp;sz_date[12] , 2 , 1 );
<a name="l01272"></a>01272      u8_ms -= 100;
<a name="l01273"></a>01273    }
<a name="l01274"></a>01274 
<a name="l01275"></a>01275    <span class="comment">// Get the miliseconde</span>
<a name="l01276"></a>01276    <a class="code" href="a00019.html#1a3ce899100c1b2a7798140852d9f22b">fat_translate_number_to_ascii</a>( &amp;sz_date[14] , 2 , u8_ms );
<a name="l01277"></a>01277 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8145cff91620fc1b70aa0eef5750db72"></a><!-- doxytag: member="fat_unusual.c::fat_update_fat2" ref="8145cff91620fc1b70aa0eef5750db72" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_update_fat2           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction copy the modification of first FAT to second FAT. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l02283">2283</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00383">fs_g_u16_first_mod_fat</a>, <a class="el" href="a00034.html#l00384">fs_g_u16_last_mod_fat</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00034.html#l00265">Fs_management::u16_fat_size</a>, and <a class="el" href="a00034.html#l00267">Fs_management::u32_ptr_fat</a>.
<p>
Referenced by <a class="el" href="a00033.html#l00374">fat_cluster_list()</a>.<div class="fragment"><pre class="fragment"><a name="l02284"></a>02284 {
<a name="l02285"></a>02285   <span class="comment">// Computed logical sector address</span>
<a name="l02286"></a>02286   <span class="keywordflow">while</span>( <a class="code" href="a00018.html#b55b94c50b63cf8b83e2afcf2e0c2981">fs_g_u16_first_mod_fat</a> &lt;= <a class="code" href="a00018.html#e8c6fce6d75eb9ddbf1e63e46659e9cc">fs_g_u16_last_mod_fat</a> )
<a name="l02287"></a>02287   {
<a name="l02288"></a>02288      <span class="comment">// Compute the position about modification of FAT 1</span>
<a name="l02289"></a>02289      <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> + <a class="code" href="a00018.html#b55b94c50b63cf8b83e2afcf2e0c2981">fs_g_u16_first_mod_fat</a>;
<a name="l02290"></a>02290      <span class="comment">// Read FAT1</span>
<a name="l02291"></a>02291       <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( TRUE ))
<a name="l02292"></a>02292          <span class="keywordflow">return</span> FALSE;
<a name="l02293"></a>02293      <span class="comment">// Compute the position about modification of FAT 2</span>
<a name="l02294"></a>02294      <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> + ((U32)<a class="code" href="a00018.html#b55b94c50b63cf8b83e2afcf2e0c2981">fs_g_u16_first_mod_fat</a> + <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>);
<a name="l02295"></a>02295      <span class="comment">// Init the sector FAT2 with the previous sector of the FAT1</span>
<a name="l02296"></a>02296      <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l02297"></a>02297          <span class="keywordflow">return</span> FALSE;
<a name="l02298"></a>02298      <span class="comment">// Flag, The sector FAT2 is modify</span>
<a name="l02299"></a>02299      <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l02300"></a>02300      <a class="code" href="a00018.html#b55b94c50b63cf8b83e2afcf2e0c2981">fs_g_u16_first_mod_fat</a>++;
<a name="l02301"></a>02301   }
<a name="l02302"></a>02302   <span class="keywordflow">return</span> TRUE;
<a name="l02303"></a>02303 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9cf154ffe36bc2c00b1d589e523b449c"></a><!-- doxytag: member="fat_unusual.c::fat_write_fat32_FSInfo" ref="9cf154ffe36bc2c00b1d589e523b449c" args="(U32 u32_nb_free_cluster)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_write_fat32_FSInfo           </td>
          <td>(</td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>u32_nb_free_cluster</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction write the space free number in drive partition FAT32 selected. 
<p>
Read global value "fs_g_status" in case of error : FS_ERR_HW Hardware driver error FS_ERR_HW_NO_PRESENT Device not present FS_LUN_WP Drive is read only<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l00840">840</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01790">fat_cache_clear()</a>, <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00034.html#l00146">FS_BR_SIGNATURE_HIGH</a>, <a class="el" href="a00034.html#l00145">FS_BR_SIGNATURE_LOW</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, and <a class="el" href="a00034.html#l00267">Fs_management::u32_ptr_fat</a>.
<p>
Referenced by <a class="el" href="a00035.html#l02145">fat_allocfreespace()</a>, <a class="el" href="a00033.html#l00374">fat_cluster_list()</a>, <a class="el" href="a00035.html#l01986">fat_getfreespace()</a>, and <a class="el" href="a00035.html#l00719">fat_write_PBR()</a>.<div class="fragment"><pre class="fragment"><a name="l00841"></a>00841 {
<a name="l00842"></a>00842    <span class="comment">// Init sector</span>
<a name="l00843"></a>00843    <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618">u32_ptr_fat</a> - 31;
<a name="l00844"></a>00844    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l00845"></a>00845       <span class="keywordflow">return</span> FALSE;
<a name="l00846"></a>00846    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l00847"></a>00847    <a class="code" href="a00017.html#5948c1de515852418670d3fb8ae1e832">fat_cache_clear</a>();
<a name="l00848"></a>00848    
<a name="l00849"></a>00849    <span class="comment">// Fill sector</span>
<a name="l00850"></a>00850    <span class="comment">// offset 00-04, This lead signature</span>
<a name="l00851"></a>00851    memcpy_code2ram( &amp;<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[0], <a class="code" href="a00019.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>) );
<a name="l00852"></a>00852    <span class="comment">// offset 004-483, reserved (fill with 0)</span>
<a name="l00853"></a>00853    <span class="comment">// offset 484-487, signature</span>
<a name="l00854"></a>00854    memcpy_code2ram( &amp;<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[484], <a class="code" href="a00019.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>) );
<a name="l00855"></a>00855    <span class="comment">// offset 488-491, free cluster count (by default NO value)</span>
<a name="l00856"></a>00856    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[488] = LSB0(u32_nb_free_cluster);
<a name="l00857"></a>00857    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[489] = LSB1(u32_nb_free_cluster);
<a name="l00858"></a>00858    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[490] = LSB2(u32_nb_free_cluster);
<a name="l00859"></a>00859    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[491] = LSB3(u32_nb_free_cluster);
<a name="l00860"></a>00860    <span class="comment">// offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)</span>
<a name="l00861"></a>00861    memset( &amp;<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[492] , 0xFF , 4 );
<a name="l00862"></a>00862    <span class="comment">// offset 496-509, reserved (fill with 0)</span>
<a name="l00863"></a>00863    <span class="comment">// offset 510-511, Signature</span>
<a name="l00864"></a>00864    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[510] = <a class="code" href="a00018.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>;
<a name="l00865"></a>00865    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[511] = <a class="code" href="a00018.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>;
<a name="l00866"></a>00866    <span class="keywordflow">return</span> TRUE;
<a name="l00867"></a>00867 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9075855486dc53d38dd64e068b512027"></a><!-- doxytag: member="fat_unusual.c::fat_write_MBR" ref="9075855486dc53d38dd64e068b512027" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_write_MBR           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction write the MBR. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l00611">611</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01790">fat_cache_clear()</a>, <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00034.html#l00146">FS_BR_SIGNATURE_HIGH</a>, <a class="el" href="a00034.html#l00145">FS_BR_SIGNATURE_LOW</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00034.html#l00110">FS_MBR_OFFSET_PART_ENTRY</a>, <a class="el" href="a00034.html#l00166">FS_PART_TYPE_FAT12</a>, <a class="el" href="a00034.html#l00167">FS_PART_TYPE_FAT16_INF32M</a>, <a class="el" href="a00034.html#l00168">FS_PART_TYPE_FAT16_SUP32M</a>, <a class="el" href="a00034.html#l00170">FS_PART_TYPE_FAT32</a>, <a class="el" href="a00034.html#l00165">FS_PARTITION_ACTIVE</a>, <a class="el" href="a00035.html#l00313">fs_s_u32_size_partition</a>, <a class="el" href="a00034.html#l00206">FS_SIZE_OF_SECTOR</a>, <a class="el" href="a00034.html#l00077">Is_fat12</a>, <a class="el" href="a00034.html#l00082">Is_fat16</a>, <a class="el" href="a00034.html#l00087">Is_fat32</a>, and <a class="el" href="a00033.html#l00351">u8_i</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00335">fat_format()</a>.<div class="fragment"><pre class="fragment"><a name="l00612"></a>00612 {
<a name="l00613"></a>00613    U8 <a class="code" href="a00017.html#5985f32ca0a3714cb4b55abf404be10c">u8_i</a> = 0;
<a name="l00614"></a>00614         
<a name="l00615"></a>00615    <span class="comment">// Init and reset the cache at the beginning of memory</span>
<a name="l00616"></a>00616    <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = 0;
<a name="l00617"></a>00617    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l00618"></a>00618       <span class="keywordflow">return</span> FALSE;
<a name="l00619"></a>00619    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l00620"></a>00620    <a class="code" href="a00017.html#5948c1de515852418670d3fb8ae1e832">fat_cache_clear</a>();
<a name="l00621"></a>00621    
<a name="l00622"></a>00622    <span class="comment">// MBR signature</span>
<a name="l00623"></a>00623    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[510] = <a class="code" href="a00018.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>;
<a name="l00624"></a>00624    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[511] = <a class="code" href="a00018.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626    <span class="comment">// Write the partition entry in the MBR</span>
<a name="l00627"></a>00627    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0) +0] = <a class="code" href="a00018.html#450f174270801d9b3e2d66854b607148">FS_PARTITION_ACTIVE</a>;   <span class="comment">// Active partition</span>
<a name="l00628"></a>00628    <span class="comment">// Remark: cylinder and header start to 0, and sector value start to 1</span>
<a name="l00629"></a>00629    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0) +1] = 0;                   // The head (0) where the partition starts</span>
<a name="l00630"></a>00630    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0) +2] = 2;                     <span class="comment">// The sector (2=next to MBR) and the cylinder (0) where the partition starts</span>
<a name="l00631"></a>00631    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0) +3] = 0;</span>
<a name="l00632"></a>00632    
<a name="l00633"></a>00633    <span class="comment">// Write patition type</span>
<a name="l00634"></a>00634    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00635"></a>00635    {  <span class="comment">// FAT 32</span>
<a name="l00636"></a>00636       u8_i = <a class="code" href="a00018.html#93881dd293ba41286e413bef3212786a">FS_PART_TYPE_FAT32</a>;
<a name="l00637"></a>00637    }
<a name="l00638"></a>00638    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l00639"></a>00639    {  <span class="comment">// FAT 16</span>
<a name="l00640"></a>00640       <span class="keywordflow">if</span>( <a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> &lt; (32L*1024*(1024/<a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a>)) )
<a name="l00641"></a>00641       {  <span class="comment">// Disk inferieur to 32MB</span>
<a name="l00642"></a>00642          u8_i = <a class="code" href="a00018.html#b9f13193999f7bb7ea0e4be6cf5ee57b">FS_PART_TYPE_FAT16_INF32M</a>;
<a name="l00643"></a>00643       }<span class="keywordflow">else</span>{
<a name="l00644"></a>00644          u8_i = <a class="code" href="a00018.html#29856400974fc942f9cf900a44ea7389">FS_PART_TYPE_FAT16_SUP32M</a>;
<a name="l00645"></a>00645       }
<a name="l00646"></a>00646    }
<a name="l00647"></a>00647    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l00648"></a>00648    {  <span class="comment">// FAT 12</span>
<a name="l00649"></a>00649       u8_i = <a class="code" href="a00018.html#d8702ceb3912c09278602d3ea33224ff">FS_PART_TYPE_FAT12</a>;
<a name="l00650"></a>00650    }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0) +4] = u8_i;
<a name="l00653"></a>00653    
<a name="l00654"></a>00654    <span class="comment">// Specific compute</span>
<a name="l00655"></a>00655    <span class="comment">// The head where the partitions ends</span>
<a name="l00656"></a>00656    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0) +5] = (LSB1(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&lt;&lt;2) + (LSB0(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&gt;&gt;6);
<a name="l00657"></a>00657    <span class="comment">// The sector and the cylinder where the partition ends</span>
<a name="l00658"></a>00658    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0) +6] = (LSB1(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&amp;0xC0) + (LSB0(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&amp;0x3F);
<a name="l00659"></a>00659    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0) +7] = LSB2(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00660"></a>00660    
<a name="l00661"></a>00661    <span class="comment">// Write partition position (in sectors) at offset 8</span>
<a name="l00662"></a>00662    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0)+ 8] = 0x01;
<a name="l00663"></a>00663    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0)+ 9] = 0x00;</span>
<a name="l00664"></a>00664    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0)+10] = 0x00;</span>
<a name="l00665"></a>00665    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0)+11] = 0x00;</span>
<a name="l00666"></a>00666    <span class="comment">// Write the number of sector in partion (= size - one sector MBR = last LBA, return by read_capacity)</span>
<a name="l00667"></a>00667    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0)+12] = LSB0(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00668"></a>00668    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0)+13] = LSB1(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00669"></a>00669    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0)+14] = LSB2(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00670"></a>00670    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[<a class="code" href="a00018.html#70b90ba913c43a878e9b478de5d1b61c">FS_MBR_OFFSET_PART_ENTRY</a>(0)+15] = LSB3(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672    <span class="keywordflow">return</span> TRUE;
<a name="l00673"></a>00673 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="89d56497bd58d7d6553b7e319f3ee863"></a><!-- doxytag: member="fat_unusual.c::fat_write_PBR" ref="89d56497bd58d7d6553b7e319f3ee863" args="(Bool b_MBR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool fat_write_PBR           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>b_MBR</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This fonction write the PBR. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b_MBR</em>&nbsp;</td><td>TRUE, include a MBR on disk</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>FALSE in case of error, see global value "fs_g_status" for more detail <p>
TRUE otherwise </dd></dl>

<p>
Definition at line <a class="el" href="a00035.html#l00719">719</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
References <a class="el" href="a00033.html#l01790">fat_cache_clear()</a>, <a class="el" href="a00033.html#l01742">fat_cache_read_sector()</a>, <a class="el" href="a00033.html#l01798">fat_cache_sector_is_modify()</a>, <a class="el" href="a00035.html#l00840">fat_write_fat32_FSInfo()</a>, <a class="el" href="a00034.html#l00146">FS_BR_SIGNATURE_HIGH</a>, <a class="el" href="a00034.html#l00145">FS_BR_SIGNATURE_LOW</a>, <a class="el" href="a00034.html#l00369">fs_g_nav</a>, <a class="el" href="a00034.html#l00390">fs_g_sector</a>, <a class="el" href="a00034.html#l00396">fs_gu32_addrsector</a>, <a class="el" href="a00035.html#l00313">fs_s_u32_size_partition</a>, <a class="el" href="a00034.html#l00122">HIGH_16_BPB_FATSz16</a>, <a class="el" href="a00034.html#l00077">Is_fat12</a>, <a class="el" href="a00034.html#l00087">Is_fat32</a>, <a class="el" href="a00034.html#l00123">LOW0_32_BPB_FATSz32</a>, <a class="el" href="a00034.html#l00124">LOW1_32_BPB_FATSz32</a>, <a class="el" href="a00034.html#l00121">LOW_16_BPB_FATSz16</a>, <a class="el" href="a00034.html#l00265">Fs_management::u16_fat_size</a>, and <a class="el" href="a00034.html#l00263">Fs_management::u8_BPB_SecPerClus</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00335">fat_format()</a>.<div class="fragment"><pre class="fragment"><a name="l00720"></a>00720 {
<a name="l00721"></a>00721    U16 u16_tmp;
<a name="l00722"></a>00722    
<a name="l00723"></a>00723    <span class="comment">//** Init the cache sector with PBR</span>
<a name="l00724"></a>00724    <span class="keywordflow">if</span>( b_MBR )
<a name="l00725"></a>00725       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = 1;
<a name="l00726"></a>00726    <span class="keywordflow">else</span>
<a name="l00727"></a>00727       <a class="code" href="a00018.html#8e617688fc42b47e56cce053123fd05f">fs_gu32_addrsector</a> = 0;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729    <span class="keywordflow">if</span>( !<a class="code" href="a00017.html#a67dc439478853cefdd226f9c99c9539">fat_cache_read_sector</a>( FALSE ))
<a name="l00730"></a>00730       <span class="keywordflow">return</span> FALSE;
<a name="l00731"></a>00731    <a class="code" href="a00017.html#e73cb496ddbf1ab33944f99f1c50f4d0">fat_cache_sector_is_modify</a>();
<a name="l00732"></a>00732    <a class="code" href="a00017.html#5948c1de515852418670d3fb8ae1e832">fat_cache_clear</a>();
<a name="l00733"></a>00733   
<a name="l00734"></a>00734    <span class="comment">//** WRITE CONSTANTE &amp; VARIABLE FOR FAT and FAT32</span>
<a name="l00735"></a>00735    memcpy_code2ram( <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>, <a class="code" href="a00019.html#6b6070b3785c1dcfd6b94c639a1039c3">const_header_pbr</a> , <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#6b6070b3785c1dcfd6b94c639a1039c3">const_header_pbr</a>) );
<a name="l00736"></a>00736    <span class="comment">// PBR signature</span>
<a name="l00737"></a>00737    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[510] = <a class="code" href="a00018.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>;
<a name="l00738"></a>00738    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[511] = <a class="code" href="a00018.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740    <span class="comment">// offset 13-13, Add sector by cluster</span>
<a name="l00741"></a>00741    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[13] = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e">u8_BPB_SecPerClus</a>;
<a name="l00742"></a>00742    <span class="comment">// offset 26-27, Number of header</span>
<a name="l00743"></a>00743    <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[26] = (LSB1(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&lt;&lt;2) + (LSB0(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&gt;&gt;6);
<a name="l00744"></a>00744   
<a name="l00745"></a>00745    <span class="comment">//** WRITE CONSTANTE &amp; VARIABLE DEPENDING OF FAT16 and FAT32</span>
<a name="l00746"></a>00746    <span class="comment">// Since offset 36, there are a different structure space for FAT16 and FAT32</span>
<a name="l00747"></a>00747    <span class="comment">// offset 39-42 or 67-70, Volume ID not used</span>
<a name="l00748"></a>00748    <span class="comment">// offset 43-53 or 71-81, Volume Label</span>
<a name="l00749"></a>00749    <span class="comment">// offset 54-61 or 82-89, File system type</span>
<a name="l00750"></a>00750    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00751"></a>00751    {
<a name="l00752"></a>00752       memcpy_code2ram( &amp;<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[64], <a class="code" href="a00019.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>) );
<a name="l00753"></a>00753    }<span class="keywordflow">else</span>{
<a name="l00754"></a>00754       memcpy_code2ram( &amp;<a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[36], <a class="code" href="a00019.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00019.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>) );
<a name="l00755"></a>00755    }
<a name="l00756"></a>00756    
<a name="l00757"></a>00757    u16_tmp = <a class="code" href="a00018.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d">u16_fat_size</a>;    <span class="comment">// save value in fast data space for optimization code</span>
<a name="l00758"></a>00758    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00759"></a>00759    {
<a name="l00760"></a>00760       <span class="comment">// offset 14-15, Add Number of reserved sector, FAT32 = 32 sectors</span>
<a name="l00761"></a>00761       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[14] = 32;
<a name="l00762"></a>00762       <span class="comment">// offset 17-18, Add Number of root entry, FAT32 = 0 entry</span>
<a name="l00763"></a>00763       <span class="comment">// offset 36-39, Fat size 32bits</span>
<a name="l00764"></a>00764       <a class="code" href="a00018.html#c1ba95f06dfaaf3c71a5eb12dd56009c">LOW0_32_BPB_FATSz32</a> = LSB(u16_tmp);
<a name="l00765"></a>00765       <a class="code" href="a00018.html#dff814b0d106b4c3b3f730fbef8338ce">LOW1_32_BPB_FATSz32</a> = MSB(u16_tmp); 
<a name="l00766"></a>00766       <span class="comment">// offset 40-41, Ext flags (all FAT are enabled = 0)</span>
<a name="l00767"></a>00767       <span class="comment">// offset 42-43, Fs version (version0:0 = 0)</span>
<a name="l00768"></a>00768       <span class="comment">// offset 44-47, Root Cluster (first free cluster = 2)</span>
<a name="l00769"></a>00769       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[44]= 2;
<a name="l00770"></a>00770       <span class="comment">// offset 48-49, Fs Info (usualy 1)</span>
<a name="l00771"></a>00771       <span class="comment">// fs_g_sector[48]= 0;</span>
<a name="l00772"></a>00772       <span class="comment">// offset 50-51, Backup Boot Sector (usualy 6)</span>
<a name="l00773"></a>00773       <span class="comment">// fs_g_sector[50]= 0;</span>
<a name="l00774"></a>00774       <span class="comment">// offset 52-63, reserved space</span>
<a name="l00775"></a>00775       <span class="comment">// offset 54-61, File system type</span>
<a name="l00776"></a>00776       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[85]=<span class="charliteral">'3'</span>;
<a name="l00777"></a>00777       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[86]=<span class="charliteral">'2'</span>;
<a name="l00778"></a>00778    }
<a name="l00779"></a>00779    <span class="keywordflow">else</span>
<a name="l00780"></a>00780    {
<a name="l00781"></a>00781       <span class="comment">// FAT 12 or 16</span>
<a name="l00782"></a>00782       <span class="comment">// offset 14-15, Add Number of reserved sector, FAT = 1 sector</span>
<a name="l00783"></a>00783       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[14] = 1;
<a name="l00784"></a>00784       <span class="comment">// offset 17-18, Add Number of root entry, FAT = 512 entrys</span>
<a name="l00785"></a>00785       <span class="comment">//fs_g_sector[17] = 512&amp;0xFF;</span>
<a name="l00786"></a>00786       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[18] = 512&gt;&gt;8;
<a name="l00787"></a>00787 
<a name="l00788"></a>00788       <span class="comment">// offset 22-23, Fat size 16bits</span>
<a name="l00789"></a>00789       <a class="code" href="a00018.html#fe57e984b2baf3970ac7feda02355ac9">LOW_16_BPB_FATSz16</a>  = LSB(u16_tmp);
<a name="l00790"></a>00790       <a class="code" href="a00018.html#c7277af1ce6ee4efe860da2d1f3b1b38">HIGH_16_BPB_FATSz16</a> = MSB(u16_tmp); 
<a name="l00791"></a>00791       <span class="comment">// offset 54-61, File system type</span>
<a name="l00792"></a>00792       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[57]=<span class="charliteral">'1'</span>;
<a name="l00793"></a>00793       <span class="keywordflow">if</span>( <a class="code" href="a00018.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l00794"></a>00794       {
<a name="l00795"></a>00795          <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[58]=<span class="charliteral">'2'</span>;
<a name="l00796"></a>00796       }<span class="keywordflow">else</span>{
<a name="l00797"></a>00797          <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[58]=<span class="charliteral">'6'</span>;
<a name="l00798"></a>00798       }
<a name="l00799"></a>00799    }
<a name="l00800"></a>00800     
<a name="l00801"></a>00801    <span class="comment">// Write the number of sector in partion (= size - one sector MBR = last LBA, return by read_capacity)</span>
<a name="l00802"></a>00802    <span class="keywordflow">if</span>( ( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00803"></a>00803    ||  ((0x10000-1) &lt;= <a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>) )
<a name="l00804"></a>00804    {
<a name="l00805"></a>00805       <span class="comment">// FAT32 or disk &gt; 32MB</span>
<a name="l00806"></a>00806       <span class="comment">// offset 32-35, Number of sector in partition (value 32 bits)</span>
<a name="l00807"></a>00807       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[32] = LSB0(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00808"></a>00808       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[33] = LSB1(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00809"></a>00809       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[34] = LSB2(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00810"></a>00810       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[35] = LSB3(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00811"></a>00811    }
<a name="l00812"></a>00812    <span class="keywordflow">else</span>
<a name="l00813"></a>00813    {
<a name="l00814"></a>00814       <span class="comment">// offset 19-20, Number of sector in partition (value 16 bits)</span>
<a name="l00815"></a>00815       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[19] = LSB0(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00816"></a>00816       <a class="code" href="a00018.html#e8fff3e358b2628449a988ca5256f7e6">fs_g_sector</a>[20] = LSB1(<a class="code" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00817"></a>00817    }
<a name="l00818"></a>00818       
<a name="l00819"></a>00819    <span class="keywordflow">if</span>( <a class="code" href="a00018.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00820"></a>00820    {
<a name="l00821"></a>00821       <span class="comment">// Init the FAT32 FSInfo Sector</span>
<a name="l00822"></a>00822       <span class="keywordflow">if</span>( !<a class="code" href="a00018.html#9cf154ffe36bc2c00b1d589e523b449c">fat_write_fat32_FSInfo</a>( 0xFFFFFFFF ))
<a name="l00823"></a>00823          <span class="keywordflow">return</span> FALSE;
<a name="l00824"></a>00824    }
<a name="l00825"></a>00825    <span class="keywordflow">return</span> TRUE;
<a name="l00826"></a>00826 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="0ab271becae152fb0b33ad5eb33ec22b"></a><!-- doxytag: member="fat_unusual.c::const_FSI_LeadSig" ref="0ab271becae152fb0b33ad5eb33ec22b" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   0x52,0x52,0x61,0x41                                
}
</pre></div>
<p>
Definition at line <a class="el" href="a00035.html#l00703">703</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="71e0de07d391ec4f20a8a1bb4b446f90"></a><!-- doxytag: member="fat_unusual.c::const_FSI_StrucSig" ref="71e0de07d391ec4f20a8a1bb4b446f90" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   0x72,0x72,0x41,0x61                                
}
</pre></div>
<p>
Definition at line <a class="el" href="a00035.html#l00706">706</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="d7b8480b30e94480383a615e9304dee1"></a><!-- doxytag: member="fat_unusual.c::const_header_fat12" ref="d7b8480b30e94480383a615e9304dee1" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#d7b8480b30e94480383a615e9304dee1">const_header_fat12</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   0xF8,0xFF,0xFF                            
   }
</pre></div>
<p>
Definition at line <a class="el" href="a00035.html#l00961">961</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="96762bd73caa7d1fdc8c92db0b777f1a"></a><!-- doxytag: member="fat_unusual.c::const_header_fat16" ref="96762bd73caa7d1fdc8c92db0b777f1a" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#96762bd73caa7d1fdc8c92db0b777f1a">const_header_fat16</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   0xF8,0xFF,0xFF,0xFF                       
   }
</pre></div>
<p>
Definition at line <a class="el" href="a00035.html#l00964">964</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="94831debe0600f19945c3239dc3634e7"></a><!-- doxytag: member="fat_unusual.c::const_header_fat32" ref="94831debe0600f19945c3239dc3634e7" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#94831debe0600f19945c3239dc3634e7">const_header_fat32</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   0xF8,0xFF,0xFF,0x0F,0xFF,0xFF,0xFF,0x0F   
  ,0xFF,0xFF,0xFF,0x0F                       
   }
</pre></div>
<p>
Definition at line <a class="el" href="a00035.html#l00967">967</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="6b6070b3785c1dcfd6b94c639a1039c3"></a><!-- doxytag: member="fat_unusual.c::const_header_pbr" ref="6b6070b3785c1dcfd6b94c639a1039c3" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#6b6070b3785c1dcfd6b94c639a1039c3">const_header_pbr</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   0xEB,0,0x90,                                       
   <span class="charliteral">'M'</span>,<span class="charliteral">'S'</span>,<span class="charliteral">'W'</span>,<span class="charliteral">'I'</span>,<span class="charliteral">'N'</span>,<span class="charliteral">'4'</span>,<span class="charliteral">'.'</span>,<span class="charliteral">'1'</span>,                   
   <a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a> &amp; 0xFF, <a class="code" href="a00018.html#3d8dbd6dd4c5150d859e8926f69e88b9">FS_SIZE_OF_SECTOR</a> &gt;&gt;8,   
   0,                                                 
   0,0,                                               
   2,                                                 
   0,0,                                               
   0,0,
   <a class="code" href="a00018.html#3222ba68ea2f6dc67aa88a0caeb7e6e4">FS_PART_NO_REMOVE_MEDIA</a>,                           
   0,0,
   0x3F,0,                                            
   0,0,                                               
   1                                                  
   }
</pre></div>Constante for <a class="el" href="a00019.html#89d56497bd58d7d6553b7e319f3ee863">fat_write_PBR()</a> routine. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l00676">676</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="0a7f54c3ba9425b8a19d431732e98391"></a><!-- doxytag: member="fat_unusual.c::const_tail_pbr" ref="0a7f54c3ba9425b8a19d431732e98391" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {           
   <a class="code" href="a00018.html#3eecd129a66f4de0d5cd023f2f925e1e">FS_PART_HARD_DISK</a>,                                 
   0,                                                 
   <a class="code" href="a00018.html#8b3d7dc9ad174dc5273cc5cb052598f1">FS_BOOT_SIGN</a>,                                      
   0,0,0,0,                                           
   <span class="charliteral">'N'</span>,<span class="charliteral">'O'</span>,<span class="charliteral">' '</span>,<span class="charliteral">'N'</span>,<span class="charliteral">'A'</span>,<span class="charliteral">'M'</span>,<span class="charliteral">'E'</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,       
   <span class="charliteral">'F'</span>,<span class="charliteral">'A'</span>,<span class="charliteral">'T'</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,                   
   }
</pre></div>
<p>
Definition at line <a class="el" href="a00035.html#l00691">691</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="89cf8e55b9308a287d4f24c28f8278ed"></a><!-- doxytag: member="fat_unusual.c::fs_s_execption_char" ref="89cf8e55b9308a287d4f24c28f8278ed" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#89cf8e55b9308a287d4f24c28f8278ed">fs_s_execption_char</a>[] = {'+',',','.',';','=','[',']'}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Table of character no supported in short name. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l01833">1833</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="6584c61d6d4c16ebe9f92c92a53e96bf"></a><!-- doxytag: member="fat_unusual.c::fs_s_tab_incorrect_char" ref="6584c61d6d4c16ebe9f92c92a53e96bf" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ U8 <a class="el" href="a00019.html#6584c61d6d4c16ebe9f92c92a53e96bf">fs_s_tab_incorrect_char</a>[] = {':','*','?','&quot;','&lt;','&gt;','|'}          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Table of characters no supported in a name. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l01788">1788</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
</div>
</div><p>
<a class="anchor" name="045dd8cfc387ec4ecf5c278bd239a5cf"></a><!-- doxytag: member="fat_unusual.c::fs_s_u32_size_partition" ref="045dd8cfc387ec4ecf5c278bd239a5cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_MEM_TYPE_SLOW_ U32 <a class="el" href="a00019.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global variable to optimize the code of format routines. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l00313">313</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00335">fat_format()</a>, <a class="el" href="a00035.html#l00477">fat_select_filesystem()</a>, <a class="el" href="a00035.html#l00611">fat_write_MBR()</a>, and <a class="el" href="a00035.html#l00719">fat_write_PBR()</a>.
</div>
</div><p>
<a class="anchor" name="12c9e9d2a4cbd29f35072cccecc0f0d5"></a><!-- doxytag: member="fat_unusual.c::TableFAT12" ref="12c9e9d2a4cbd29f35072cccecc0f0d5" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ <a class="el" href="a00011.html">Fs_format_table</a> <a class="el" href="a00019.html#12c9e9d2a4cbd29f35072cccecc0f0d5">TableFAT12</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   {  4096, 1},      
   {  8192, 2},      
   { 16384, 4},      
   { 32680, 8},      
}
</pre></div>Table format for FAT12. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l00394">394</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00477">fat_select_filesystem()</a>.
</div>
</div><p>
<a class="anchor" name="e060256d5bbd91d6412e3601893935b4"></a><!-- doxytag: member="fat_unusual.c::TableFAT16" ref="e060256d5bbd91d6412e3601893935b4" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ <a class="el" href="a00011.html">Fs_format_table</a> <a class="el" href="a00019.html#e060256d5bbd91d6412e3601893935b4">TableFAT16</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   { 8400, 0},       
   { 32680, 2},      
   { 262144, 4},     
   { 524288, 8},     
   { 1048576, 16},   
   
   { 2097152, 32},   
   { 4194304, 64},   
   { 0xFFFFFFFF, 0}  
}
</pre></div>Table format for FAT16. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l00413">413</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00477">fat_select_filesystem()</a>.
</div>
</div><p>
<a class="anchor" name="c25415e8010641385456353f4c1c5eec"></a><!-- doxytag: member="fat_unusual.c::TableFAT32" ref="c25415e8010641385456353f4c1c5eec" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_CONST_TYPE_ <a class="el" href="a00011.html">Fs_format_table</a> <a class="el" href="a00019.html#c25415e8010641385456353f4c1c5eec">TableFAT32</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
   { 66600, 0},      
   { 532480, 1},     
   { 16777216, 8},   
   { 33554432, 16},  
   { 67108864, 32},  
   { 0xFFFFFFFF, 64} 
}
</pre></div>Table format for FAT32. 
<p>

<p>
Definition at line <a class="el" href="a00035.html#l00439">439</a> of file <a class="el" href="a00035.html">fat_unusual.c</a>.
<p>
Referenced by <a class="el" href="a00035.html#l00477">fat_select_filesystem()</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Sep 20 12:17:17 2007 for AVR32 UC3 - FSACCESS Services by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
