<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR32 - USB DFU Example: ISP: flashc.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>flashc.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
FLASHC driver for AVR32 UC3. 
<p>
AVR32 Flash Controller driver module.<p>
<ul>
<li>Compiler: IAR EWAVR32 and GNU GCC for AVR32</li><li>Supported devices: All AVR32 devices with a FLASHC module can be used.</li><li>AppNote:</li></ul>
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support and FAQ: <a href="http://support.atmel.no/">http://support.atmel.no/</a> </dd></dl>

<p>
Definition in file <a class="el" href="a00045.html">flashc.c</a>.
<p>
<code>#include &lt;avr32/io.h&gt;</code><br>
<code>#include &lt;stddef.h&gt;</code><br>
<code>#include &quot;compiler.h&quot;</code><br>
<code>#include &quot;<a class="el" href="a00046.html">flashc.h</a>&quot;</code><br>

<p>
<a href="a00045.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">u_avr32_flashc_fcmd_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">u_avr32_flashc_fcr_t</a></td></tr>

<tr><td colspan="2"><br><h2>FLASHC Status</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sticky error status of the FLASHC.  <a href="#f22dcfb635e7fa6bf926dc810e40d6be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void(*volatile)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#c293397096f61bb5c2400792f3b39c0f">flashc_wait_until_ready</a> (void) = flashc_default_wait_until_ready</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the function used by the driver when it needs to wait until the FLASHC is ready to run a new command.  <a href="#c293397096f61bb5c2400792f3b39c0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ca88002d64a494ca5b796b592834369d">flashc_default_wait_until_ready</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits actively until the FLASHC is ready to run a new command.  <a href="#ca88002d64a494ca5b796b592834369d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#e7d38c60001d5d8d00363a6cb07f89f0">flashc_get_error_status</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the error status of the FLASHC.  <a href="#e7d38c60001d5d8d00363a6cb07f89f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether a Lock Error has occurred during the last function called that issued one or more FLASHC commands.  <a href="#a5e4eb7ae688be5d59fca4bb6a326447"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether a Programming Error has occurred during the last function called that issued one or more FLASHC commands.  <a href="#2556a29213a1be8df40df2f8868077bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#c47ea338258641e6fe9361885a116c39">flashc_is_ready</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the FLASHC is ready to run a new command.  <a href="#c47ea338258641e6fe9361885a116c39"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Protection Mechanisms</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#245cc33e09bc45b78d4fdc189ba6fd85">flashc_activate_security_bit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activates the Security bit.  <a href="#245cc33e09bc45b78d4fdc189ba6fd85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#83ed88a41076163bd29ca80d30cb094f">flashc_get_bootloader_protected_size</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the bootloader protected size.  <a href="#83ed88a41076163bd29ca80d30cb094f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#64607cf8bb7de7e226973c7d9a10170d">flashc_is_external_privileged_fetch_locked</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether external privileged fetch is locked.  <a href="#64607cf8bb7de7e226973c7d9a10170d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#fa30fe317124244e8c5a7fcc7a0ba44b">flashc_is_page_region_locked</a> (int page_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the region of a page is locked.  <a href="#fa30fe317124244e8c5a7fcc7a0ba44b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#e6e9e45c046406a645ffac5e3fd62d40">flashc_is_region_locked</a> (unsigned int region)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether a region is locked.  <a href="#e6e9e45c046406a645ffac5e3fd62d40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#03df73f0be08f7bc503f3c336b1abdc1">flashc_is_security_bit_active</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Security bit is active.  <a href="#03df73f0be08f7bc503f3c336b1abdc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#7c05cca97169ee6888828c40243c0191">flashc_lock_all_regions</a> (Bool lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks all regions.  <a href="#7c05cca97169ee6888828c40243c0191"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#5b5725c807435b40115f4577a79b88b2">flashc_lock_external_privileged_fetch</a> (Bool lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks external privileged fetch.  <a href="#5b5725c807435b40115f4577a79b88b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a79c8c0023a4813a08cff039ccd003ab">flashc_lock_page_region</a> (int page_number, Bool lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks the region of a page.  <a href="#a79c8c0023a4813a08cff039ccd003ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#026f45da4ae8afea4d40066d3523ee3b">flashc_lock_region</a> (unsigned int region, Bool lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks a region.  <a href="#026f45da4ae8afea4d40066d3523ee3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#076a1b22c9f3e6dad1739f0398f89b37">flashc_set_bootloader_protected_size</a> (unsigned int bootprot_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bootloader protected size.  <a href="#076a1b22c9f3e6dad1739f0398f89b37"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to Flash Pages</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#83ce37dee77452f369b163d131885f3d">flashc_check_user_page_erase</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the User page is erased.  <a href="#83ce37dee77452f369b163d131885f3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ffafe9cb74731d817b721d2a52093412">flashc_clear_page_buffer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the page buffer.  <a href="#ffafe9cb74731d817b721d2a52093412"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#230f4c4dcf517606a540dfa1df3efa91">flashc_erase_all_pages</a> (Bool check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases all pages within the flash array.  <a href="#230f4c4dcf517606a540dfa1df3efa91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#8de3bbd50094f548ca293f07b136cc6d">flashc_erase_page</a> (int page_number, Bool check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a page.  <a href="#8de3bbd50094f548ca293f07b136cc6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#2ef66c5ffa0974223c44e151a8719b6d">flashc_erase_user_page</a> (Bool check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the User page.  <a href="#2ef66c5ffa0974223c44e151a8719b6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#cdea4bfb0cb1066fba239a9302196ee5">flashc_is_page_erased</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the page to which the last Quick Page Read command was applied was erased.  <a href="#cdea4bfb0cb1066fba239a9302196ee5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#b257e261b58cabbd30f176287882886e">flashc_memcpy</a> (volatile void *dst, const void *src, size_t nbytes, Bool erase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the source pointed to by <em>src</em>.  <a href="#b257e261b58cabbd30f176287882886e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#1e3ac5049d1eed492678764f8d1efc4b">flashc_memset16</a> (volatile void *dst, U16 src, size_t nbytes, Bool erase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source half-word.  <a href="#1e3ac5049d1eed492678764f8d1efc4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#f51102eac590a354c08f3b4311745674">flashc_memset32</a> (volatile void *dst, U32 src, size_t nbytes, Bool erase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source word.  <a href="#f51102eac590a354c08f3b4311745674"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#d232684f65e596ffd85a63e0c1a5c41d">flashc_memset64</a> (volatile void *dst, U64 src, size_t nbytes, Bool erase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source double-word.  <a href="#d232684f65e596ffd85a63e0c1a5c41d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#cc5c426d84ce1ef1d2e898e827b23207">flashc_memset8</a> (volatile void *dst, U8 src, size_t nbytes, Bool erase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> source byte.  <a href="#cc5c426d84ce1ef1d2e898e827b23207"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#cd50527aacf1d9ae11608fcc49a4fdcf">flashc_quick_page_read</a> (int page_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the Quick Page Read command to a page.  <a href="#cd50527aacf1d9ae11608fcc49a4fdcf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a10438433246139bee71da6db2bb5bd5">flashc_write_page</a> (int page_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a page from the page buffer.  <a href="#a10438433246139bee71da6db2bb5bd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#d04374b721dca9c534d7cd041ae24712">flashc_write_user_page</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the User page from the page buffer.  <a href="#d04374b721dca9c534d7cd041ae24712"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Control</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#da1616072a05bb5d85e4c64af8826757">flashc_enable_lock_error_int</a> (Bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the Lock Error interrupt.  <a href="#da1616072a05bb5d85e4c64af8826757"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#1ac3cdbea1169c7f292db30f7c7a48bc">flashc_enable_prog_error_int</a> (Bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the Programming Error interrupt.  <a href="#1ac3cdbea1169c7f292db30f7c7a48bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#11ae526262d08d12815ec74f503c63c0">flashc_enable_ready_int</a> (Bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the Flash Ready interrupt.  <a href="#11ae526262d08d12815ec74f503c63c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#52784dbdd246c6c320e5041026d4da08">flashc_get_wait_state</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of wait states of flash read accesses.  <a href="#52784dbdd246c6c320e5041026d4da08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#d9a950413a6b9d64a832b82ebaa2c38d">flashc_is_lock_error_int_enabled</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Lock Error interrupt is enabled.  <a href="#d9a950413a6b9d64a832b82ebaa2c38d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ec6b3818f1a6a0d4bf69838c2743de85">flashc_is_prog_error_int_enabled</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Programming Error interrupt is enabled.  <a href="#ec6b3818f1a6a0d4bf69838c2743de85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#517223d37600d347adc24fed238ebaf7">flashc_is_ready_int_enabled</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Flash Ready interrupt is enabled.  <a href="#517223d37600d347adc24fed238ebaf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#2835c7ef58f410290ad530d34d7e8133">flashc_set_wait_state</a> (unsigned int wait_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of wait states of flash read accesses.  <a href="#2835c7ef58f410290ad530d34d7e8133"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Global Commands</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#56f654a36c20b651412bbb689b8a4b2c">flashc_erase_all</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issues an Erase All command to the FLASHC.  <a href="#56f654a36c20b651412bbb689b8a4b2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac955da1ba0b0833d17d3068c34222ec">flashc_no_operation</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issues a No Operation command to the FLASHC.  <a href="#ac955da1ba0b0833d17d3068c34222ec"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to General-Purpose Fuses</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#cf3096dc9ecea92533c4688d7f90a0ef">flashc_erase_all_gp_fuses</a> (Bool check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases all general-purpose fuses.  <a href="#cf3096dc9ecea92533c4688d7f90a0ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#3d3494ba9bfe90893f65d2d3d90ab088">flashc_erase_gp_fuse_bit</a> (unsigned int gp_fuse_bit, Bool check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a general-purpose fuse bit.  <a href="#3d3494ba9bfe90893f65d2d3d90ab088"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#5e1c12e72c0d141bc13fed9fe6a7dd19">flashc_erase_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width, Bool check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a general-purpose fuse bit-field.  <a href="#5e1c12e72c0d141bc13fed9fe6a7dd19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#293468b5d263ffe7f9a2595c900a9293">flashc_erase_gp_fuse_byte</a> (unsigned int gp_fuse_byte, Bool check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a general-purpose fuse byte.  <a href="#293468b5d263ffe7f9a2595c900a9293"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#13ee637e6c10a7bba5d92172ff520a80">flashc_read_all_gp_fuses</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads all general-purpose fuses.  <a href="#13ee637e6c10a7bba5d92172ff520a80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#e6203d2e69ff15d59366c28bf8e26a7e">flashc_read_gp_fuse_bit</a> (unsigned int gp_fuse_bit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a general-purpose fuse bit.  <a href="#e6203d2e69ff15d59366c28bf8e26a7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#21af75e6beb4675f79c01a019ebc1a46">flashc_read_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a general-purpose fuse bit-field.  <a href="#21af75e6beb4675f79c01a019ebc1a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#1ad2aab294e528795bbd835539b0b14e">flashc_read_gp_fuse_byte</a> (unsigned int gp_fuse_byte)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a general-purpose fuse byte.  <a href="#1ad2aab294e528795bbd835539b0b14e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#33c3c1b69ddc1a03471d45cd5ecc2c64">flashc_set_all_gp_fuses</a> (U32 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all general-purpose fuses with the appropriate erase and write operations.  <a href="#33c3c1b69ddc1a03471d45cd5ecc2c64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#5c5442a988c608baea0d1c0b841badca">flashc_set_gp_fuse_bit</a> (unsigned int gp_fuse_bit, Bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a general-purpose fuse bit with the appropriate erase and write operations.  <a href="#5c5442a988c608baea0d1c0b841badca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#64e271d0e26dd92933889081ee551bbe">flashc_set_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width, U32 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a general-purpose fuse bit-field with the appropriate erase and write operations.  <a href="#64e271d0e26dd92933889081ee551bbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#cda1125f62193f69c24c0e4975e95b4d">flashc_set_gp_fuse_byte</a> (unsigned int gp_fuse_byte, U8 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a general-purpose fuse byte with the appropriate erase and write operations.  <a href="#cda1125f62193f69c24c0e4975e95b4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#09f466abd0984884a05c91e8ebb773f9">flashc_write_all_gp_fuses</a> (U32 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes all general-purpose fuses.  <a href="#09f466abd0984884a05c91e8ebb773f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#52f9456a7effcc28290c3139f7d54bfc">flashc_write_gp_fuse_bit</a> (unsigned int gp_fuse_bit, Bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a general-purpose fuse bit.  <a href="#52f9456a7effcc28290c3139f7d54bfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#af0b1e05809805510132d8e6eb761fdd">flashc_write_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width, U32 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a general-purpose fuse bit-field.  <a href="#af0b1e05809805510132d8e6eb761fdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#7670e69d41fe6a985ad898be25044caf">flashc_write_gp_fuse_byte</a> (unsigned int gp_fuse_byte, U8 value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a general-purpose fuse byte.  <a href="#7670e69d41fe6a985ad898be25044caf"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Command Control</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#36519235197ff4d6ab7f5adcb3fce6c1">flashc_get_command</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the last issued FLASHC command.  <a href="#36519235197ff4d6ab7f5adcb3fce6c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#db51a37e3153c24e5dd6cf06daac0e21">flashc_get_page_number</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current FLASHC page number.  <a href="#db51a37e3153c24e5dd6cf06daac0e21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a> (unsigned int command, int page_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issues a FLASHC command.  <a href="#8045c427c32cf3617e861067d76c9c11"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Flash Properties</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#8071c315b02d038c49fa0bf89a40ba1b">flashc_get_flash_size</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the whole flash array.  <a href="#8071c315b02d038c49fa0bf89a40ba1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the total number of pages in the flash array.  <a href="#afad0dcf645cc65acb5bc879558dac23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#8910bcde3235e2af0770fbd2412b05bc">flashc_get_page_count_per_region</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of pages in each flash region.  <a href="#8910bcde3235e2af0770fbd2412b05bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#c5871dc98c8812b0413efd6456508999">flashc_get_page_region</a> (int page_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the region number of a page.  <a href="#c5871dc98c8812b0413efd6456508999"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#43b14107d406ea9025f8947490c9ddcd">flashc_get_region_first_page_number</a> (unsigned int region)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of the first page of a region.  <a href="#43b14107d406ea9025f8947490c9ddcd"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="245cc33e09bc45b78d4fdc189ba6fd85"></a><!-- doxytag: member="flashc.c::flashc_activate_security_bit" ref="245cc33e09bc45b78d4fdc189ba6fd85" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_activate_security_bit           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Activates the Security bit. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00307">307</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00055.html#l00352">mem_security_write()</a>.<div class="fragment"><pre class="fragment"><a name="l00308"></a>00308 {
<a name="l00309"></a>00309   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_SSB, -1);
<a name="l00310"></a>00310 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="83ce37dee77452f369b163d131885f3d"></a><!-- doxytag: member="flashc.c::flashc_check_user_page_erase" ref="83ce37dee77452f369b163d131885f3d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_check_user_page_erase           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether the User page is erased. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the User page is erased. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00637">637</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00649">flashc_erase_user_page()</a>.<div class="fragment"><pre class="fragment"><a name="l00638"></a>00638 {
<a name="l00639"></a>00639   <span class="keyword">volatile</span> U64 *user_page_ptr = (U64 *)AVR32_FLASHC_USER_PAGE;
<a name="l00640"></a>00640   <span class="keywordflow">while</span> (user_page_ptr &lt; (U64 *)(AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))
<a name="l00641"></a>00641   {
<a name="l00642"></a>00642     <span class="keywordflow">if</span> (*user_page_ptr++ != 0xFFFFFFFFFFFFFFFFULL)
<a name="l00643"></a>00643       <span class="keywordflow">return</span> FALSE;
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645   <span class="keywordflow">return</span> TRUE;
<a name="l00646"></a>00646 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ffafe9cb74731d817b721d2a52093412"></a><!-- doxytag: member="flashc.c::flashc_clear_page_buffer" ref="ffafe9cb74731d817b721d2a52093412" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_clear_page_buffer           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the page buffer. 
<p>
This command resets all bits in the page buffer to one. Write accesses to the page buffer can only change page buffer bits from one to zero.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The page buffer is not automatically reset after a page write.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00583">583</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00870">flashc_memcpy()</a>, and <a class="el" href="a00045.html#l00680">flashc_memset64()</a>.<div class="fragment"><pre class="fragment"><a name="l00584"></a>00584 {
<a name="l00585"></a>00585   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_CPB, -1);
<a name="l00586"></a>00586 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ca88002d64a494ca5b796b592834369d"></a><!-- doxytag: member="flashc.c::flashc_default_wait_until_ready" ref="ca88002d64a494ca5b796b592834369d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_default_wait_until_ready           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits actively until the FLASHC is ready to run a new command. 
<p>
This is the default function assigned to <a class="el" href="a00021.html#c293397096f61bb5c2400792f3b39c0f">flashc_wait_until_ready</a>. 
<p>
Definition at line <a class="el" href="a00045.html#l00194">194</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00188">flashc_is_ready()</a>.<div class="fragment"><pre class="fragment"><a name="l00195"></a>00195 {
<a name="l00196"></a>00196   <span class="keywordflow">while</span> (!<a class="code" href="a00020.html#c47ea338258641e6fe9361885a116c39">flashc_is_ready</a>());
<a name="l00197"></a>00197 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="da1616072a05bb5d85e4c64af8826757"></a><!-- doxytag: member="flashc.c::flashc_enable_lock_error_int" ref="da1616072a05bb5d85e4c64af8826757" args="(Bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_enable_lock_error_int           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the Lock Error interrupt. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Whether to enable the Lock Error interrupt: <code>TRUE</code> or <code>FALSE</code>. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00045.html#l00158">158</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00058">u_avr32_flashc_fcr_t::FCR</a>, and <a class="el" href="a00045.html#l00057">u_avr32_flashc_fcr_t::fcr</a>.<div class="fragment"><pre class="fragment"><a name="l00159"></a>00159 {
<a name="l00160"></a>00160   <a class="code" href="a00015.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00161"></a>00161   u_avr32_flashc_fcr.<a class="code" href="a00015.html#a8f3a48553db579f2272c10a5ad2c710">FCR</a>.locke = (enable != FALSE);
<a name="l00162"></a>00162   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00015.html#4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00163"></a>00163 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1ac3cdbea1169c7f292db30f7c7a48bc"></a><!-- doxytag: member="flashc.c::flashc_enable_prog_error_int" ref="1ac3cdbea1169c7f292db30f7c7a48bc" args="(Bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_enable_prog_error_int           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the Programming Error interrupt. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Whether to enable the Programming Error interrupt: <code>TRUE</code> or <code>FALSE</code>. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00045.html#l00172">172</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00058">u_avr32_flashc_fcr_t::FCR</a>, and <a class="el" href="a00045.html#l00057">u_avr32_flashc_fcr_t::fcr</a>.<div class="fragment"><pre class="fragment"><a name="l00173"></a>00173 {
<a name="l00174"></a>00174   <a class="code" href="a00015.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00175"></a>00175   u_avr32_flashc_fcr.<a class="code" href="a00015.html#a8f3a48553db579f2272c10a5ad2c710">FCR</a>.proge = (enable != FALSE);
<a name="l00176"></a>00176   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00015.html#4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00177"></a>00177 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="11ae526262d08d12815ec74f503c63c0"></a><!-- doxytag: member="flashc.c::flashc_enable_ready_int" ref="11ae526262d08d12815ec74f503c63c0" args="(Bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_enable_ready_int           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the Flash Ready interrupt. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Whether to enable the Flash Ready interrupt: <code>TRUE</code> or <code>FALSE</code>. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00045.html#l00144">144</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00058">u_avr32_flashc_fcr_t::FCR</a>, and <a class="el" href="a00045.html#l00057">u_avr32_flashc_fcr_t::fcr</a>.<div class="fragment"><pre class="fragment"><a name="l00145"></a>00145 {
<a name="l00146"></a>00146   <a class="code" href="a00015.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00147"></a>00147   u_avr32_flashc_fcr.<a class="code" href="a00015.html#a8f3a48553db579f2272c10a5ad2c710">FCR</a>.frdy = (enable != FALSE);
<a name="l00148"></a>00148   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00015.html#4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00149"></a>00149 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="56f654a36c20b651412bbb689b8a4b2c"></a><!-- doxytag: member="flashc.c::flashc_erase_all" ref="56f654a36c20b651412bbb689b8a4b2c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_erase_all           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Issues an Erase All command to the FLASHC. 
<p>
This command erases all bits in the flash array, the general-purpose fuse bits and the Security bit. The User page is not erased.<p>
This command also ensures that all volatile memories, such as register file and RAMs, are erased before the Security bit is erased, i.e. deactivated.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if at least one region is locked or the bootloader protection is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00287">287</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.<div class="fragment"><pre class="fragment"><a name="l00288"></a>00288 {
<a name="l00289"></a>00289   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EA, -1);
<a name="l00290"></a>00290 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cf3096dc9ecea92533c4688d7f90a0ef"></a><!-- doxytag: member="flashc.c::flashc_erase_all_gp_fuses" ref="cf3096dc9ecea92533c4688d7f90a0ef" args="(Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_all_gp_fuses           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases all general-purpose fuses. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00463">463</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>, and <a class="el" href="a00045.html#l00414">flashc_read_all_gp_fuses()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00443">flashc_erase_gp_fuse_byte()</a>, and <a class="el" href="a00045.html#l00555">flashc_set_all_gp_fuses()</a>.<div class="fragment"><pre class="fragment"><a name="l00464"></a>00464 {
<a name="l00465"></a>00465   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EAGPF, -1);
<a name="l00466"></a>00466   <span class="keywordflow">return</span> (check) ? (<a class="code" href="a00020.html#13ee637e6c10a7bba5d92172ff520a80">flashc_read_all_gp_fuses</a>() == 0xFFFFFFFF) : TRUE;
<a name="l00467"></a>00467 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="230f4c4dcf517606a540dfa1df3efa91"></a><!-- doxytag: member="flashc.c::flashc_erase_all_pages" ref="230f4c4dcf517606a540dfa1df3efa91" args="(Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_all_pages           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases all pages within the flash array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if at least one region is locked or the bootloader protection is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00616">616</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00602">flashc_erase_page()</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00092">flashc_get_page_count()</a>.
<p>
Referenced by <a class="el" href="a00055.html#l00529">usb_dfu_dnload()</a>.<div class="fragment"><pre class="fragment"><a name="l00617"></a>00617 {
<a name="l00618"></a>00618   Bool all_pages_erased = TRUE;
<a name="l00619"></a>00619   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00620"></a>00620   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> page_number = <a class="code" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count</a>();
<a name="l00621"></a>00621   <span class="keywordflow">while</span> (page_number)
<a name="l00622"></a>00622   {
<a name="l00623"></a>00623     all_pages_erased &amp;= <a class="code" href="a00020.html#8de3bbd50094f548ca293f07b136cc6d">flashc_erase_page</a>(--page_number, check);
<a name="l00624"></a>00624     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00625"></a>00625   }
<a name="l00626"></a>00626   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00627"></a>00627   <span class="keywordflow">return</span> all_pages_erased;
<a name="l00628"></a>00628 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3d3494ba9bfe90893f65d2d3d90ab088"></a><!-- doxytag: member="flashc.c::flashc_erase_gp_fuse_bit" ref="3d3494ba9bfe90893f65d2d3d90ab088" args="(unsigned int gp_fuse_bit, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_gp_fuse_bit           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases a general-purpose fuse bit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>31</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00420">420</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>, and <a class="el" href="a00045.html#l00395">flashc_read_gp_fuse_bit()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00427">flashc_erase_gp_fuse_bitfield()</a>, and <a class="el" href="a00045.html#l00511">flashc_set_gp_fuse_bit()</a>.<div class="fragment"><pre class="fragment"><a name="l00421"></a>00421 {
<a name="l00422"></a>00422   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EGPB, gp_fuse_bit &amp; 0x1F);
<a name="l00423"></a>00423   <span class="keywordflow">return</span> (check) ? <a class="code" href="a00020.html#e6203d2e69ff15d59366c28bf8e26a7e">flashc_read_gp_fuse_bit</a>(gp_fuse_bit) : TRUE;
<a name="l00424"></a>00424 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5e1c12e72c0d141bc13fed9fe6a7dd19"></a><!-- doxytag: member="flashc.c::flashc_erase_gp_fuse_bitfield" ref="5e1c12e72c0d141bc13fed9fe6a7dd19" args="(unsigned int pos, unsigned int width, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_gp_fuse_bitfield           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases a general-purpose fuse bit-field. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>31</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>32</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00427">427</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00420">flashc_erase_gp_fuse_bit()</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00401">flashc_read_gp_fuse_bitfield()</a>.<div class="fragment"><pre class="fragment"><a name="l00428"></a>00428 {
<a name="l00429"></a>00429   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00430"></a>00430   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_bit;
<a name="l00431"></a>00431   pos &amp;= 0x1F;
<a name="l00432"></a>00432   width = min(width, 32);
<a name="l00433"></a>00433   <span class="keywordflow">for</span> (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++)
<a name="l00434"></a>00434   {
<a name="l00435"></a>00435     <a class="code" href="a00020.html#3d3494ba9bfe90893f65d2d3d90ab088">flashc_erase_gp_fuse_bit</a>(gp_fuse_bit, FALSE);
<a name="l00436"></a>00436     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00437"></a>00437   }
<a name="l00438"></a>00438   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00439"></a>00439   <span class="keywordflow">return</span> (check) ? (<a class="code" href="a00020.html#21af75e6beb4675f79c01a019ebc1a46">flashc_read_gp_fuse_bitfield</a>(pos, width) == (1 &lt;&lt; width) - 1) : TRUE;
<a name="l00440"></a>00440 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="293468b5d263ffe7f9a2595c900a9293"></a><!-- doxytag: member="flashc.c::flashc_erase_gp_fuse_byte" ref="293468b5d263ffe7f9a2595c900a9293" args="(unsigned int gp_fuse_byte, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_gp_fuse_byte           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases a general-purpose fuse byte. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>3</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00443">443</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00463">flashc_erase_all_gp_fuses()</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, <a class="el" href="a00045.html#l00414">flashc_read_all_gp_fuses()</a>, <a class="el" href="a00045.html#l00408">flashc_read_gp_fuse_byte()</a>, and <a class="el" href="a00045.html#l00492">flashc_write_gp_fuse_byte()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00535">flashc_set_gp_fuse_byte()</a>.<div class="fragment"><pre class="fragment"><a name="l00444"></a>00444 {
<a name="l00445"></a>00445   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status;
<a name="l00446"></a>00446   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_gp_fuse_byte;
<a name="l00447"></a>00447   U32 value = <a class="code" href="a00020.html#13ee637e6c10a7bba5d92172ff520a80">flashc_read_all_gp_fuses</a>();
<a name="l00448"></a>00448   <a class="code" href="a00020.html#cf3096dc9ecea92533c4688d7f90a0ef">flashc_erase_all_gp_fuses</a>(FALSE);
<a name="l00449"></a>00449   error_status = <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00450"></a>00450   <span class="keywordflow">for</span> (current_gp_fuse_byte = 0; current_gp_fuse_byte &lt; 4; current_gp_fuse_byte++, value &gt;&gt;= 8)
<a name="l00451"></a>00451   {
<a name="l00452"></a>00452     <span class="keywordflow">if</span> (current_gp_fuse_byte != gp_fuse_byte)
<a name="l00453"></a>00453     {
<a name="l00454"></a>00454       <a class="code" href="a00020.html#7670e69d41fe6a985ad898be25044caf">flashc_write_gp_fuse_byte</a>(current_gp_fuse_byte, value);
<a name="l00455"></a>00455       error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00456"></a>00456     }
<a name="l00457"></a>00457   }
<a name="l00458"></a>00458   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00459"></a>00459   <span class="keywordflow">return</span> (check) ? (<a class="code" href="a00020.html#1ad2aab294e528795bbd835539b0b14e">flashc_read_gp_fuse_byte</a>(gp_fuse_byte) == 0xFF) : TRUE;
<a name="l00460"></a>00460 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8de3bbd50094f548ca293f07b136cc6d"></a><!-- doxytag: member="flashc.c::flashc_erase_page" ref="8de3bbd50094f548ca293f07b136cc6d" args="(int page_number, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_page           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases a page. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: <ul>
<li><code>0</code> to <code>(<a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to a page belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00602">602</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00224">flashc_error_status</a>, <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>, and <a class="el" href="a00045.html#l00595">flashc_quick_page_read()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00616">flashc_erase_all_pages()</a>, and <a class="el" href="a00045.html#l00680">flashc_memset64()</a>.<div class="fragment"><pre class="fragment"><a name="l00603"></a>00603 {
<a name="l00604"></a>00604   Bool page_erased = TRUE;
<a name="l00605"></a>00605   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EP, page_number);
<a name="l00606"></a>00606   <span class="keywordflow">if</span> (check)
<a name="l00607"></a>00607   {
<a name="l00608"></a>00608     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00609"></a>00609     page_erased = <a class="code" href="a00020.html#cd50527aacf1d9ae11608fcc49a4fdcf">flashc_quick_page_read</a>(-1);
<a name="l00610"></a>00610     <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> |= error_status;
<a name="l00611"></a>00611   }
<a name="l00612"></a>00612   <span class="keywordflow">return</span> page_erased;
<a name="l00613"></a>00613 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ef66c5ffa0974223c44e151a8719b6d"></a><!-- doxytag: member="flashc.c::flashc_erase_user_page" ref="2ef66c5ffa0974223c44e151a8719b6d" args="(Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_user_page           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases the User page. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
An erase operation can only set bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00649">649</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00637">flashc_check_user_page_erase()</a>, and <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00680">flashc_memset64()</a>.<div class="fragment"><pre class="fragment"><a name="l00650"></a>00650 {
<a name="l00651"></a>00651   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EUP, -1);
<a name="l00652"></a>00652   <span class="keywordflow">return</span> (check) ? <a class="code" href="a00020.html#83ce37dee77452f369b163d131885f3d">flashc_check_user_page_erase</a>() : TRUE;
<a name="l00653"></a>00653 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="83ed88a41076163bd29ca80d30cb094f"></a><!-- doxytag: member="flashc.c::flashc_get_bootloader_protected_size" ref="83ed88a41076163bd29ca80d30cb094f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_bootloader_protected_size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the bootloader protected size. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The bootloader protected size in bytes. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00313">313</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00401">flashc_read_gp_fuse_bitfield()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00322">flashc_set_bootloader_protected_size()</a>.<div class="fragment"><pre class="fragment"><a name="l00314"></a>00314 {
<a name="l00315"></a>00315   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bootprot = (1 &lt;&lt; AVR32_FLASHC_FGPFR_BOOTPROT_SIZE) - 1 -
<a name="l00316"></a>00316                           <a class="code" href="a00020.html#21af75e6beb4675f79c01a019ebc1a46">flashc_read_gp_fuse_bitfield</a>(AVR32_FLASHC_FGPFR_BOOTPROT_OFFSET,
<a name="l00317"></a>00317                                                        AVR32_FLASHC_FGPFR_BOOTPROT_SIZE);
<a name="l00318"></a>00318   <span class="keywordflow">return</span> (bootprot) ? AVR32_FLASHC_PAGE_SIZE &lt;&lt; bootprot : 0;
<a name="l00319"></a>00319 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="36519235197ff4d6ab7f5adcb3fce6c1"></a><!-- doxytag: member="flashc.c::flashc_get_command" ref="36519235197ff4d6ab7f5adcb3fce6c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_command           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the last issued FLASHC command. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The last issued FLASHC command. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00247">247</a> of file <a class="el" href="a00045.html">flashc.c</a>.<div class="fragment"><pre class="fragment"><a name="l00248"></a>00248 {
<a name="l00249"></a>00249   <span class="keywordflow">return</span> (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_CMD_MASK) &gt;&gt; AVR32_FLASHC_FCMD_CMD_OFFSET;
<a name="l00250"></a>00250 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e7d38c60001d5d8d00363a6cb07f89f0"></a><!-- doxytag: member="flashc.c::flashc_get_error_status" ref="e7d38c60001d5d8d00363a6cb07f89f0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int flashc_get_error_status           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the error status of the FLASHC. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The error status of the FLASHC built up from <code>AVR32_FLASHC_FSR_LOCKE_MASK</code> and <code>AVR32_FLASHC_FSR_PROGE_MASK</code>.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This hardware error status is cleared by all functions reading the Flash Status Register (FSR). This function is therefore not part of the driver's API which instead presents <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a>. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00213">213</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.<div class="fragment"><pre class="fragment"><a name="l00214"></a>00214 {
<a name="l00215"></a>00215   <span class="keywordflow">return</span> AVR32_FLASHC.fsr &amp; (AVR32_FLASHC_FSR_LOCKE_MASK |
<a name="l00216"></a>00216                              AVR32_FLASHC_FSR_PROGE_MASK);
<a name="l00217"></a>00217 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8071c315b02d038c49fa0bf89a40ba1b"></a><!-- doxytag: member="flashc.c::flashc_get_flash_size" ref="8071c315b02d038c49fa0bf89a40ba1b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_flash_size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size of the whole flash array. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The size of the whole flash array in bytes. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00075">75</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00092">flashc_get_page_count()</a>, <a class="el" href="a00045.html#l00870">flashc_memcpy()</a>, <a class="el" href="a00045.html#l00680">flashc_memset64()</a>, and <a class="el" href="a00055.html#l00493">usb_dfu_init()</a>.<div class="fragment"><pre class="fragment"><a name="l00076"></a>00076 {
<a name="l00077"></a>00077   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> FLASH_SIZE[1 &lt;&lt; AVR32_FLASHC_FSR_FSZ_SIZE] =
<a name="l00078"></a>00078   {
<a name="l00079"></a>00079       32 &lt;&lt; 10,
<a name="l00080"></a>00080       64 &lt;&lt; 10,
<a name="l00081"></a>00081      128 &lt;&lt; 10,
<a name="l00082"></a>00082      256 &lt;&lt; 10,
<a name="l00083"></a>00083      384 &lt;&lt; 10,
<a name="l00084"></a>00084      512 &lt;&lt; 10,
<a name="l00085"></a>00085      768 &lt;&lt; 10,
<a name="l00086"></a>00086     1024 &lt;&lt; 10
<a name="l00087"></a>00087   };
<a name="l00088"></a>00088   <span class="keywordflow">return</span> FLASH_SIZE[(AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FSZ_MASK) &gt;&gt; AVR32_FLASHC_FSR_FSZ_OFFSET];
<a name="l00089"></a>00089 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="afad0dcf645cc65acb5bc879558dac23"></a><!-- doxytag: member="flashc.c::flashc_get_page_count" ref="afad0dcf645cc65acb5bc879558dac23" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_count           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the total number of pages in the flash array. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The total number of pages in the flash array. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00092">92</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00075">flashc_get_flash_size()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00616">flashc_erase_all_pages()</a>, and <a class="el" href="a00045.html#l00098">flashc_get_page_count_per_region()</a>.<div class="fragment"><pre class="fragment"><a name="l00093"></a>00093 {
<a name="l00094"></a>00094   <span class="keywordflow">return</span> <a class="code" href="a00020.html#8071c315b02d038c49fa0bf89a40ba1b">flashc_get_flash_size</a>() / AVR32_FLASHC_PAGE_SIZE;
<a name="l00095"></a>00095 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8910bcde3235e2af0770fbd2412b05bc"></a><!-- doxytag: member="flashc.c::flashc_get_page_count_per_region" ref="8910bcde3235e2af0770fbd2412b05bc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_count_per_region           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of pages in each flash region. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of pages in each flash region. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00098">98</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00046.html#l00054">AVR32_FLASHC_REGIONS</a>, and <a class="el" href="a00045.html#l00092">flashc_get_page_count()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00104">flashc_get_page_region()</a>, and <a class="el" href="a00045.html#l00110">flashc_get_region_first_page_number()</a>.<div class="fragment"><pre class="fragment"><a name="l00099"></a>00099 {
<a name="l00100"></a>00100   <span class="keywordflow">return</span> <a class="code" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count</a>() / <a class="code" href="a00021.html#a70e373b96ff9c00883f284ca308e592">AVR32_FLASHC_REGIONS</a>;
<a name="l00101"></a>00101 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="db51a37e3153c24e5dd6cf06daac0e21"></a><!-- doxytag: member="flashc.c::flashc_get_page_number" ref="db51a37e3153c24e5dd6cf06daac0e21" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_number           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current FLASHC page number. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current FLASHC page number. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00253">253</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00104">flashc_get_page_region()</a>.<div class="fragment"><pre class="fragment"><a name="l00254"></a>00254 {
<a name="l00255"></a>00255   <span class="keywordflow">return</span> (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_PAGEN_MASK) &gt;&gt; AVR32_FLASHC_FCMD_PAGEN_OFFSET;
<a name="l00256"></a>00256 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c5871dc98c8812b0413efd6456508999"></a><!-- doxytag: member="flashc.c::flashc_get_page_region" ref="c5871dc98c8812b0413efd6456508999" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_region           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the region number of a page. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: <ul>
<li><code>0</code> to <code>(<a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The region number of the specified page. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00104">104</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00098">flashc_get_page_count_per_region()</a>, and <a class="el" href="a00045.html#l00253">flashc_get_page_number()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00350">flashc_is_page_region_locked()</a>.<div class="fragment"><pre class="fragment"><a name="l00105"></a>00105 {
<a name="l00106"></a>00106   <span class="keywordflow">return</span> ((page_number &gt;= 0) ? page_number : <a class="code" href="a00020.html#db51a37e3153c24e5dd6cf06daac0e21">flashc_get_page_number</a>()) / <a class="code" href="a00020.html#8910bcde3235e2af0770fbd2412b05bc">flashc_get_page_count_per_region</a>();
<a name="l00107"></a>00107 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="43b14107d406ea9025f8947490c9ddcd"></a><!-- doxytag: member="flashc.c::flashc_get_region_first_page_number" ref="43b14107d406ea9025f8947490c9ddcd" args="(unsigned int region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_region_first_page_number           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>region</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of the first page of a region. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The region number: <code>0</code> to <code>(AVR32_FLASHC_REGIONS - 1)</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of the first page of the specified region. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00110">110</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00098">flashc_get_page_count_per_region()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00368">flashc_lock_region()</a>.<div class="fragment"><pre class="fragment"><a name="l00111"></a>00111 {
<a name="l00112"></a>00112   <span class="keywordflow">return</span> region * <a class="code" href="a00020.html#8910bcde3235e2af0770fbd2412b05bc">flashc_get_page_count_per_region</a>();
<a name="l00113"></a>00113 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="52784dbdd246c6c320e5041026d4da08"></a><!-- doxytag: member="flashc.c::flashc_get_wait_state" ref="52784dbdd246c6c320e5041026d4da08" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_wait_state           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of wait states of flash read accesses. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of wait states of flash read accesses. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00124">124</a> of file <a class="el" href="a00045.html">flashc.c</a>.<div class="fragment"><pre class="fragment"><a name="l00125"></a>00125 {
<a name="l00126"></a>00126   <span class="keywordflow">return</span> (AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FWS_MASK) &gt;&gt; AVR32_FLASHC_FCR_FWS_OFFSET;
<a name="l00127"></a>00127 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="64607cf8bb7de7e226973c7d9a10170d"></a><!-- doxytag: member="flashc.c::flashc_is_external_privileged_fetch_locked" ref="64607cf8bb7de7e226973c7d9a10170d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_external_privileged_fetch_locked           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether external privileged fetch is locked. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether external privileged fetch is locked. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00338">338</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00395">flashc_read_gp_fuse_bit()</a>.<div class="fragment"><pre class="fragment"><a name="l00339"></a>00339 {
<a name="l00340"></a>00340   <span class="keywordflow">return</span> (!<a class="code" href="a00020.html#e6203d2e69ff15d59366c28bf8e26a7e">flashc_read_gp_fuse_bit</a>(AVR32_FLASHC_FGPFR_EPFL_OFFSET));
<a name="l00341"></a>00341 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a5e4eb7ae688be5d59fca4bb6a326447"></a><!-- doxytag: member="flashc.c::flashc_is_lock_error" ref="a5e4eb7ae688be5d59fca4bb6a326447" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_lock_error           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether a Lock Error has occurred during the last function called that issued one or more FLASHC commands. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a Lock Error has occurred during the last function called that issued one or more FLASHC commands. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00227">227</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00224">flashc_error_status</a>.<div class="fragment"><pre class="fragment"><a name="l00228"></a>00228 {
<a name="l00229"></a>00229   <span class="keywordflow">return</span> ((<a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> &amp; AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
<a name="l00230"></a>00230 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d9a950413a6b9d64a832b82ebaa2c38d"></a><!-- doxytag: member="flashc.c::flashc_is_lock_error_int_enabled" ref="d9a950413a6b9d64a832b82ebaa2c38d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_lock_error_int_enabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether the Lock Error interrupt is enabled. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the Lock Error interrupt is enabled. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00152">152</a> of file <a class="el" href="a00045.html">flashc.c</a>.<div class="fragment"><pre class="fragment"><a name="l00153"></a>00153 {
<a name="l00154"></a>00154   <span class="keywordflow">return</span> ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_LOCKE_MASK) != 0);
<a name="l00155"></a>00155 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cdea4bfb0cb1066fba239a9302196ee5"></a><!-- doxytag: member="flashc.c::flashc_is_page_erased" ref="cdea4bfb0cb1066fba239a9302196ee5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_page_erased           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether the page to which the last Quick Page Read command was applied was erased. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the page to which the last Quick Page Read command was applied was erased. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00589">589</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00595">flashc_quick_page_read()</a>.<div class="fragment"><pre class="fragment"><a name="l00590"></a>00590 {
<a name="l00591"></a>00591   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_QPRR_MASK) != 0);
<a name="l00592"></a>00592 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fa30fe317124244e8c5a7fcc7a0ba44b"></a><!-- doxytag: member="flashc.c::flashc_is_page_region_locked" ref="fa30fe317124244e8c5a7fcc7a0ba44b" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_page_region_locked           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether the region of a page is locked. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: <ul>
<li><code>0</code> to <code>(<a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the region of the specified page is locked. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00350">350</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00104">flashc_get_page_region()</a>, and <a class="el" href="a00045.html#l00356">flashc_is_region_locked()</a>.<div class="fragment"><pre class="fragment"><a name="l00351"></a>00351 {
<a name="l00352"></a>00352   <span class="keywordflow">return</span> <a class="code" href="a00020.html#e6e9e45c046406a645ffac5e3fd62d40">flashc_is_region_locked</a>(<a class="code" href="a00020.html#c5871dc98c8812b0413efd6456508999">flashc_get_page_region</a>(page_number));
<a name="l00353"></a>00353 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ec6b3818f1a6a0d4bf69838c2743de85"></a><!-- doxytag: member="flashc.c::flashc_is_prog_error_int_enabled" ref="ec6b3818f1a6a0d4bf69838c2743de85" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_prog_error_int_enabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether the Programming Error interrupt is enabled. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the Programming Error interrupt is enabled. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00166">166</a> of file <a class="el" href="a00045.html">flashc.c</a>.<div class="fragment"><pre class="fragment"><a name="l00167"></a>00167 {
<a name="l00168"></a>00168   <span class="keywordflow">return</span> ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_PROGE_MASK) != 0);
<a name="l00169"></a>00169 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2556a29213a1be8df40df2f8868077bd"></a><!-- doxytag: member="flashc.c::flashc_is_programming_error" ref="2556a29213a1be8df40df2f8868077bd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_programming_error           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether a Programming Error has occurred during the last function called that issued one or more FLASHC commands. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether a Programming Error has occurred during the last function called that issued one or more FLASHC commands. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00233">233</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00224">flashc_error_status</a>.<div class="fragment"><pre class="fragment"><a name="l00234"></a>00234 {
<a name="l00235"></a>00235   <span class="keywordflow">return</span> ((<a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> &amp; AVR32_FLASHC_FSR_PROGE_MASK) != 0);
<a name="l00236"></a>00236 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c47ea338258641e6fe9361885a116c39"></a><!-- doxytag: member="flashc.c::flashc_is_ready" ref="c47ea338258641e6fe9361885a116c39" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_ready           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether the FLASHC is ready to run a new command. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the FLASHC is ready to run a new command. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00188">188</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00194">flashc_default_wait_until_ready()</a>.<div class="fragment"><pre class="fragment"><a name="l00189"></a>00189 {
<a name="l00190"></a>00190   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FRDY_MASK) != 0);
<a name="l00191"></a>00191 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="517223d37600d347adc24fed238ebaf7"></a><!-- doxytag: member="flashc.c::flashc_is_ready_int_enabled" ref="517223d37600d347adc24fed238ebaf7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_ready_int_enabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether the Flash Ready interrupt is enabled. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the Flash Ready interrupt is enabled. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00138">138</a> of file <a class="el" href="a00045.html">flashc.c</a>.<div class="fragment"><pre class="fragment"><a name="l00139"></a>00139 {
<a name="l00140"></a>00140   <span class="keywordflow">return</span> ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FRDY_MASK) != 0);
<a name="l00141"></a>00141 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e6e9e45c046406a645ffac5e3fd62d40"></a><!-- doxytag: member="flashc.c::flashc_is_region_locked" ref="e6e9e45c046406a645ffac5e3fd62d40" args="(unsigned int region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_region_locked           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>region</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether a region is locked. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The region number: <code>0</code> to <code>(AVR32_FLASHC_REGIONS - 1)</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the specified region is locked. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00356">356</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00046.html#l00054">AVR32_FLASHC_REGIONS</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00350">flashc_is_page_region_locked()</a>.<div class="fragment"><pre class="fragment"><a name="l00357"></a>00357 {
<a name="l00358"></a>00358   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_LOCK0_MASK &lt;&lt; (region &amp; (<a class="code" href="a00021.html#a70e373b96ff9c00883f284ca308e592">AVR32_FLASHC_REGIONS</a> - 1))) != 0);
<a name="l00359"></a>00359 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="03df73f0be08f7bc503f3c336b1abdc1"></a><!-- doxytag: member="flashc.c::flashc_is_security_bit_active" ref="03df73f0be08f7bc503f3c336b1abdc1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_security_bit_active           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells whether the Security bit is active. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the Security bit is active. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00301">301</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00055.html#l00345">mem_security_read()</a>, and <a class="el" href="a00055.html#l00493">usb_dfu_init()</a>.<div class="fragment"><pre class="fragment"><a name="l00302"></a>00302 {
<a name="l00303"></a>00303   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_SECURITY_MASK) != 0);
<a name="l00304"></a>00304 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8045c427c32cf3617e861067d76c9c11"></a><!-- doxytag: member="flashc.c::flashc_issue_command" ref="8045c427c32cf3617e861067d76c9c11" args="(unsigned int command, int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_issue_command           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Issues a FLASHC command. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The command: <code>AVR32_FLASHC_FCMD_CMD_x</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number to apply the command to: <ul>
<li><code>0</code> to <code>(<a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: use this to apply the command to the current page number or if the command does not apply to any page number; </li>
<li>this argument may have other meanings according to the command. See the FLASHC chapter of the MCU datasheet.</li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command violates the protection mechanism.<p>
A Programming Error is issued if the command is invalid.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00259">259</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00063">u_avr32_flashc_fcmd_t::fcmd</a>, <a class="el" href="a00045.html#l00064">u_avr32_flashc_fcmd_t::FCMD</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, <a class="el" href="a00045.html#l00213">flashc_get_error_status()</a>, and <a class="el" href="a00045.html#l00200">flashc_wait_until_ready</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00307">flashc_activate_security_bit()</a>, <a class="el" href="a00045.html#l00583">flashc_clear_page_buffer()</a>, <a class="el" href="a00045.html#l00287">flashc_erase_all()</a>, <a class="el" href="a00045.html#l00463">flashc_erase_all_gp_fuses()</a>, <a class="el" href="a00045.html#l00420">flashc_erase_gp_fuse_bit()</a>, <a class="el" href="a00045.html#l00602">flashc_erase_page()</a>, <a class="el" href="a00045.html#l00649">flashc_erase_user_page()</a>, <a class="el" href="a00045.html#l00362">flashc_lock_page_region()</a>, <a class="el" href="a00045.html#l00281">flashc_no_operation()</a>, <a class="el" href="a00045.html#l00595">flashc_quick_page_read()</a>, <a class="el" href="a00045.html#l00470">flashc_write_gp_fuse_bit()</a>, <a class="el" href="a00045.html#l00492">flashc_write_gp_fuse_byte()</a>, <a class="el" href="a00045.html#l00631">flashc_write_page()</a>, and <a class="el" href="a00045.html#l00656">flashc_write_user_page()</a>.<div class="fragment"><pre class="fragment"><a name="l00260"></a>00260 {
<a name="l00261"></a>00261   <a class="code" href="a00014.html">u_avr32_flashc_fcmd_t</a> u_avr32_flashc_fcmd;
<a name="l00262"></a>00262   <a class="code" href="a00020.html#c293397096f61bb5c2400792f3b39c0f">flashc_wait_until_ready</a>();
<a name="l00263"></a>00263   u_avr32_flashc_fcmd.<a class="code" href="a00014.html#6e34d6a9df4c1f26204d439fd5314700">fcmd</a> = AVR32_FLASHC.fcmd;
<a name="l00264"></a>00264   u_avr32_flashc_fcmd.<a class="code" href="a00014.html#417db73c116267ff3545f9af41fac150">FCMD</a>.cmd = command;
<a name="l00265"></a>00265   <span class="keywordflow">if</span> (page_number &gt;= 0) u_avr32_flashc_fcmd.<a class="code" href="a00014.html#417db73c116267ff3545f9af41fac150">FCMD</a>.pagen = page_number;
<a name="l00266"></a>00266   u_avr32_flashc_fcmd.<a class="code" href="a00014.html#417db73c116267ff3545f9af41fac150">FCMD</a>.key = AVR32_FLASHC_FCMD_KEY_KEY;
<a name="l00267"></a>00267   AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.<a class="code" href="a00014.html#6e34d6a9df4c1f26204d439fd5314700">fcmd</a>;
<a name="l00268"></a>00268   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = <a class="code" href="a00020.html#e7d38c60001d5d8d00363a6cb07f89f0">flashc_get_error_status</a>();
<a name="l00269"></a>00269   <a class="code" href="a00020.html#c293397096f61bb5c2400792f3b39c0f">flashc_wait_until_ready</a>();
<a name="l00270"></a>00270 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7c05cca97169ee6888828c40243c0191"></a><!-- doxytag: member="flashc.c::flashc_lock_all_regions" ref="7c05cca97169ee6888828c40243c0191" args="(Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_all_regions           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks or unlocks all regions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock the regions: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00374">374</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00046.html#l00054">AVR32_FLASHC_REGIONS</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00368">flashc_lock_region()</a>.
<p>
Referenced by <a class="el" href="a00055.html#l00529">usb_dfu_dnload()</a>.<div class="fragment"><pre class="fragment"><a name="l00375"></a>00375 {
<a name="l00376"></a>00376   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00377"></a>00377   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> region = <a class="code" href="a00021.html#a70e373b96ff9c00883f284ca308e592">AVR32_FLASHC_REGIONS</a>;
<a name="l00378"></a>00378   <span class="keywordflow">while</span> (region)
<a name="l00379"></a>00379   {
<a name="l00380"></a>00380     <a class="code" href="a00020.html#026f45da4ae8afea4d40066d3523ee3b">flashc_lock_region</a>(--region, lock);
<a name="l00381"></a>00381     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00382"></a>00382   }
<a name="l00383"></a>00383   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00384"></a>00384 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5b5725c807435b40115f4577a79b88b2"></a><!-- doxytag: member="flashc.c::flashc_lock_external_privileged_fetch" ref="5b5725c807435b40115f4577a79b88b2" args="(Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_external_privileged_fetch           </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks or unlocks external privileged fetch. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock external privileged fetch: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00344">344</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00511">flashc_set_gp_fuse_bit()</a>.<div class="fragment"><pre class="fragment"><a name="l00345"></a>00345 {
<a name="l00346"></a>00346   <a class="code" href="a00020.html#5c5442a988c608baea0d1c0b841badca">flashc_set_gp_fuse_bit</a>(AVR32_FLASHC_FGPFR_EPFL_OFFSET, !lock);
<a name="l00347"></a>00347 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a79c8c0023a4813a08cff039ccd003ab"></a><!-- doxytag: member="flashc.c::flashc_lock_page_region" ref="a79c8c0023a4813a08cff039ccd003ab" args="(int page_number, Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_page_region           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks or unlocks the region of a page. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: <ul>
<li><code>0</code> to <code>(<a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock the region of the specified page: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00362">362</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00368">flashc_lock_region()</a>.<div class="fragment"><pre class="fragment"><a name="l00363"></a>00363 {
<a name="l00364"></a>00364   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>((lock) ? AVR32_FLASHC_FCMD_CMD_LP : AVR32_FLASHC_FCMD_CMD_UP, page_number);
<a name="l00365"></a>00365 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="026f45da4ae8afea4d40066d3523ee3b"></a><!-- doxytag: member="flashc.c::flashc_lock_region" ref="026f45da4ae8afea4d40066d3523ee3b" args="(unsigned int region, Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_region           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks or unlocks a region. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The region number: <code>0</code> to <code>(AVR32_FLASHC_REGIONS - 1)</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock the specified region: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00368">368</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00110">flashc_get_region_first_page_number()</a>, and <a class="el" href="a00045.html#l00362">flashc_lock_page_region()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00374">flashc_lock_all_regions()</a>.<div class="fragment"><pre class="fragment"><a name="l00369"></a>00369 {
<a name="l00370"></a>00370   <a class="code" href="a00020.html#a79c8c0023a4813a08cff039ccd003ab">flashc_lock_page_region</a>(<a class="code" href="a00020.html#43b14107d406ea9025f8947490c9ddcd">flashc_get_region_first_page_number</a>(region), lock);
<a name="l00371"></a>00371 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b257e261b58cabbd30f176287882886e"></a><!-- doxytag: member="flashc.c::flashc_memcpy" ref="b257e261b58cabbd30f176287882886e" args="(volatile void *dst, const void *src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memcpy           </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the source pointed to by <em>src</em>. 
<p>
The destination areas that are not within the flash array or the User page are ignored.<p>
All pointer and size alignments are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to source data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If copying takes place between areas that overlap, the behavior is undefined.<p>
A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00870">870</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00583">flashc_clear_page_buffer()</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00075">flashc_get_flash_size()</a>.
<p>
Referenced by <a class="el" href="a00055.html#l00339">mem_flash_write()</a>, and <a class="el" href="a00055.html#l00396">mem_user_write()</a>.<div class="fragment"><pre class="fragment"><a name="l00871"></a>00871 {
<a name="l00872"></a>00872   <span class="comment">// Use aggregated pointers to have several alignments available for a same address.</span>
<a name="l00873"></a>00873   UnionCVPtr flash_array_end;
<a name="l00874"></a>00874   UnionVPtr dest;
<a name="l00875"></a>00875   UnionCPtr source;
<a name="l00876"></a>00876   StructCVPtr dest_end;
<a name="l00877"></a>00877   UnionCVPtr flash_page_source_end;
<a name="l00878"></a>00878   Bool incomplete_flash_page_end;
<a name="l00879"></a>00879   Union64 flash_dword;
<a name="l00880"></a>00880   Bool flash_dword_pending = FALSE;
<a name="l00881"></a>00881   UnionVPtr tmp;
<a name="l00882"></a>00882   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00883"></a>00883   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="comment">// Reformat arguments.</span>
<a name="l00886"></a>00886   flash_array_end.u8ptr = AVR32_FLASH + <a class="code" href="a00020.html#8071c315b02d038c49fa0bf89a40ba1b">flashc_get_flash_size</a>();
<a name="l00887"></a>00887   dest.u8ptr = dst;
<a name="l00888"></a>00888   source.u8ptr = src;
<a name="l00889"></a>00889   dest_end.u8ptr = dest.u8ptr + nbytes;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891   <span class="comment">// If destination is outside flash, go to next flash page if any.</span>
<a name="l00892"></a>00892   <span class="keywordflow">if</span> (dest.u8ptr &lt; AVR32_FLASH)
<a name="l00893"></a>00893   {
<a name="l00894"></a>00894     source.u8ptr += AVR32_FLASH - dest.u8ptr;
<a name="l00895"></a>00895     dest.u8ptr = AVR32_FLASH;
<a name="l00896"></a>00896   }
<a name="l00897"></a>00897   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
<a name="l00898"></a>00898   {
<a name="l00899"></a>00899     source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
<a name="l00900"></a>00900     dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l00901"></a>00901   }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   <span class="comment">// If end of destination is outside flash, move it to the end of the previous flash page if any.</span>
<a name="l00904"></a>00904   <span class="keywordflow">if</span> (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
<a name="l00905"></a>00905   {
<a name="l00906"></a>00906     dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
<a name="l00907"></a>00907   }
<a name="l00908"></a>00908   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
<a name="l00909"></a>00909   {
<a name="l00910"></a>00910     dest_end.u8ptr = flash_array_end.u8ptr;
<a name="l00911"></a>00911   }
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   <span class="comment">// Align each end of destination pointer with its natural boundary.</span>
<a name="l00914"></a>00914   dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U16));
<a name="l00915"></a>00915   dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, <span class="keyword">sizeof</span>(U32));
<a name="l00916"></a>00916   dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   <span class="comment">// While end of destination is not reached...</span>
<a name="l00919"></a>00919   <span class="keywordflow">while</span> (dest.u8ptr &lt; dest_end.u8ptr)
<a name="l00920"></a>00920   {
<a name="l00921"></a>00921     <span class="comment">// Clear the page buffer in order to prepare data for a flash page write.</span>
<a name="l00922"></a>00922     <a class="code" href="a00020.html#ffafe9cb74731d817b721d2a52093412">flashc_clear_page_buffer</a>();
<a name="l00923"></a>00923     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925     <span class="comment">// Determine where the source data will end in the current flash page.</span>
<a name="l00926"></a>00926     flash_page_source_end.u64ptr =
<a name="l00927"></a>00927       (U64 *)min((U32)dest_end.u64ptr,
<a name="l00928"></a>00928                  Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930     <span class="comment">// Determine if the current destination page has an incomplete end.</span>
<a name="l00931"></a>00931     incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
<a name="l00932"></a>00932                                  Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
<a name="l00933"></a>00933 
<a name="l00934"></a>00934     <span class="comment">// If destination does not point to the beginning of the current flash page...</span>
<a name="l00935"></a>00935     <span class="keywordflow">if</span> (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
<a name="l00936"></a>00936     {
<a name="l00937"></a>00937       <span class="comment">// If page erase is requested...</span>
<a name="l00938"></a>00938       <span class="keywordflow">if</span> (erase)
<a name="l00939"></a>00939       {
<a name="l00940"></a>00940         <span class="comment">// Fill the beginning of the page buffer with the current flash page data.</span>
<a name="l00941"></a>00941         <span class="keywordflow">for</span> (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
<a name="l00942"></a>00942              tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00943"></a>00943              tmp.u64ptr++)
<a name="l00944"></a>00944           *tmp.u64ptr = *tmp.u64ptr;
<a name="l00945"></a>00945       }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947       <span class="comment">// If destination is not 64-bit aligned...</span>
<a name="l00948"></a>00948       <span class="keywordflow">if</span> (!Test_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l00949"></a>00949       {
<a name="l00950"></a>00950         <span class="comment">// If page erase is requested...</span>
<a name="l00951"></a>00951         <span class="keywordflow">if</span> (erase)
<a name="l00952"></a>00952         {
<a name="l00953"></a>00953           <span class="comment">// Fill the beginning of the flash double-word buffer with the current flash page data.</span>
<a name="l00954"></a>00954           <span class="keywordflow">for</span> (i = 0; i &lt; Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l00955"></a>00955             flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l00956"></a>00956         }
<a name="l00957"></a>00957         <span class="comment">// If page erase is not requested...</span>
<a name="l00958"></a>00958         <span class="keywordflow">else</span>
<a name="l00959"></a>00959         {
<a name="l00960"></a>00960           <span class="comment">// Erase the beginning of the flash double-word buffer.</span>
<a name="l00961"></a>00961           <span class="keywordflow">for</span> (i = 0; i &lt; Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l00962"></a>00962             flash_dword.u8[i] = 0xFF;
<a name="l00963"></a>00963         }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965         <span class="comment">// Fill the end of the flash double-word buffer with the source data.</span>
<a name="l00966"></a>00966         <span class="keywordflow">for</span> (; i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l00967"></a>00967           flash_dword.u8[i] = *source.u8ptr++;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         <span class="comment">// Align the destination pointer with its 64-bit boundary.</span>
<a name="l00970"></a>00970         dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00971"></a>00971 
<a name="l00972"></a>00972         <span class="comment">// If the current destination double-word is not the last one...</span>
<a name="l00973"></a>00973         if (dest.u64ptr &lt; dest_end.u64ptr)
<a name="l00974"></a>00974         {
<a name="l00975"></a>00975           <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l00976"></a>00976           *dest.u64ptr++ = flash_dword.u64;
<a name="l00977"></a>00977         }
<a name="l00978"></a>00978         <span class="comment">// If the current destination double-word is the last one, the flash</span>
<a name="l00979"></a>00979         <span class="comment">// double-word buffer must be kept for later.</span>
<a name="l00980"></a>00980         <span class="keywordflow">else</span> flash_dword_pending = TRUE;
<a name="l00981"></a>00981       }
<a name="l00982"></a>00982     }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984     <span class="comment">// Read the source data with the maximal possible alignment and write it to</span>
<a name="l00985"></a>00985     <span class="comment">// the page buffer with 64-bit alignment.</span>
<a name="l00986"></a>00986     <span class="keywordflow">switch</span> (Get_align((U32)source.u8ptr, <span class="keyword">sizeof</span>(U32)))
<a name="l00987"></a>00987     {
<a name="l00988"></a>00988     <span class="keywordflow">case</span> 0:
<a name="l00989"></a>00989       for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l00990"></a>00990         *dest.u64ptr++ = *source.u64ptr++;
<a name="l00991"></a>00991       <span class="keywordflow">break</span>;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     <span class="keywordflow">case</span> <span class="keyword">sizeof</span>(U16):
<a name="l00994"></a>00994       for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l00995"></a>00995       {
<a name="l00996"></a>00996         for (j = 0; j &lt; <span class="keyword">sizeof</span>(U64) / <span class="keyword">sizeof</span>(U16); j++) flash_dword.u16[j] = *source.u16ptr++;
<a name="l00997"></a>00997         *dest.u64ptr++ = flash_dword.u64;
<a name="l00998"></a>00998       }
<a name="l00999"></a>00999       <span class="keywordflow">break</span>;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001     <span class="keywordflow">default</span>:
<a name="l01002"></a>01002       <span class="keywordflow">for</span> (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l01003"></a>01003       {
<a name="l01004"></a>01004         for (j = 0; j &lt; <span class="keyword">sizeof</span>(U64); j++) flash_dword.u8[j] = *source.u8ptr++;
<a name="l01005"></a>01005         *dest.u64ptr++ = flash_dword.u64;
<a name="l01006"></a>01006       }
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008 
<a name="l01009"></a>01009     <span class="comment">// If the current destination page has an incomplete end...</span>
<a name="l01010"></a>01010     <span class="keywordflow">if</span> (incomplete_flash_page_end)
<a name="l01011"></a>01011     {
<a name="l01012"></a>01012       <span class="comment">// If the flash double-word buffer is in use, do not initialize it.</span>
<a name="l01013"></a>01013       <span class="keywordflow">if</span> (flash_dword_pending) i = Get_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l01014"></a>01014       <span class="comment">// If the flash double-word buffer is free...</span>
<a name="l01015"></a>01015       <span class="keywordflow">else</span>
<a name="l01016"></a>01016       {
<a name="l01017"></a>01017         <span class="comment">// Fill the beginning of the flash double-word buffer with the source data.</span>
<a name="l01018"></a>01018         for (i = 0; i &lt; Get_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l01019"></a>01019           flash_dword.u8[i] = *source.u8ptr++;
<a name="l01020"></a>01020       }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022       <span class="comment">// If page erase is requested...</span>
<a name="l01023"></a>01023       <span class="keywordflow">if</span> (erase)
<a name="l01024"></a>01024       {
<a name="l01025"></a>01025         tmp.u8ptr = (<span class="keyword">volatile</span> U8 *)dest_end.u8ptr;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027         <span class="comment">// If end of destination is not 64-bit aligned...</span>
<a name="l01028"></a>01028         if (!Test_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l01029"></a>01029         {
<a name="l01030"></a>01030           <span class="comment">// Fill the end of the flash double-word buffer with the current flash page data.</span>
<a name="l01031"></a>01031           <span class="keywordflow">for</span> (; i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l01032"></a>01032             flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034           <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l01035"></a>01035           *dest.u64ptr++ = flash_dword.u64;
<a name="l01036"></a>01036         }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038         <span class="comment">// Fill the end of the page buffer with the current flash page data.</span>
<a name="l01039"></a>01039         <span class="keywordflow">for</span> (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
<a name="l01040"></a>01040           *tmp.u64ptr = *tmp.u64ptr;
<a name="l01041"></a>01041       }
<a name="l01042"></a>01042       <span class="comment">// If page erase is not requested but end of destination is not 64-bit aligned...</span>
<a name="l01043"></a>01043       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!Test_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l01044"></a>01044       {
<a name="l01045"></a>01045         <span class="comment">// Erase the end of the flash double-word buffer.</span>
<a name="l01046"></a>01046         <span class="keywordflow">for</span> (; i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l01047"></a>01047           flash_dword.u8[i] = 0xFF;
<a name="l01048"></a>01048 
<a name="l01049"></a>01049         <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l01050"></a>01050         *dest.u64ptr++ = flash_dword.u64;
<a name="l01051"></a>01051       }
<a name="l01052"></a>01052     }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="comment">// If the current flash page is in the flash array...</span>
<a name="l01055"></a>01055     <span class="keywordflow">if</span> (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
<a name="l01056"></a>01056     {
<a name="l01057"></a>01057       <span class="comment">// Erase the current page if requested and write it from the page buffer.</span>
<a name="l01058"></a>01058       if (erase)
<a name="l01059"></a>01059       {
<a name="l01060"></a>01060         <a class="code" href="a00020.html#8de3bbd50094f548ca293f07b136cc6d">flashc_erase_page</a>(-1, FALSE);
<a name="l01061"></a>01061         error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l01062"></a>01062       }
<a name="l01063"></a>01063       <a class="code" href="a00020.html#a10438433246139bee71da6db2bb5bd5">flashc_write_page</a>(-1);
<a name="l01064"></a>01064       error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l01065"></a>01065 
<a name="l01066"></a>01066       <span class="comment">// If the end of the flash array is reached, go to the User page.</span>
<a name="l01067"></a>01067       <span class="keywordflow">if</span> (dest.u8ptr &gt;= flash_array_end.u8ptr)
<a name="l01068"></a>01068       {
<a name="l01069"></a>01069         source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
<a name="l01070"></a>01070         dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l01071"></a>01071       }
<a name="l01072"></a>01072     }
<a name="l01073"></a>01073     <span class="comment">// If the current flash page is the User page...</span>
<a name="l01074"></a>01074     <span class="keywordflow">else</span>
<a name="l01075"></a>01075     {
<a name="l01076"></a>01076       <span class="comment">// Erase the User page if requested and write it from the page buffer.</span>
<a name="l01077"></a>01077       <span class="keywordflow">if</span> (erase)
<a name="l01078"></a>01078       {
<a name="l01079"></a>01079         <a class="code" href="a00020.html#2ef66c5ffa0974223c44e151a8719b6d">flashc_erase_user_page</a>(FALSE);
<a name="l01080"></a>01080         error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l01081"></a>01081       }
<a name="l01082"></a>01082       <a class="code" href="a00020.html#d04374b721dca9c534d7cd041ae24712">flashc_write_user_page</a>();
<a name="l01083"></a>01083       error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085   }
<a name="l01086"></a>01086 
<a name="l01087"></a>01087   <span class="comment">// Update the FLASHC error status.</span>
<a name="l01088"></a>01088   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l01089"></a>01089 
<a name="l01090"></a>01090   <span class="comment">// Return the initial destination pointer as the standard memcpy function does.</span>
<a name="l01091"></a>01091   <span class="keywordflow">return</span> dst;
<a name="l01092"></a>01092 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1e3ac5049d1eed492678764f8d1efc4b"></a><!-- doxytag: member="flashc.c::flashc_memset16" ref="1e3ac5049d1eed492678764f8d1efc4b" args="(volatile void *dst, U16 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset16           </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source half-word. 
<p>
The destination areas that are not within the flash array or the User page are ignored.<p>
All pointer and size alignments are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source half-word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00668">668</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00674">flashc_memset32()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00662">flashc_memset8()</a>.<div class="fragment"><pre class="fragment"><a name="l00669"></a>00669 {
<a name="l00670"></a>00670   <span class="keywordflow">return</span> <a class="code" href="a00020.html#f51102eac590a354c08f3b4311745674">flashc_memset32</a>(dst, src | (U32)src &lt;&lt; 16, nbytes, erase);
<a name="l00671"></a>00671 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f51102eac590a354c08f3b4311745674"></a><!-- doxytag: member="flashc.c::flashc_memset32" ref="f51102eac590a354c08f3b4311745674" args="(volatile void *dst, U32 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset32           </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source word. 
<p>
The destination areas that are not within the flash array or the User page are ignored.<p>
All pointer and size alignments are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00674">674</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00680">flashc_memset64()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00668">flashc_memset16()</a>.<div class="fragment"><pre class="fragment"><a name="l00675"></a>00675 {
<a name="l00676"></a>00676   <span class="keywordflow">return</span> <a class="code" href="a00020.html#d232684f65e596ffd85a63e0c1a5c41d">flashc_memset64</a>(dst, src | (U64)src &lt;&lt; 32, nbytes, erase);
<a name="l00677"></a>00677 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d232684f65e596ffd85a63e0c1a5c41d"></a><!-- doxytag: member="flashc.c::flashc_memset64" ref="d232684f65e596ffd85a63e0c1a5c41d" args="(volatile void *dst, U64 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset64           </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source double-word. 
<p>
The destination areas that are not within the flash array or the User page are ignored.<p>
All pointer and size alignments are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source double-word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00680">680</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00583">flashc_clear_page_buffer()</a>, <a class="el" href="a00045.html#l00602">flashc_erase_page()</a>, <a class="el" href="a00045.html#l00649">flashc_erase_user_page()</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, <a class="el" href="a00045.html#l00075">flashc_get_flash_size()</a>, <a class="el" href="a00045.html#l00631">flashc_write_page()</a>, and <a class="el" href="a00045.html#l00656">flashc_write_user_page()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00674">flashc_memset32()</a>.<div class="fragment"><pre class="fragment"><a name="l00681"></a>00681 {
<a name="l00682"></a>00682   <span class="comment">// Use aggregated pointers to have several alignments available for a same address.</span>
<a name="l00683"></a>00683   UnionCVPtr flash_array_end;
<a name="l00684"></a>00684   UnionVPtr dest;
<a name="l00685"></a>00685   Union64 source = {0};
<a name="l00686"></a>00686   StructCVPtr dest_end;
<a name="l00687"></a>00687   UnionCVPtr flash_page_source_end;
<a name="l00688"></a>00688   Bool incomplete_flash_page_end;
<a name="l00689"></a>00689   Union64 flash_dword;
<a name="l00690"></a>00690   UnionVPtr tmp;
<a name="l00691"></a>00691   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00692"></a>00692   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="comment">// Reformat arguments.</span>
<a name="l00695"></a>00695   flash_array_end.u8ptr = AVR32_FLASH + <a class="code" href="a00020.html#8071c315b02d038c49fa0bf89a40ba1b">flashc_get_flash_size</a>();
<a name="l00696"></a>00696   dest.u8ptr = dst;
<a name="l00697"></a>00697   <span class="keywordflow">for</span> (i = (Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)) - 1) &amp; (<span class="keyword">sizeof</span>(U64) - 1);
<a name="l00698"></a>00698        src; i = (i - 1) &amp; (<span class="keyword">sizeof</span>(U64) - 1))
<a name="l00699"></a>00699   {
<a name="l00700"></a>00700     source.u8[i] = src;
<a name="l00701"></a>00701     src &gt;&gt;= 8;
<a name="l00702"></a>00702   }
<a name="l00703"></a>00703   dest_end.u8ptr = dest.u8ptr + nbytes;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="comment">// If destination is outside flash, go to next flash page if any.</span>
<a name="l00706"></a>00706   <span class="keywordflow">if</span> (dest.u8ptr &lt; AVR32_FLASH)
<a name="l00707"></a>00707   {
<a name="l00708"></a>00708     dest.u8ptr = AVR32_FLASH;
<a name="l00709"></a>00709   }
<a name="l00710"></a>00710   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
<a name="l00711"></a>00711   {
<a name="l00712"></a>00712     dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l00713"></a>00713   }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   <span class="comment">// If end of destination is outside flash, move it to the end of the previous flash page if any.</span>
<a name="l00716"></a>00716   <span class="keywordflow">if</span> (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
<a name="l00717"></a>00717   {
<a name="l00718"></a>00718     dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
<a name="l00719"></a>00719   }
<a name="l00720"></a>00720   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
<a name="l00721"></a>00721   {
<a name="l00722"></a>00722     dest_end.u8ptr = flash_array_end.u8ptr;
<a name="l00723"></a>00723   }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725   <span class="comment">// Align each end of destination pointer with its natural boundary.</span>
<a name="l00726"></a>00726   dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U16));
<a name="l00727"></a>00727   dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, <span class="keyword">sizeof</span>(U32));
<a name="l00728"></a>00728   dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="comment">// While end of destination is not reached...</span>
<a name="l00731"></a>00731   <span class="keywordflow">while</span> (dest.u8ptr &lt; dest_end.u8ptr)
<a name="l00732"></a>00732   {
<a name="l00733"></a>00733     <span class="comment">// Clear the page buffer in order to prepare data for a flash page write.</span>
<a name="l00734"></a>00734     <a class="code" href="a00020.html#ffafe9cb74731d817b721d2a52093412">flashc_clear_page_buffer</a>();
<a name="l00735"></a>00735     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     <span class="comment">// Determine where the source data will end in the current flash page.</span>
<a name="l00738"></a>00738     flash_page_source_end.u64ptr =
<a name="l00739"></a>00739       (U64 *)min((U32)dest_end.u64ptr,
<a name="l00740"></a>00740                  Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="comment">// Determine if the current destination page has an incomplete end.</span>
<a name="l00743"></a>00743     incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
<a name="l00744"></a>00744                                  Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
<a name="l00745"></a>00745 
<a name="l00746"></a>00746     <span class="comment">// Use a flash double-word buffer to manage unaligned accesses.</span>
<a name="l00747"></a>00747     flash_dword.u64 = source.u64;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="comment">// If destination does not point to the beginning of the current flash page...</span>
<a name="l00750"></a>00750     <span class="keywordflow">if</span> (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
<a name="l00751"></a>00751     {
<a name="l00752"></a>00752       <span class="comment">// If page erase is requested...</span>
<a name="l00753"></a>00753       <span class="keywordflow">if</span> (erase)
<a name="l00754"></a>00754       {
<a name="l00755"></a>00755         <span class="comment">// Fill the beginning of the page buffer with the current flash page data.</span>
<a name="l00756"></a>00756         <span class="keywordflow">for</span> (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
<a name="l00757"></a>00757              tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00758"></a>00758              tmp.u64ptr++)
<a name="l00759"></a>00759           *tmp.u64ptr = *tmp.u64ptr;
<a name="l00760"></a>00760       }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762       <span class="comment">// If destination is not 64-bit aligned...</span>
<a name="l00763"></a>00763       <span class="keywordflow">if</span> (!Test_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l00764"></a>00764       {
<a name="l00765"></a>00765         <span class="comment">// If page erase is requested...</span>
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (erase)
<a name="l00767"></a>00767         {
<a name="l00768"></a>00768           <span class="comment">// Fill the beginning of the flash double-word buffer with the current flash page data.</span>
<a name="l00769"></a>00769           <span class="keywordflow">for</span> (i = 0; i &lt; Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l00770"></a>00770             flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l00771"></a>00771         }
<a name="l00772"></a>00772         <span class="comment">// If page erase is not requested...</span>
<a name="l00773"></a>00773         <span class="keywordflow">else</span>
<a name="l00774"></a>00774         {
<a name="l00775"></a>00775           <span class="comment">// Erase the beginning of the flash double-word buffer.</span>
<a name="l00776"></a>00776           <span class="keywordflow">for</span> (i = 0; i &lt; Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l00777"></a>00777             flash_dword.u8[i] = 0xFF;
<a name="l00778"></a>00778         }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780         <span class="comment">// Align the destination pointer with its 64-bit boundary.</span>
<a name="l00781"></a>00781         dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00782"></a>00782 
<a name="l00783"></a>00783         <span class="comment">// If the current destination double-word is not the last one...</span>
<a name="l00784"></a>00784         <span class="keywordflow">if</span> (dest.u64ptr &lt; dest_end.u64ptr)
<a name="l00785"></a>00785         {
<a name="l00786"></a>00786           <span class="comment">// Write the flash double-word buffer to the page buffer and reinitialize it.</span>
<a name="l00787"></a>00787           *dest.u64ptr++ = flash_dword.u64;
<a name="l00788"></a>00788           flash_dword.u64 = source.u64;
<a name="l00789"></a>00789         }
<a name="l00790"></a>00790       }
<a name="l00791"></a>00791     }
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     <span class="comment">// Write the source data to the page buffer with 64-bit alignment.</span>
<a name="l00794"></a>00794     <span class="keywordflow">for</span> (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l00795"></a>00795       *dest.u64ptr++ = source.u64;
<a name="l00796"></a>00796 
<a name="l00797"></a>00797     <span class="comment">// If the current destination page has an incomplete end...</span>
<a name="l00798"></a>00798     <span class="keywordflow">if</span> (incomplete_flash_page_end)
<a name="l00799"></a>00799     {
<a name="l00800"></a>00800       <span class="comment">// If page erase is requested...</span>
<a name="l00801"></a>00801       <span class="keywordflow">if</span> (erase)
<a name="l00802"></a>00802       {
<a name="l00803"></a>00803         tmp.u8ptr = (<span class="keyword">volatile</span> U8 *)dest_end.u8ptr;
<a name="l00804"></a>00804 
<a name="l00805"></a>00805         <span class="comment">// If end of destination is not 64-bit aligned...</span>
<a name="l00806"></a>00806         if (!Test_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l00807"></a>00807         {
<a name="l00808"></a>00808           <span class="comment">// Fill the end of the flash double-word buffer with the current flash page data.</span>
<a name="l00809"></a>00809           <span class="keywordflow">for</span> (i = Get_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)); i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l00810"></a>00810             flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812           <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l00813"></a>00813           *dest.u64ptr++ = flash_dword.u64;
<a name="l00814"></a>00814         }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816         <span class="comment">// Fill the end of the page buffer with the current flash page data.</span>
<a name="l00817"></a>00817         <span class="keywordflow">for</span> (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
<a name="l00818"></a>00818           *tmp.u64ptr = *tmp.u64ptr;
<a name="l00819"></a>00819       }
<a name="l00820"></a>00820       <span class="comment">// If page erase is not requested but end of destination is not 64-bit aligned...</span>
<a name="l00821"></a>00821       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!Test_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l00822"></a>00822       {
<a name="l00823"></a>00823         <span class="comment">// Erase the end of the flash double-word buffer.</span>
<a name="l00824"></a>00824         <span class="keywordflow">for</span> (i = Get_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)); i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l00825"></a>00825           flash_dword.u8[i] = 0xFF;
<a name="l00826"></a>00826 
<a name="l00827"></a>00827         <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l00828"></a>00828         *dest.u64ptr++ = flash_dword.u64;
<a name="l00829"></a>00829       }
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="comment">// If the current flash page is in the flash array...</span>
<a name="l00833"></a>00833     <span class="keywordflow">if</span> (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
<a name="l00834"></a>00834     {
<a name="l00835"></a>00835       <span class="comment">// Erase the current page if requested and write it from the page buffer.</span>
<a name="l00836"></a>00836       <span class="keywordflow">if</span> (erase)
<a name="l00837"></a>00837       {
<a name="l00838"></a>00838         <a class="code" href="a00020.html#8de3bbd50094f548ca293f07b136cc6d">flashc_erase_page</a>(-1, FALSE);
<a name="l00839"></a>00839         error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00840"></a>00840       }
<a name="l00841"></a>00841       <a class="code" href="a00020.html#a10438433246139bee71da6db2bb5bd5">flashc_write_page</a>(-1);
<a name="l00842"></a>00842       error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00843"></a>00843 
<a name="l00844"></a>00844       <span class="comment">// If the end of the flash array is reached, go to the User page.</span>
<a name="l00845"></a>00845       <span class="keywordflow">if</span> (dest.u8ptr &gt;= flash_array_end.u8ptr)
<a name="l00846"></a>00846         dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848     <span class="comment">// If the current flash page is the User page...</span>
<a name="l00849"></a>00849     <span class="keywordflow">else</span>
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851       <span class="comment">// Erase the User page if requested and write it from the page buffer.</span>
<a name="l00852"></a>00852       <span class="keywordflow">if</span> (erase)
<a name="l00853"></a>00853       {
<a name="l00854"></a>00854         <a class="code" href="a00020.html#2ef66c5ffa0974223c44e151a8719b6d">flashc_erase_user_page</a>(FALSE);
<a name="l00855"></a>00855         error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00856"></a>00856       }
<a name="l00857"></a>00857       <a class="code" href="a00020.html#d04374b721dca9c534d7cd041ae24712">flashc_write_user_page</a>();
<a name="l00858"></a>00858       error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00859"></a>00859     }
<a name="l00860"></a>00860   }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862   <span class="comment">// Update the FLASHC error status.</span>
<a name="l00863"></a>00863   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865   <span class="comment">// Return the initial destination pointer as the standard memset function does.</span>
<a name="l00866"></a>00866   <span class="keywordflow">return</span> dst;
<a name="l00867"></a>00867 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cc5c426d84ce1ef1d2e898e827b23207"></a><!-- doxytag: member="flashc.c::flashc_memset8" ref="cc5c426d84ce1ef1d2e898e827b23207" args="(volatile void *dst, U8 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset8           </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> source byte. 
<p>
The destination areas that are not within the flash array or the User page are ignored.<p>
All pointer and size alignments are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source byte. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00662">662</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00668">flashc_memset16()</a>.<div class="fragment"><pre class="fragment"><a name="l00663"></a>00663 {
<a name="l00664"></a>00664   <span class="keywordflow">return</span> <a class="code" href="a00020.html#1e3ac5049d1eed492678764f8d1efc4b">flashc_memset16</a>(dst, src | (U16)src &lt;&lt; 8, nbytes, erase);
<a name="l00665"></a>00665 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ac955da1ba0b0833d17d3068c34222ec"></a><!-- doxytag: member="flashc.c::flashc_no_operation" ref="ac955da1ba0b0833d17d3068c34222ec" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_no_operation           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Issues a No Operation command to the FLASHC. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00281">281</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.<div class="fragment"><pre class="fragment"><a name="l00282"></a>00282 {
<a name="l00283"></a>00283   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_NOP, -1);
<a name="l00284"></a>00284 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cd50527aacf1d9ae11608fcc49a4fdcf"></a><!-- doxytag: member="flashc.c::flashc_quick_page_read" ref="cd50527aacf1d9ae11608fcc49a4fdcf" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_quick_page_read           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies the Quick Page Read command to a page. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: <ul>
<li><code>0</code> to <code>(<a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the specified page is erased.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00595">595</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00589">flashc_is_page_erased()</a>, and <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00602">flashc_erase_page()</a>.<div class="fragment"><pre class="fragment"><a name="l00596"></a>00596 {
<a name="l00597"></a>00597   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
<a name="l00598"></a>00598   <span class="keywordflow">return</span> <a class="code" href="a00020.html#cdea4bfb0cb1066fba239a9302196ee5">flashc_is_page_erased</a>();
<a name="l00599"></a>00599 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="13ee637e6c10a7bba5d92172ff520a80"></a><!-- doxytag: member="flashc.c::flashc_read_all_gp_fuses" ref="13ee637e6c10a7bba5d92172ff520a80" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 flashc_read_all_gp_fuses           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads all general-purpose fuses. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of all general-purpose fuses as a word. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00414">414</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00463">flashc_erase_all_gp_fuses()</a>, and <a class="el" href="a00045.html#l00443">flashc_erase_gp_fuse_byte()</a>.<div class="fragment"><pre class="fragment"><a name="l00415"></a>00415 {
<a name="l00416"></a>00416   <span class="keywordflow">return</span> AVR32_FLASHC.fgpfr;
<a name="l00417"></a>00417 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e6203d2e69ff15d59366c28bf8e26a7e"></a><!-- doxytag: member="flashc.c::flashc_read_gp_fuse_bit" ref="e6203d2e69ff15d59366c28bf8e26a7e" args="(unsigned int gp_fuse_bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_read_gp_fuse_bit           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a general-purpose fuse bit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>31</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the specified general-purpose fuse bit. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00395">395</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00420">flashc_erase_gp_fuse_bit()</a>, <a class="el" href="a00045.html#l00338">flashc_is_external_privileged_fetch_locked()</a>, <a class="el" href="a00055.html#l00302">is_isp_forced()</a>, and <a class="el" href="a00055.html#l00362">mem_configuration_read()</a>.<div class="fragment"><pre class="fragment"><a name="l00396"></a>00396 {
<a name="l00397"></a>00397   <span class="keywordflow">return</span> ((AVR32_FLASHC.fgpfr &amp; AVR32_FLASHC_FGPFR_GPF00_MASK &lt;&lt; (gp_fuse_bit &amp; 0x1F)) != 0);
<a name="l00398"></a>00398 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="21af75e6beb4675f79c01a019ebc1a46"></a><!-- doxytag: member="flashc.c::flashc_read_gp_fuse_bitfield" ref="21af75e6beb4675f79c01a019ebc1a46" args="(unsigned int pos, unsigned int width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 flashc_read_gp_fuse_bitfield           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a general-purpose fuse bit-field. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>31</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>32</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the specified general-purpose fuse bit-field. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00401">401</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00427">flashc_erase_gp_fuse_bitfield()</a>, and <a class="el" href="a00045.html#l00313">flashc_get_bootloader_protected_size()</a>.<div class="fragment"><pre class="fragment"><a name="l00402"></a>00402 {
<a name="l00403"></a>00403   <span class="keywordflow">return</span> AVR32_FLASHC.fgpfr &gt;&gt; (AVR32_FLASHC_FGPFR_GPF00_OFFSET + (pos &amp; 0x1F)) &amp;
<a name="l00404"></a>00404          ((1 &lt;&lt; min(width, 32)) - 1);
<a name="l00405"></a>00405 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1ad2aab294e528795bbd835539b0b14e"></a><!-- doxytag: member="flashc.c::flashc_read_gp_fuse_byte" ref="1ad2aab294e528795bbd835539b0b14e" args="(unsigned int gp_fuse_byte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 flashc_read_gp_fuse_byte           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a general-purpose fuse byte. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>3</code>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the specified general-purpose fuse byte. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00408">408</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00443">flashc_erase_gp_fuse_byte()</a>.<div class="fragment"><pre class="fragment"><a name="l00409"></a>00409 {
<a name="l00410"></a>00410   <span class="keywordflow">return</span> AVR32_FLASHC.fgpfr &gt;&gt; (AVR32_FLASHC_FGPFR_GPF00_OFFSET + ((gp_fuse_byte &amp; 0x03) &lt;&lt; 3));
<a name="l00411"></a>00411 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="33c3c1b69ddc1a03471d45cd5ecc2c64"></a><!-- doxytag: member="flashc.c::flashc_set_all_gp_fuses" ref="33c3c1b69ddc1a03471d45cd5ecc2c64" args="(U32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_all_gp_fuses           </td>
          <td>(</td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets all general-purpose fuses with the appropriate erase and write operations. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of all general-purpose fuses as a word.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00555">555</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00463">flashc_erase_all_gp_fuses()</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00498">flashc_write_all_gp_fuses()</a>.<div class="fragment"><pre class="fragment"><a name="l00556"></a>00556 {
<a name="l00557"></a>00557   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status;
<a name="l00558"></a>00558   <span class="keywordflow">switch</span> (value)
<a name="l00559"></a>00559   {
<a name="l00560"></a>00560   <span class="keywordflow">case</span> 0xFFFFFFFF:
<a name="l00561"></a>00561     <a class="code" href="a00020.html#cf3096dc9ecea92533c4688d7f90a0ef">flashc_erase_all_gp_fuses</a>(FALSE);
<a name="l00562"></a>00562     <span class="keywordflow">break</span>;
<a name="l00563"></a>00563   <span class="keywordflow">case</span> 0x00000000:
<a name="l00564"></a>00564     <a class="code" href="a00020.html#09f466abd0984884a05c91e8ebb773f9">flashc_write_all_gp_fuses</a>(0x00000000);
<a name="l00565"></a>00565     <span class="keywordflow">break</span>;
<a name="l00566"></a>00566   <span class="keywordflow">default</span>:
<a name="l00567"></a>00567     <a class="code" href="a00020.html#cf3096dc9ecea92533c4688d7f90a0ef">flashc_erase_all_gp_fuses</a>(FALSE);
<a name="l00568"></a>00568     error_status = <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00569"></a>00569     <a class="code" href="a00020.html#09f466abd0984884a05c91e8ebb773f9">flashc_write_all_gp_fuses</a>(value);
<a name="l00570"></a>00570     <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> |= error_status;
<a name="l00571"></a>00571   }
<a name="l00572"></a>00572 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="076a1b22c9f3e6dad1739f0398f89b37"></a><!-- doxytag: member="flashc.c::flashc_set_bootloader_protected_size" ref="076a1b22c9f3e6dad1739f0398f89b37" args="(unsigned int bootprot_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_set_bootloader_protected_size           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>bootprot_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the bootloader protected size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bootprot_size</em>&nbsp;</td><td>The wanted bootloader protected size in bytes. If this size is not supported, the actual size will be the nearest greater available size or the maximal possible size if the requested size is too large.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The actual bootloader protected size in bytes.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00322">322</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00313">flashc_get_bootloader_protected_size()</a>, and <a class="el" href="a00045.html#l00520">flashc_set_gp_fuse_bitfield()</a>.<div class="fragment"><pre class="fragment"><a name="l00323"></a>00323 {
<a name="l00324"></a>00324   <a class="code" href="a00020.html#64e271d0e26dd92933889081ee551bbe">flashc_set_gp_fuse_bitfield</a>(AVR32_FLASHC_FGPFR_BOOTPROT_OFFSET,
<a name="l00325"></a>00325                               AVR32_FLASHC_FGPFR_BOOTPROT_SIZE,
<a name="l00326"></a>00326                               (1 &lt;&lt; AVR32_FLASHC_FGPFR_BOOTPROT_SIZE) - 1 -
<a name="l00327"></a>00327                               ((bootprot_size) ?
<a name="l00328"></a>00328                                32 - clz((((min(max(bootprot_size, AVR32_FLASHC_PAGE_SIZE &lt;&lt; 1),
<a name="l00329"></a>00329                                                AVR32_FLASHC_PAGE_SIZE &lt;&lt;
<a name="l00330"></a>00330                                                ((1 &lt;&lt; AVR32_FLASHC_FGPFR_BOOTPROT_SIZE) - 1)) +
<a name="l00331"></a>00331                                            AVR32_FLASHC_PAGE_SIZE - 1) /
<a name="l00332"></a>00332                                           AVR32_FLASHC_PAGE_SIZE) &lt;&lt; 1) - 1) - 1 :
<a name="l00333"></a>00333                                0));
<a name="l00334"></a>00334   <span class="keywordflow">return</span> <a class="code" href="a00020.html#83ed88a41076163bd29ca80d30cb094f">flashc_get_bootloader_protected_size</a>();
<a name="l00335"></a>00335 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5c5442a988c608baea0d1c0b841badca"></a><!-- doxytag: member="flashc.c::flashc_set_gp_fuse_bit" ref="5c5442a988c608baea0d1c0b841badca" args="(unsigned int gp_fuse_bit, Bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_gp_fuse_bit           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a general-purpose fuse bit with the appropriate erase and write operations. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>31</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00511">511</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00420">flashc_erase_gp_fuse_bit()</a>, and <a class="el" href="a00045.html#l00470">flashc_write_gp_fuse_bit()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00344">flashc_lock_external_privileged_fetch()</a>, <a class="el" href="a00045.html#l00520">flashc_set_gp_fuse_bitfield()</a>, <a class="el" href="a00055.html#l00308">force_isp()</a>, and <a class="el" href="a00055.html#l00370">mem_configuration_write()</a>.<div class="fragment"><pre class="fragment"><a name="l00512"></a>00512 {
<a name="l00513"></a>00513   <span class="keywordflow">if</span> (value)
<a name="l00514"></a>00514     <a class="code" href="a00020.html#3d3494ba9bfe90893f65d2d3d90ab088">flashc_erase_gp_fuse_bit</a>(gp_fuse_bit, FALSE);
<a name="l00515"></a>00515   <span class="keywordflow">else</span>
<a name="l00516"></a>00516     <a class="code" href="a00020.html#52f9456a7effcc28290c3139f7d54bfc">flashc_write_gp_fuse_bit</a>(gp_fuse_bit, FALSE);
<a name="l00517"></a>00517 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="64e271d0e26dd92933889081ee551bbe"></a><!-- doxytag: member="flashc.c::flashc_set_gp_fuse_bitfield" ref="64e271d0e26dd92933889081ee551bbe" args="(unsigned int pos, unsigned int width, U32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_gp_fuse_bitfield           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a general-purpose fuse bit-field with the appropriate erase and write operations. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>31</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>32</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit-field.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00520">520</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00511">flashc_set_gp_fuse_bit()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00322">flashc_set_bootloader_protected_size()</a>.<div class="fragment"><pre class="fragment"><a name="l00521"></a>00521 {
<a name="l00522"></a>00522   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00523"></a>00523   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_bit;
<a name="l00524"></a>00524   pos &amp;= 0x1F;
<a name="l00525"></a>00525   width = min(width, 32);
<a name="l00526"></a>00526   <span class="keywordflow">for</span> (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
<a name="l00527"></a>00527   {
<a name="l00528"></a>00528     <a class="code" href="a00020.html#5c5442a988c608baea0d1c0b841badca">flashc_set_gp_fuse_bit</a>(gp_fuse_bit, value &amp; 0x01);
<a name="l00529"></a>00529     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00530"></a>00530   }
<a name="l00531"></a>00531   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00532"></a>00532 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cda1125f62193f69c24c0e4975e95b4d"></a><!-- doxytag: member="flashc.c::flashc_set_gp_fuse_byte" ref="cda1125f62193f69c24c0e4975e95b4d" args="(unsigned int gp_fuse_byte, U8 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_gp_fuse_byte           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a general-purpose fuse byte with the appropriate erase and write operations. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>3</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse byte.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00535">535</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00443">flashc_erase_gp_fuse_byte()</a>, <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00492">flashc_write_gp_fuse_byte()</a>.<div class="fragment"><pre class="fragment"><a name="l00536"></a>00536 {
<a name="l00537"></a>00537   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status;
<a name="l00538"></a>00538   <span class="keywordflow">switch</span> (value)
<a name="l00539"></a>00539   {
<a name="l00540"></a>00540   <span class="keywordflow">case</span> 0xFF:
<a name="l00541"></a>00541     <a class="code" href="a00020.html#293468b5d263ffe7f9a2595c900a9293">flashc_erase_gp_fuse_byte</a>(gp_fuse_byte, FALSE);
<a name="l00542"></a>00542     <span class="keywordflow">break</span>;
<a name="l00543"></a>00543   <span class="keywordflow">case</span> 0x00:
<a name="l00544"></a>00544     <a class="code" href="a00020.html#7670e69d41fe6a985ad898be25044caf">flashc_write_gp_fuse_byte</a>(gp_fuse_byte, 0x00);
<a name="l00545"></a>00545     <span class="keywordflow">break</span>;
<a name="l00546"></a>00546   <span class="keywordflow">default</span>:
<a name="l00547"></a>00547     <a class="code" href="a00020.html#293468b5d263ffe7f9a2595c900a9293">flashc_erase_gp_fuse_byte</a>(gp_fuse_byte, FALSE);
<a name="l00548"></a>00548     error_status = <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00549"></a>00549     <a class="code" href="a00020.html#7670e69d41fe6a985ad898be25044caf">flashc_write_gp_fuse_byte</a>(gp_fuse_byte, value);
<a name="l00550"></a>00550     <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> |= error_status;
<a name="l00551"></a>00551   }
<a name="l00552"></a>00552 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2835c7ef58f410290ad530d34d7e8133"></a><!-- doxytag: member="flashc.c::flashc_set_wait_state" ref="2835c7ef58f410290ad530d34d7e8133" args="(unsigned int wait_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_wait_state           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>wait_state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the number of wait states of flash read accesses. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wait_state</em>&nbsp;</td><td>The number of wait states of flash read accesses: <code>0</code> to <code>1</code>. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00045.html#l00130">130</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00058">u_avr32_flashc_fcr_t::FCR</a>, and <a class="el" href="a00045.html#l00057">u_avr32_flashc_fcr_t::fcr</a>.
<p>
Referenced by <a class="el" href="a00049.html#l00076">sys_clk_gen_start()</a>, and <a class="el" href="a00049.html#l00174">sys_clk_gen_stop()</a>.<div class="fragment"><pre class="fragment"><a name="l00131"></a>00131 {
<a name="l00132"></a>00132   <a class="code" href="a00015.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00133"></a>00133   u_avr32_flashc_fcr.<a class="code" href="a00015.html#a8f3a48553db579f2272c10a5ad2c710">FCR</a>.fws = wait_state;
<a name="l00134"></a>00134   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00015.html#4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00135"></a>00135 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="09f466abd0984884a05c91e8ebb773f9"></a><!-- doxytag: member="flashc.c::flashc_write_all_gp_fuses" ref="09f466abd0984884a05c91e8ebb773f9" args="(U32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_all_gp_fuses           </td>
          <td>(</td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes all general-purpose fuses. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of all general-purpose fuses as a word.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
A write operation can only clear bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00498">498</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00492">flashc_write_gp_fuse_byte()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00555">flashc_set_all_gp_fuses()</a>.<div class="fragment"><pre class="fragment"><a name="l00499"></a>00499 {
<a name="l00500"></a>00500   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00501"></a>00501   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_byte;
<a name="l00502"></a>00502   <span class="keywordflow">for</span> (gp_fuse_byte = 0; gp_fuse_byte &lt; 4; gp_fuse_byte++, value &gt;&gt;= 8)
<a name="l00503"></a>00503   {
<a name="l00504"></a>00504     <a class="code" href="a00020.html#7670e69d41fe6a985ad898be25044caf">flashc_write_gp_fuse_byte</a>(gp_fuse_byte, value);
<a name="l00505"></a>00505     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00506"></a>00506   }
<a name="l00507"></a>00507   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00508"></a>00508 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="52f9456a7effcc28290c3139f7d54bfc"></a><!-- doxytag: member="flashc.c::flashc_write_gp_fuse_bit" ref="52f9456a7effcc28290c3139f7d54bfc" args="(unsigned int gp_fuse_bit, Bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_gp_fuse_bit           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a general-purpose fuse bit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>31</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
A write operation can only clear bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00470">470</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00511">flashc_set_gp_fuse_bit()</a>, and <a class="el" href="a00045.html#l00477">flashc_write_gp_fuse_bitfield()</a>.<div class="fragment"><pre class="fragment"><a name="l00471"></a>00471 {
<a name="l00472"></a>00472   <span class="keywordflow">if</span> (!value)
<a name="l00473"></a>00473     <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_WGPB, gp_fuse_bit &amp; 0x1F);
<a name="l00474"></a>00474 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="af0b1e05809805510132d8e6eb761fdd"></a><!-- doxytag: member="flashc.c::flashc_write_gp_fuse_bitfield" ref="af0b1e05809805510132d8e6eb761fdd" args="(unsigned int pos, unsigned int width, U32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_gp_fuse_bitfield           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a general-purpose fuse bit-field. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>31</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>32</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit-field.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
A write operation can only clear bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00477">477</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00224">flashc_error_status</a>, and <a class="el" href="a00045.html#l00470">flashc_write_gp_fuse_bit()</a>.<div class="fragment"><pre class="fragment"><a name="l00478"></a>00478 {
<a name="l00479"></a>00479   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00480"></a>00480   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_bit;
<a name="l00481"></a>00481   pos &amp;= 0x1F;
<a name="l00482"></a>00482   width = min(width, 32);
<a name="l00483"></a>00483   <span class="keywordflow">for</span> (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
<a name="l00484"></a>00484   {
<a name="l00485"></a>00485     <a class="code" href="a00020.html#52f9456a7effcc28290c3139f7d54bfc">flashc_write_gp_fuse_bit</a>(gp_fuse_bit, value &amp; 0x01);
<a name="l00486"></a>00486     error_status |= <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a>;
<a name="l00487"></a>00487   }
<a name="l00488"></a>00488   <a class="code" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = error_status;
<a name="l00489"></a>00489 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7670e69d41fe6a985ad898be25044caf"></a><!-- doxytag: member="flashc.c::flashc_write_gp_fuse_byte" ref="7670e69d41fe6a985ad898be25044caf" args="(unsigned int gp_fuse_byte, U8 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_gp_fuse_byte           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a general-purpose fuse byte. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>3</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse byte.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
A write operation can only clear bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00492">492</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00443">flashc_erase_gp_fuse_byte()</a>, <a class="el" href="a00045.html#l00535">flashc_set_gp_fuse_byte()</a>, and <a class="el" href="a00045.html#l00498">flashc_write_all_gp_fuses()</a>.<div class="fragment"><pre class="fragment"><a name="l00493"></a>00493 {
<a name="l00494"></a>00494   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_PGPFB, (gp_fuse_byte &amp; 0x03) | value &lt;&lt; 2);
<a name="l00495"></a>00495 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a10438433246139bee71da6db2bb5bd5"></a><!-- doxytag: member="flashc.c::flashc_write_page" ref="a10438433246139bee71da6db2bb5bd5" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_page           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a page from the page buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: <ul>
<li><code>0</code> to <code>(<a class="el" href="a00020.html#afad0dcf645cc65acb5bc879558dac23">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to a page belonging to a locked region or to the bootloader protected area.<p>
The page buffer is not automatically reset after a page write.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
A write operation can only clear bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00631">631</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00680">flashc_memset64()</a>.<div class="fragment"><pre class="fragment"><a name="l00632"></a>00632 {
<a name="l00633"></a>00633   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_WP, page_number);
<a name="l00634"></a>00634 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d04374b721dca9c534d7cd041ae24712"></a><!-- doxytag: member="flashc.c::flashc_write_user_page" ref="d04374b721dca9c534d7cd041ae24712" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_user_page           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the User page from the page buffer. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The page buffer is not automatically reset after a page write.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00021.html#a5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00021.html#2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.<p>
A write operation can only clear bits. </dd></dl>

<p>
Definition at line <a class="el" href="a00045.html#l00656">656</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
References <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00680">flashc_memset64()</a>.<div class="fragment"><pre class="fragment"><a name="l00657"></a>00657 {
<a name="l00658"></a>00658   <a class="code" href="a00020.html#8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_WUP, -1);
<a name="l00659"></a>00659 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="f22dcfb635e7fa6bf926dc810e40d6be"></a><!-- doxytag: member="flashc.c::flashc_error_status" ref="f22dcfb635e7fa6bf926dc810e40d6be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a00020.html#f22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = 0<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sticky error status of the FLASHC. 
<p>
This variable is updated by functions that issue FLASHC commands. It contains the cumulated FLASHC error status of all the FLASHC commands issued by a function. 
<p>
Definition at line <a class="el" href="a00045.html#l00224">224</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00616">flashc_erase_all_pages()</a>, <a class="el" href="a00045.html#l00427">flashc_erase_gp_fuse_bitfield()</a>, <a class="el" href="a00045.html#l00443">flashc_erase_gp_fuse_byte()</a>, <a class="el" href="a00045.html#l00602">flashc_erase_page()</a>, <a class="el" href="a00045.html#l00227">flashc_is_lock_error()</a>, <a class="el" href="a00045.html#l00233">flashc_is_programming_error()</a>, <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>, <a class="el" href="a00045.html#l00374">flashc_lock_all_regions()</a>, <a class="el" href="a00045.html#l00870">flashc_memcpy()</a>, <a class="el" href="a00045.html#l00680">flashc_memset64()</a>, <a class="el" href="a00045.html#l00555">flashc_set_all_gp_fuses()</a>, <a class="el" href="a00045.html#l00520">flashc_set_gp_fuse_bitfield()</a>, <a class="el" href="a00045.html#l00535">flashc_set_gp_fuse_byte()</a>, <a class="el" href="a00045.html#l00498">flashc_write_all_gp_fuses()</a>, and <a class="el" href="a00045.html#l00477">flashc_write_gp_fuse_bitfield()</a>.
</div>
</div><p>
<a class="anchor" name="c293397096f61bb5c2400792f3b39c0f"></a><!-- doxytag: member="flashc.c::flashc_wait_until_ready" ref="c293397096f61bb5c2400792f3b39c0f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*volatile) <a class="el" href="a00021.html#c293397096f61bb5c2400792f3b39c0f">flashc_wait_until_ready</a>(void) = flashc_default_wait_until_ready          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to the function used by the driver when it needs to wait until the FLASHC is ready to run a new command. 
<p>
The default function is <a class="el" href="a00021.html#ca88002d64a494ca5b796b592834369d">flashc_default_wait_until_ready</a>. The user may change this pointer to use another implementation. 
<p>
Definition at line <a class="el" href="a00045.html#l00200">200</a> of file <a class="el" href="a00045.html">flashc.c</a>.
<p>
Referenced by <a class="el" href="a00045.html#l00259">flashc_issue_command()</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Sep 20 12:17:25 2007 for AVR32 - USB DFU Example: ISP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
