<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR32 - AT45DBX Data Flash Driver: at45dbx.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>at45dbx.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Management of the AT45DBX data flash controller through SPI. 
<p>
This file manages the accesses to the AT45DBX data flash components.<p>
<ul>
<li>Compiler: IAR EWAVR32 and GNU GCC for AVR32</li><li>Supported devices: All AVR32 devices with an SPI module can be used.</li><li>AppNote:</li></ul>
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support and FAQ: <a href="http://support.atmel.no/">http://support.atmel.no/</a> </dd></dl>

<p>
Definition in file <a class="el" href="a00020.html">at45dbx.h</a>.
<p>
<code>#include &quot;<a class="el" href="a00024.html">conf_access.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="a00029.html">spi.h</a>&quot;</code><br>

<p>
<a href="a00020.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#f403d899ed2618ee9541443f49034266">AT45DBX_SECTOR_BITS</a>&nbsp;&nbsp;&nbsp;9</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of bits for addresses within sectors.  <a href="#f403d899ed2618ee9541443f49034266"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; AT45DBX_SECTOR_BITS)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sector size in bytes.  <a href="#e29e3481c115b344aa2d45f0751c4ab9"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Available AT45DBX Sizes</div></td></tr>
<tr><td colspan="2"><div class="groupText">Number of address bits of available AT45DBX data flash memories.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only memories with page sizes of at least 512 bytes (sector size) are supported. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ef511acbc4868c6fc638816657ee4502">AT45DBX_2MB</a>&nbsp;&nbsp;&nbsp;21</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#3b5ca27708b7b4ed4983f8cfb53e8733">AT45DBX_4MB</a>&nbsp;&nbsp;&nbsp;22</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#b4f8b12552e58be832a54a09cea186d4">AT45DBX_8MB</a>&nbsp;&nbsp;&nbsp;23</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Control Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#10af87406c978dddd99ee3b7fc91316e">at45dbx_init</a> (<a class="el" href="a00001.html">spi_options_t</a> spiOptions, unsigned int pba_hz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the data flash controller and the SPI channel by which the DF is controlled.  <a href="#10af87406c978dddd99ee3b7fc91316e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#5b5319976e7ddf1cfae43cc37db1e0be">at45dbx_mem_check</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a memory check on all DFs.  <a href="#5b5319976e7ddf1cfae43cc37db1e0be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#9ce78736f903433296343e97968af883">at45dbx_read_close</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unselects the current DF memory.  <a href="#9ce78736f903433296343e97968af883"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#c003b62656f4d90d71ba4c9cbce6a1ef">at45dbx_read_open</a> (U32 sector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a DF memory in read mode at a given sector.  <a href="#c003b62656f4d90d71ba4c9cbce6a1ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#283989acaf1e876fb002ad0292c1b4cc">at45dbx_write_close</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the end of the current logical sector and launches page programming.  <a href="#283989acaf1e876fb002ad0292c1b4cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#e5630db4f5d2a58f14b1247e8701c588">at45dbx_write_open</a> (U32 sector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function opens a DF memory in write mode at a given sector.  <a href="#e5630db4f5d2a58f14b1247e8701c588"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Single-Byte Access Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#5ba257081b9835afca62a6b5fe2ccbb9">at45dbx_read_byte</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a single byte read from DF memory.  <a href="#5ba257081b9835afca62a6b5fe2ccbb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#0b9835fceedaec0045b180918d876927">at45dbx_write_byte</a> (U8 b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a single byte write to DF memory.  <a href="#0b9835fceedaec0045b180918d876927"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiple-Sector Access Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#62c631d1bbf6e9536c0041278bfcb8f4">at45dbx_read_multiple_sector</a> (U16 nb_sector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads <em>nb_sector</em> sectors from DF memory.  <a href="#62c631d1bbf6e9536c0041278bfcb8f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#649a7b008b9a5323034d7ffb930f93d5">at45dbx_read_multiple_sector_callback</a> (const void *psector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function invoked after each sector read during <a class="el" href="a00009.html#62c631d1bbf6e9536c0041278bfcb8f4">at45dbx_read_multiple_sector</a>.  <a href="#649a7b008b9a5323034d7ffb930f93d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#300234c5107dcc9deb92d01c4afe31fa">at45dbx_write_multiple_sector</a> (U16 nb_sector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes <em>nb_sector</em> sectors to DF memory.  <a href="#300234c5107dcc9deb92d01c4afe31fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#8c8592dd952ff02a8f2cd69f9a633ebb">at45dbx_write_multiple_sector_callback</a> (void *psector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function invoked before each sector write during <a class="el" href="a00009.html#300234c5107dcc9deb92d01c4afe31fa">at45dbx_write_multiple_sector</a>.  <a href="#8c8592dd952ff02a8f2cd69f9a633ebb"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Single-Sector Access Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#617cf35058ba73aaa3d8a3f37dc058d3">at45dbx_read_sector_2_ram</a> (void *ram)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads 1 DF sector to a RAM buffer.  <a href="#617cf35058ba73aaa3d8a3f37dc058d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#203fce44573d526f4fd833d3752ecd67">at45dbx_write_sector_from_ram</a> (const void *ram)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes 1 DF sector from a RAM buffer.  <a href="#203fce44573d526f4fd833d3752ecd67"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ef511acbc4868c6fc638816657ee4502"></a><!-- doxytag: member="at45dbx.h::AT45DBX_2MB" ref="ef511acbc4868c6fc638816657ee4502" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT45DBX_2MB&nbsp;&nbsp;&nbsp;21          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00020.html#l00069">69</a> of file <a class="el" href="a00020.html">at45dbx.h</a>.
</div>
</div><p>
<a class="anchor" name="3b5ca27708b7b4ed4983f8cfb53e8733"></a><!-- doxytag: member="at45dbx.h::AT45DBX_4MB" ref="3b5ca27708b7b4ed4983f8cfb53e8733" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT45DBX_4MB&nbsp;&nbsp;&nbsp;22          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00020.html#l00070">70</a> of file <a class="el" href="a00020.html">at45dbx.h</a>.
</div>
</div><p>
<a class="anchor" name="b4f8b12552e58be832a54a09cea186d4"></a><!-- doxytag: member="at45dbx.h::AT45DBX_8MB" ref="b4f8b12552e58be832a54a09cea186d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT45DBX_8MB&nbsp;&nbsp;&nbsp;23          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00020.html#l00071">71</a> of file <a class="el" href="a00020.html">at45dbx.h</a>.
</div>
</div><p>
<a class="anchor" name="f403d899ed2618ee9541443f49034266"></a><!-- doxytag: member="at45dbx.h::AT45DBX_SECTOR_BITS" ref="f403d899ed2618ee9541443f49034266" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT45DBX_SECTOR_BITS&nbsp;&nbsp;&nbsp;9          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of bits for addresses within sectors. 
<p>

<p>
Definition at line <a class="el" href="a00020.html#l00075">75</a> of file <a class="el" href="a00020.html">at45dbx.h</a>.
<p>
Referenced by <a class="el" href="a00022.html#l00188">at45dbx_df_2_ram()</a>, <a class="el" href="a00022.html#l00200">at45dbx_ram_2_df()</a>, <a class="el" href="a00019.html#l00438">at45dbx_read_byte()</a>, <a class="el" href="a00022.html#l00080">at45dbx_read_capacity()</a>, <a class="el" href="a00019.html#l00300">at45dbx_read_open()</a>, <a class="el" href="a00019.html#l00548">at45dbx_read_sector_2_ram()</a>, <a class="el" href="a00022.html#l00114">at45dbx_usb_read_10()</a>, <a class="el" href="a00022.html#l00143">at45dbx_usb_write_10()</a>, <a class="el" href="a00019.html#l00475">at45dbx_write_byte()</a>, <a class="el" href="a00019.html#l00351">at45dbx_write_open()</a>, and <a class="el" href="a00019.html#l00596">at45dbx_write_sector_from_ram()</a>.
</div>
</div><p>
<a class="anchor" name="e29e3481c115b344aa2d45f0751c4ab9"></a><!-- doxytag: member="at45dbx.h::AT45DBX_SECTOR_SIZE" ref="e29e3481c115b344aa2d45f0751c4ab9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AT45DBX_SECTOR_SIZE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; AT45DBX_SECTOR_BITS)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sector size in bytes. 
<p>

<p>
Definition at line <a class="el" href="a00020.html#l00078">78</a> of file <a class="el" href="a00020.html">at45dbx.h</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00214">at45dbx_example_test_RAM_mem()</a>, <a class="el" href="a00021.html#l00317">at45dbx_read_multiple_sector_callback()</a>, <a class="el" href="a00019.html#l00548">at45dbx_read_sector_2_ram()</a>, <a class="el" href="a00021.html#l00309">at45dbx_write_multiple_sector_callback()</a>, and <a class="el" href="a00019.html#l00596">at45dbx_write_sector_from_ram()</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="10af87406c978dddd99ee3b7fc91316e"></a><!-- doxytag: member="at45dbx.h::at45dbx_init" ref="10af87406c978dddd99ee3b7fc91316e" args="(spi_options_t spiOptions, unsigned int pba_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00001.html">spi_options_t</a>&nbsp;</td>
          <td class="paramname"> <em>spiOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the data flash controller and the SPI channel by which the DF is controlled. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spiOptions</em>&nbsp;</td><td>Initialization options of the DF SPI channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>SPI module input clock frequency (PBA clock, Hz).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00019.html#l00209">209</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00025.html#l00065">AT45DBX_MEM_CNT</a>, <a class="el" href="a00025.html#l00069">AT45DBX_SPI_FIRST_NPCS</a>, <a class="el" href="a00029.html#l00072">spi_options_t::reg</a>, <a class="el" href="a00018.html#856ecadf3d7fe18c4fc3ae56500f89822b1fe832bba9b2799c09ddec72f7df75">SPI_OK</a>, and <a class="el" href="a00028.html#l00264">spi_setupChipReg()</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00337">at45dbx_resources_init()</a>.<div class="fragment"><pre class="fragment"><a name="l00210"></a>00210 {
<a name="l00211"></a>00211   <span class="comment">// Setup SPI registers according to spiOptions.</span>
<a name="l00212"></a>00212   <span class="keywordflow">for</span> (spiOptions.<a class="code" href="a00001.html#1e6dfa9b370d7e4f0b4e8d6cb75835a5">reg</a> = <a class="code" href="a00014.html#fbbae7cb25f217be527151be186e6deb">AT45DBX_SPI_FIRST_NPCS</a>;
<a name="l00213"></a>00213        spiOptions.<a class="code" href="a00001.html#1e6dfa9b370d7e4f0b4e8d6cb75835a5">reg</a> &lt; <a class="code" href="a00014.html#fbbae7cb25f217be527151be186e6deb">AT45DBX_SPI_FIRST_NPCS</a> + <a class="code" href="a00014.html#265f0e24294e8a8f6800f6d171b06601">AT45DBX_MEM_CNT</a>;
<a name="l00214"></a>00214        spiOptions.<a class="code" href="a00001.html#1e6dfa9b370d7e4f0b4e8d6cb75835a5">reg</a>++)
<a name="l00215"></a>00215   {
<a name="l00216"></a>00216     <span class="keywordflow">if</span> (<a class="code" href="a00017.html#a7f7310b35b18230075e4622a3ddee3e">spi_setupChipReg</a>(AT45DBX_SPI, &amp;spiOptions, pba_hz) != <a class="code" href="a00018.html#856ecadf3d7fe18c4fc3ae56500f89822b1fe832bba9b2799c09ddec72f7df75">SPI_OK</a>) <span class="keywordflow">return</span> KO;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="comment">// Memory ready.</span>
<a name="l00220"></a>00220   <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = FALSE;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222   <span class="keywordflow">return</span> OK;
<a name="l00223"></a>00223 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5b5319976e7ddf1cfae43cc37db1e0be"></a><!-- doxytag: member="at45dbx.h::at45dbx_mem_check" ref="5b5319976e7ddf1cfae43cc37db1e0be" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_mem_check           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a memory check on all DFs. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00019.html#l00246">246</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00019.html#l00112">AT45DBX_CMDC_RD_STATUS_REG</a>, <a class="el" href="a00025.html#l00065">AT45DBX_MEM_CNT</a>, <a class="el" href="a00019.html#l00136">AT45DBX_MSK_DENSITY</a>, <a class="el" href="a00028.html#l00394">spi_read()</a>, <a class="el" href="a00028.html#l00343">spi_write()</a>, and <a class="el" href="a00019.html#l00191">spi_write_dummy</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00140">at45dbx_example_check_mem()</a>, and <a class="el" href="a00022.html#l00074">at45dbx_test_unit_ready()</a>.<div class="fragment"><pre class="fragment"><a name="l00247"></a>00247 {
<a name="l00248"></a>00248   U8 df;
<a name="l00249"></a>00249   U16 status;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="comment">// DF memory check.</span>
<a name="l00252"></a>00252   <span class="keywordflow">for</span> (df = 0; df &lt; <a class="code" href="a00014.html#265f0e24294e8a8f6800f6d171b06601">AT45DBX_MEM_CNT</a>; df++)
<a name="l00253"></a>00253   {
<a name="l00254"></a>00254     <span class="comment">// Select the DF memory to check.</span>
<a name="l00255"></a>00255     <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(df, TRUE);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="comment">// Send the Status Register Read command.</span>
<a name="l00258"></a>00258     <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, <a class="code" href="a00008.html#bb6b2f48e7fb582baaeb1e9293d5874f">AT45DBX_CMDC_RD_STATUS_REG</a>);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     <span class="comment">// Send a dummy byte to read the status register.</span>
<a name="l00261"></a>00261     <a class="code" href="a00008.html#aad80751cb014549d0dcc5e9166b9426">spi_write_dummy</a>();
<a name="l00262"></a>00262     <a class="code" href="a00017.html#ba67d4cedf75b3afc90aaadc86a23c07">spi_read</a>(AT45DBX_SPI, &amp;status);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     <span class="comment">// Unselect the checked DF memory.</span>
<a name="l00265"></a>00265     <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(df, FALSE);
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     <span class="comment">// Unexpected device density value.</span>
<a name="l00268"></a>00268     <span class="keywordflow">if</span> ((status &amp; <a class="code" href="a00008.html#1ce8990db7d81496ba63c0c3dbc03c8e">AT45DBX_MSK_DENSITY</a>) &lt; AT45DBX_DENSITY) <span class="keywordflow">return</span> KO;
<a name="l00269"></a>00269   }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   <span class="keywordflow">return</span> OK;
<a name="l00272"></a>00272 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5ba257081b9835afca62a6b5fe2ccbb9"></a><!-- doxytag: member="at45dbx.h::at45dbx_read_byte" ref="5ba257081b9835afca62a6b5fe2ccbb9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 at45dbx_read_byte           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a single byte read from DF memory. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The read byte.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>First call must be preceded by a call to the <a class="el" href="a00009.html#c003b62656f4d90d71ba4c9cbce6a1ef">at45dbx_read_open</a> function. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00438">438</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, <a class="el" href="a00019.html#l00180">AT45DBX_MSK_PTR_BYTE</a>, <a class="el" href="a00019.html#l00300">at45dbx_read_open()</a>, <a class="el" href="a00020.html#l00075">AT45DBX_SECTOR_BITS</a>, <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>, <a class="el" href="a00028.html#l00394">spi_read()</a>, and <a class="el" href="a00019.html#l00191">spi_write_dummy</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00157">at45dbx_example_test_byte_mem()</a>.<div class="fragment"><pre class="fragment"><a name="l00439"></a>00439 {
<a name="l00440"></a>00440   U16 data;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442   <span class="comment">// Memory busy.</span>
<a name="l00443"></a>00443   <span class="keywordflow">if</span> (<a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a>)
<a name="l00444"></a>00444   {
<a name="l00445"></a>00445     <span class="comment">// Being here, we know that we previously finished a page read.</span>
<a name="l00446"></a>00446     <span class="comment">// =&gt; We have to access the next page.</span>
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="comment">// Memory ready.</span>
<a name="l00449"></a>00449     <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = FALSE;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451     <span class="comment">// Eventually select the next DF and open the next page.</span>
<a name="l00452"></a>00452     <span class="comment">// NOTE: at45dbx_read_open input parameter is a sector.</span>
<a name="l00453"></a>00453     <a class="code" href="a00008.html#c003b62656f4d90d71ba4c9cbce6a1ef">at45dbx_read_open</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00009.html#f403d899ed2618ee9541443f49034266">AT45DBX_SECTOR_BITS</a>); <span class="comment">// gl_ptr_mem / AT45DBX_SECTOR_SIZE.</span>
<a name="l00454"></a>00454   }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456   <span class="comment">// Send a dummy byte to read the next data byte.</span>
<a name="l00457"></a>00457   <a class="code" href="a00008.html#aad80751cb014549d0dcc5e9166b9426">spi_write_dummy</a>();
<a name="l00458"></a>00458   <a class="code" href="a00017.html#ba67d4cedf75b3afc90aaadc86a23c07">spi_read</a>(AT45DBX_SPI, &amp;data);
<a name="l00459"></a>00459   <a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>++;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">// If end of page reached,</span>
<a name="l00462"></a>00462   <span class="keywordflow">if</span> (!Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#9fe22bf13aaae864efa1b9d2e14dbc15">AT45DBX_MSK_PTR_BYTE</a>))
<a name="l00463"></a>00463   {
<a name="l00464"></a>00464     <span class="comment">// unselect the DF memory gl_ptr_mem points to.</span>
<a name="l00465"></a>00465     <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, FALSE);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     <span class="comment">// Memory busy.</span>
<a name="l00468"></a>00468     <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = TRUE;
<a name="l00469"></a>00469   }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <span class="keywordflow">return</span> data;
<a name="l00472"></a>00472 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9ce78736f903433296343e97968af883"></a><!-- doxytag: member="at45dbx.h::at45dbx_read_close" ref="9ce78736f903433296343e97968af883" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void at45dbx_read_close           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unselects the current DF memory. 
<p>

<p>
Definition at line <a class="el" href="a00019.html#l00341">341</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, and <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>.
<p>
Referenced by <a class="el" href="a00022.html#l00188">at45dbx_df_2_ram()</a>, <a class="el" href="a00021.html#l00157">at45dbx_example_test_byte_mem()</a>, <a class="el" href="a00021.html#l00276">at45dbx_example_test_multiple_sector()</a>, <a class="el" href="a00021.html#l00214">at45dbx_example_test_RAM_mem()</a>, and <a class="el" href="a00022.html#l00114">at45dbx_usb_read_10()</a>.<div class="fragment"><pre class="fragment"><a name="l00342"></a>00342 {
<a name="l00343"></a>00343   <span class="comment">// Unselect the DF memory gl_ptr_mem points to.</span>
<a name="l00344"></a>00344   <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, FALSE);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <span class="comment">// Memory ready.</span>
<a name="l00347"></a>00347   <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = FALSE;
<a name="l00348"></a>00348 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="62c631d1bbf6e9536c0041278bfcb8f4"></a><!-- doxytag: member="at45dbx.h::at45dbx_read_multiple_sector" ref="62c631d1bbf6e9536c0041278bfcb8f4" args="(U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_read_multiple_sector           </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads <em>nb_sector</em> sectors from DF memory. 
<p>
Data flow is: DF -&gt; callback.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>Number of contiguous sectors to read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>First call must be preceded by a call to the <a class="el" href="a00009.html#c003b62656f4d90d71ba4c9cbce6a1ef">at45dbx_read_open</a> function.<p>
As <a class="el" href="a00008.html#18a68b3fc9d201b37cac0e4da3c37ccf">AT45DBX_PAGE_SIZE</a> is always a multiple of <a class="el" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>, there is no need to check page end for each byte. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00514">514</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00022.html#l00126">at45dbx_read_multiple_sector_callback()</a>, <a class="el" href="a00019.html#l00548">at45dbx_read_sector_2_ram()</a>, and <a class="el" href="a00019.html#l00201">sector_buf</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00276">at45dbx_example_test_multiple_sector()</a>, and <a class="el" href="a00022.html#l00114">at45dbx_usb_read_10()</a>.<div class="fragment"><pre class="fragment"><a name="l00515"></a>00515 {
<a name="l00516"></a>00516   <span class="keywordflow">while</span> (nb_sector--)
<a name="l00517"></a>00517   {
<a name="l00518"></a>00518     <span class="comment">// Read the next sector.</span>
<a name="l00519"></a>00519     <a class="code" href="a00008.html#617cf35058ba73aaa3d8a3f37dc058d3">at45dbx_read_sector_2_ram</a>(<a class="code" href="a00008.html#599ab5dd05eb386b517ba893f65075e5">sector_buf</a>);
<a name="l00520"></a>00520     <a class="code" href="a00009.html#649a7b008b9a5323034d7ffb930f93d5">at45dbx_read_multiple_sector_callback</a>(<a class="code" href="a00008.html#599ab5dd05eb386b517ba893f65075e5">sector_buf</a>);
<a name="l00521"></a>00521   }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="keywordflow">return</span> OK;
<a name="l00524"></a>00524 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="649a7b008b9a5323034d7ffb930f93d5"></a><!-- doxytag: member="at45dbx.h::at45dbx_read_multiple_sector_callback" ref="649a7b008b9a5323034d7ffb930f93d5" args="(const void *psector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void at45dbx_read_multiple_sector_callback           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>psector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback function invoked after each sector read during <a class="el" href="a00009.html#62c631d1bbf6e9536c0041278bfcb8f4">at45dbx_read_multiple_sector</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psector</em>&nbsp;</td><td>Pointer to read sector. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00022.html#l00126">126</a> of file <a class="el" href="a00022.html">at45dbx_mem.c</a>.
<p>
References <a class="el" href="a00021.html#l00135">at45dbx_example_error_cnt</a>, <a class="el" href="a00020.html#l00078">AT45DBX_SECTOR_SIZE</a>, and <a class="el" href="a00021.html#l00131">PATTERN_MULTIPLE_SECTOR</a>.
<p>
Referenced by <a class="el" href="a00019.html#l00514">at45dbx_read_multiple_sector()</a>.<div class="fragment"><pre class="fragment"><a name="l00127"></a>00127 {
<a name="l00128"></a>00128   U16 data_to_transfer = <a class="code" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="comment">// Transfer read sector to the USB interface.</span>
<a name="l00131"></a>00131   <span class="keywordflow">while</span> (data_to_transfer)
<a name="l00132"></a>00132   {
<a name="l00133"></a>00133     <span class="keywordflow">while</span> (!Is_usb_in_ready(g_scsi_ep_ms_in));
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     Usb_reset_endpoint_fifo_access(g_scsi_ep_ms_in);
<a name="l00136"></a>00136     data_to_transfer = usb_write_ep_txpacket(g_scsi_ep_ms_in, psector,
<a name="l00137"></a>00137                                              data_to_transfer, &amp;psector);
<a name="l00138"></a>00138     Usb_ack_in_ready_send(g_scsi_ep_ms_in);
<a name="l00139"></a>00139   }
<a name="l00140"></a>00140 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c003b62656f4d90d71ba4c9cbce6a1ef"></a><!-- doxytag: member="at45dbx.h::at45dbx_read_open" ref="c003b62656f4d90d71ba4c9cbce6a1ef" args="(U32 sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_read_open           </td>
          <td>(</td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>sector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a DF memory in read mode at a given sector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>Start sector.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Sector may be page-unaligned (depending on the DF page size). </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00300">300</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00019.html#l00071">AT45DBX_CMDA_RD_PAGE</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, <a class="el" href="a00019.html#l00180">AT45DBX_MSK_PTR_BYTE</a>, <a class="el" href="a00019.html#l00183">AT45DBX_MSK_PTR_PAGE</a>, <a class="el" href="a00020.html#l00075">AT45DBX_SECTOR_BITS</a>, <a class="el" href="a00019.html#l00277">at45dbx_wait_ready()</a>, <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>, <a class="el" href="a00028.html#l00343">spi_write()</a>, and <a class="el" href="a00019.html#l00191">spi_write_dummy</a>.
<p>
Referenced by <a class="el" href="a00022.html#l00188">at45dbx_df_2_ram()</a>, <a class="el" href="a00021.html#l00157">at45dbx_example_test_byte_mem()</a>, <a class="el" href="a00021.html#l00276">at45dbx_example_test_multiple_sector()</a>, <a class="el" href="a00021.html#l00214">at45dbx_example_test_RAM_mem()</a>, <a class="el" href="a00019.html#l00438">at45dbx_read_byte()</a>, <a class="el" href="a00019.html#l00548">at45dbx_read_sector_2_ram()</a>, and <a class="el" href="a00022.html#l00114">at45dbx_usb_read_10()</a>.<div class="fragment"><pre class="fragment"><a name="l00301"></a>00301 {
<a name="l00302"></a>00302   U32 addr;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="comment">// Set the global memory pointer to a byte address.</span>
<a name="l00305"></a>00305   <a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> = sector &lt;&lt; <a class="code" href="a00009.html#f403d899ed2618ee9541443f49034266">AT45DBX_SECTOR_BITS</a>; <span class="comment">// gl_ptr_mem = sector * AT45DBX_SECTOR_SIZE.</span>
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   <span class="comment">// If the DF memory is busy, wait until it's ready.</span>
<a name="l00308"></a>00308   <span class="keywordflow">if</span> (<a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a>) <a class="code" href="a00008.html#fea61230b05b90f7212b52ca07ce7322">at45dbx_wait_ready</a>();
<a name="l00309"></a>00309   <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = FALSE;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="comment">// Select the DF memory gl_ptr_mem points to.</span>
<a name="l00312"></a>00312   <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, TRUE);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="comment">// Initiate a page read at a given sector.</span>
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="comment">// Send the Main Memory Page Read command.</span>
<a name="l00317"></a>00317   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, <a class="code" href="a00008.html#0be99f22ca94f9c9d3959fee60f02610">AT45DBX_CMDA_RD_PAGE</a>);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319   <span class="comment">// Send the three address bytes, which comprise:</span>
<a name="l00320"></a>00320   <span class="comment">//  - (24 - (AT45DBX_PAGE_ADDR_BITS + AT45DBX_BYTE_ADDR_BITS)) reserved bits;</span>
<a name="l00321"></a>00321   <span class="comment">//  - then AT45DBX_PAGE_ADDR_BITS bits specifying the page in main memory to be read;</span>
<a name="l00322"></a>00322   <span class="comment">//  - then AT45DBX_BYTE_ADDR_BITS bits specifying the starting byte address within that page.</span>
<a name="l00323"></a>00323   <span class="comment">// NOTE: The bits of gl_ptr_mem above the AT45DBX_MEM_SIZE bits are useless for the local</span>
<a name="l00324"></a>00324   <span class="comment">// DF addressing. They are used for DF discrimination when there are several DFs.</span>
<a name="l00325"></a>00325   addr = (Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#62fa0a60ee145ddf54dbe65d3b786105">AT45DBX_MSK_PTR_PAGE</a>) &lt;&lt; AT45DBX_BYTE_ADDR_BITS) |
<a name="l00326"></a>00326          Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#9fe22bf13aaae864efa1b9d2e14dbc15">AT45DBX_MSK_PTR_BYTE</a>);
<a name="l00327"></a>00327   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB2W(addr));
<a name="l00328"></a>00328   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB1W(addr));
<a name="l00329"></a>00329   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB0W(addr));
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <span class="comment">// Send 32 don't care clock cycles to initialize the read operation.</span>
<a name="l00332"></a>00332   <a class="code" href="a00008.html#aad80751cb014549d0dcc5e9166b9426">spi_write_dummy</a>();
<a name="l00333"></a>00333   <a class="code" href="a00008.html#aad80751cb014549d0dcc5e9166b9426">spi_write_dummy</a>();
<a name="l00334"></a>00334   <a class="code" href="a00008.html#aad80751cb014549d0dcc5e9166b9426">spi_write_dummy</a>();
<a name="l00335"></a>00335   <a class="code" href="a00008.html#aad80751cb014549d0dcc5e9166b9426">spi_write_dummy</a>();
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   <span class="keywordflow">return</span> OK;
<a name="l00338"></a>00338 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="617cf35058ba73aaa3d8a3f37dc058d3"></a><!-- doxytag: member="at45dbx.h::at45dbx_read_sector_2_ram" ref="617cf35058ba73aaa3d8a3f37dc058d3" args="(void *ram)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_read_sector_2_ram           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ram</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads 1 DF sector to a RAM buffer. 
<p>
Data flow is: DF -&gt; RAM.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ram</em>&nbsp;</td><td>Pointer to RAM buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>First call must be preceded by a call to the <a class="el" href="a00009.html#c003b62656f4d90d71ba4c9cbce6a1ef">at45dbx_read_open</a> function. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00548">548</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, <a class="el" href="a00019.html#l00180">AT45DBX_MSK_PTR_BYTE</a>, <a class="el" href="a00019.html#l00300">at45dbx_read_open()</a>, <a class="el" href="a00020.html#l00075">AT45DBX_SECTOR_BITS</a>, <a class="el" href="a00020.html#l00078">AT45DBX_SECTOR_SIZE</a>, <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>, <a class="el" href="a00028.html#l00394">spi_read()</a>, and <a class="el" href="a00019.html#l00191">spi_write_dummy</a>.
<p>
Referenced by <a class="el" href="a00022.html#l00188">at45dbx_df_2_ram()</a>, <a class="el" href="a00021.html#l00214">at45dbx_example_test_RAM_mem()</a>, and <a class="el" href="a00019.html#l00514">at45dbx_read_multiple_sector()</a>.<div class="fragment"><pre class="fragment"><a name="l00549"></a>00549 {
<a name="l00550"></a>00550   U8 *_ram = ram;
<a name="l00551"></a>00551   U16 i;
<a name="l00552"></a>00552   U16 data;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   <span class="comment">// Memory busy.</span>
<a name="l00555"></a>00555   <span class="keywordflow">if</span> (<a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a>)
<a name="l00556"></a>00556   {
<a name="l00557"></a>00557     <span class="comment">// Being here, we know that we previously finished a page read.</span>
<a name="l00558"></a>00558     <span class="comment">// =&gt; We have to access the next page.</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     <span class="comment">// Memory ready.</span>
<a name="l00561"></a>00561     <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = FALSE;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <span class="comment">// Eventually select the next DF and open the next page.</span>
<a name="l00564"></a>00564     <span class="comment">// NOTE: at45dbx_read_open input parameter is a sector.</span>
<a name="l00565"></a>00565     <a class="code" href="a00008.html#c003b62656f4d90d71ba4c9cbce6a1ef">at45dbx_read_open</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00009.html#f403d899ed2618ee9541443f49034266">AT45DBX_SECTOR_BITS</a>); <span class="comment">// gl_ptr_mem / AT45DBX_SECTOR_SIZE.</span>
<a name="l00566"></a>00566   }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568   <span class="comment">// Read the next sector.</span>
<a name="l00569"></a>00569   <span class="keywordflow">for</span> (i = <a class="code" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>; i; i--)
<a name="l00570"></a>00570   {
<a name="l00571"></a>00571     <span class="comment">// Send a dummy byte to read the next data byte.</span>
<a name="l00572"></a>00572     <a class="code" href="a00008.html#aad80751cb014549d0dcc5e9166b9426">spi_write_dummy</a>();
<a name="l00573"></a>00573     <a class="code" href="a00017.html#ba67d4cedf75b3afc90aaadc86a23c07">spi_read</a>(AT45DBX_SPI, &amp;data);
<a name="l00574"></a>00574     *_ram++ = data;
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   <span class="comment">// Update the memory pointer.</span>
<a name="l00578"></a>00578   <a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> += <a class="code" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="preprocessor">#if AT45DBX_PAGE_SIZE &gt; AT45DBX_SECTOR_SIZE</span>
<a name="l00581"></a>00581 <span class="preprocessor"></span>  <span class="comment">// If end of page reached,</span>
<a name="l00582"></a>00582   <span class="keywordflow">if</span> (!Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#9fe22bf13aaae864efa1b9d2e14dbc15">AT45DBX_MSK_PTR_BYTE</a>))
<a name="l00583"></a>00583 <span class="preprocessor">#endif</span>
<a name="l00584"></a>00584 <span class="preprocessor"></span>  {
<a name="l00585"></a>00585     <span class="comment">// unselect the DF memory gl_ptr_mem points to.</span>
<a name="l00586"></a>00586     <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, FALSE);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588     <span class="comment">// Memory busy.</span>
<a name="l00589"></a>00589     <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = TRUE;
<a name="l00590"></a>00590   }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   <span class="keywordflow">return</span> OK;
<a name="l00593"></a>00593 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0b9835fceedaec0045b180918d876927"></a><!-- doxytag: member="at45dbx.h::at45dbx_write_byte" ref="0b9835fceedaec0045b180918d876927" args="(U8 b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_write_byte           </td>
          <td>(</td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>b</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a single byte write to DF memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The byte to write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>First call must be preceded by a call to the <a class="el" href="a00009.html#e5630db4f5d2a58f14b1247e8701c588">at45dbx_write_open</a> function. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00475">475</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, <a class="el" href="a00019.html#l00180">AT45DBX_MSK_PTR_BYTE</a>, <a class="el" href="a00020.html#l00075">AT45DBX_SECTOR_BITS</a>, <a class="el" href="a00019.html#l00351">at45dbx_write_open()</a>, <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>, and <a class="el" href="a00028.html#l00343">spi_write()</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00157">at45dbx_example_test_byte_mem()</a>.<div class="fragment"><pre class="fragment"><a name="l00476"></a>00476 {
<a name="l00477"></a>00477   <span class="comment">// Memory busy.</span>
<a name="l00478"></a>00478   <span class="keywordflow">if</span> (<a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a>)
<a name="l00479"></a>00479   {
<a name="l00480"></a>00480     <span class="comment">// Being here, we know that we previously launched a page programming.</span>
<a name="l00481"></a>00481     <span class="comment">// =&gt; We have to access the next page.</span>
<a name="l00482"></a>00482 
<a name="l00483"></a>00483     <span class="comment">// Eventually select the next DF and open the next page.</span>
<a name="l00484"></a>00484     <span class="comment">// NOTE: at45dbx_write_open input parameter is a sector.</span>
<a name="l00485"></a>00485     <a class="code" href="a00008.html#e5630db4f5d2a58f14b1247e8701c588">at45dbx_write_open</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00009.html#f403d899ed2618ee9541443f49034266">AT45DBX_SECTOR_BITS</a>); <span class="comment">// gl_ptr_mem / AT45DBX_SECTOR_SIZE.</span>
<a name="l00486"></a>00486   }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488   <span class="comment">// Write the next data byte.</span>
<a name="l00489"></a>00489   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, b);
<a name="l00490"></a>00490   <a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>++;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="comment">// If end of page reached,</span>
<a name="l00493"></a>00493   <span class="keywordflow">if</span> (!Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#9fe22bf13aaae864efa1b9d2e14dbc15">AT45DBX_MSK_PTR_BYTE</a>))
<a name="l00494"></a>00494   {
<a name="l00495"></a>00495     <span class="comment">// unselect the DF memory gl_ptr_mem points to in order to program the page.</span>
<a name="l00496"></a>00496     <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, FALSE);
<a name="l00497"></a>00497 
<a name="l00498"></a>00498     <span class="comment">// Memory busy.</span>
<a name="l00499"></a>00499     at45dbx_busy = TRUE;
<a name="l00500"></a>00500   }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   <span class="keywordflow">return</span> OK;
<a name="l00503"></a>00503 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="283989acaf1e876fb002ad0292c1b4cc"></a><!-- doxytag: member="at45dbx.h::at45dbx_write_close" ref="283989acaf1e876fb002ad0292c1b4cc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void at45dbx_write_close           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the end of the current logical sector and launches page programming. 
<p>

<p>
Definition at line <a class="el" href="a00019.html#l00413">413</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, <a class="el" href="a00019.html#l00186">AT45DBX_MSK_PTR_SECTOR</a>, <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>, and <a class="el" href="a00028.html#l00343">spi_write()</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00157">at45dbx_example_test_byte_mem()</a>, <a class="el" href="a00021.html#l00276">at45dbx_example_test_multiple_sector()</a>, <a class="el" href="a00021.html#l00214">at45dbx_example_test_RAM_mem()</a>, <a class="el" href="a00022.html#l00200">at45dbx_ram_2_df()</a>, and <a class="el" href="a00022.html#l00143">at45dbx_usb_write_10()</a>.<div class="fragment"><pre class="fragment"><a name="l00414"></a>00414 {
<a name="l00415"></a>00415   <span class="comment">// While end of logical sector not reached, zero-fill remaining memory bytes.</span>
<a name="l00416"></a>00416   <span class="keywordflow">while</span> (Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#a35b61b27bc7d2e05d246ddcb5c66d41">AT45DBX_MSK_PTR_SECTOR</a>))
<a name="l00417"></a>00417   {
<a name="l00418"></a>00418     <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, 0x00);
<a name="l00419"></a>00419     gl_ptr_mem++;
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="comment">// Unselect the DF memory gl_ptr_mem points to.</span>
<a name="l00423"></a>00423   <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(gl_ptr_mem &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, FALSE);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="comment">// Memory busy.</span>
<a name="l00426"></a>00426   <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = TRUE;
<a name="l00427"></a>00427 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="300234c5107dcc9deb92d01c4afe31fa"></a><!-- doxytag: member="at45dbx.h::at45dbx_write_multiple_sector" ref="300234c5107dcc9deb92d01c4afe31fa" args="(U16 nb_sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_write_multiple_sector           </td>
          <td>(</td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>nb_sector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes <em>nb_sector</em> sectors to DF memory. 
<p>
Data flow is: callback -&gt; DF.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nb_sector</em>&nbsp;</td><td>Number of contiguous sectors to write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>First call must be preceded by a call to the <a class="el" href="a00009.html#e5630db4f5d2a58f14b1247e8701c588">at45dbx_write_open</a> function.<p>
As <a class="el" href="a00008.html#18a68b3fc9d201b37cac0e4da3c37ccf">AT45DBX_PAGE_SIZE</a> is always a multiple of <a class="el" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>, there is no need to check page end for each byte. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00527">527</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00022.html#l00159">at45dbx_write_multiple_sector_callback()</a>, <a class="el" href="a00019.html#l00596">at45dbx_write_sector_from_ram()</a>, and <a class="el" href="a00019.html#l00201">sector_buf</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00276">at45dbx_example_test_multiple_sector()</a>, and <a class="el" href="a00022.html#l00143">at45dbx_usb_write_10()</a>.<div class="fragment"><pre class="fragment"><a name="l00528"></a>00528 {
<a name="l00529"></a>00529   <span class="keywordflow">while</span> (nb_sector--)
<a name="l00530"></a>00530   {
<a name="l00531"></a>00531     <span class="comment">// Write the next sector.</span>
<a name="l00532"></a>00532     <a class="code" href="a00009.html#8c8592dd952ff02a8f2cd69f9a633ebb">at45dbx_write_multiple_sector_callback</a>(<a class="code" href="a00008.html#599ab5dd05eb386b517ba893f65075e5">sector_buf</a>);
<a name="l00533"></a>00533     <a class="code" href="a00008.html#203fce44573d526f4fd833d3752ecd67">at45dbx_write_sector_from_ram</a>(<a class="code" href="a00008.html#599ab5dd05eb386b517ba893f65075e5">sector_buf</a>);
<a name="l00534"></a>00534   }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="keywordflow">return</span> OK;
<a name="l00537"></a>00537 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8c8592dd952ff02a8f2cd69f9a633ebb"></a><!-- doxytag: member="at45dbx.h::at45dbx_write_multiple_sector_callback" ref="8c8592dd952ff02a8f2cd69f9a633ebb" args="(void *psector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void at45dbx_write_multiple_sector_callback           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>psector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback function invoked before each sector write during <a class="el" href="a00009.html#300234c5107dcc9deb92d01c4afe31fa">at45dbx_write_multiple_sector</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psector</em>&nbsp;</td><td>Pointer to sector to write. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00022.html#l00159">159</a> of file <a class="el" href="a00022.html">at45dbx_mem.c</a>.
<p>
References <a class="el" href="a00020.html#l00078">AT45DBX_SECTOR_SIZE</a>, and <a class="el" href="a00021.html#l00131">PATTERN_MULTIPLE_SECTOR</a>.
<p>
Referenced by <a class="el" href="a00019.html#l00527">at45dbx_write_multiple_sector()</a>.<div class="fragment"><pre class="fragment"><a name="l00160"></a>00160 {
<a name="l00161"></a>00161   U16 data_to_transfer = <a class="code" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163   <span class="comment">// Transfer sector to write from the USB interface.</span>
<a name="l00164"></a>00164   <span class="keywordflow">while</span> (data_to_transfer)
<a name="l00165"></a>00165   {
<a name="l00166"></a>00166     <span class="keywordflow">while</span> (!Is_usb_out_received(g_scsi_ep_ms_out));
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     Usb_reset_endpoint_fifo_access(g_scsi_ep_ms_out);
<a name="l00169"></a>00169     data_to_transfer = usb_read_ep_rxpacket(g_scsi_ep_ms_out, psector,
<a name="l00170"></a>00170                                             data_to_transfer, &amp;psector);
<a name="l00171"></a>00171     Usb_ack_out_received_free(g_scsi_ep_ms_out);
<a name="l00172"></a>00172   }
<a name="l00173"></a>00173 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e5630db4f5d2a58f14b1247e8701c588"></a><!-- doxytag: member="at45dbx.h::at45dbx_write_open" ref="e5630db4f5d2a58f14b1247e8701c588" args="(U32 sector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_write_open           </td>
          <td>(</td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>sector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function opens a DF memory in write mode at a given sector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sector</em>&nbsp;</td><td>Start sector.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Sector may be page-unaligned (depending on the DF page size).<p>
If <a class="el" href="a00008.html#18a68b3fc9d201b37cac0e4da3c37ccf">AT45DBX_PAGE_SIZE</a> &gt; <a class="el" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>, page content is first loaded in buffer to then be partially updated by write byte or write sector functions. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00351">351</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00019.html#l00095">AT45DBX_CMDB_PR_PAGE_TH_BUF1</a>, <a class="el" href="a00019.html#l00087">AT45DBX_CMDB_XFR_PAGE_TO_BUF1</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, <a class="el" href="a00019.html#l00180">AT45DBX_MSK_PTR_BYTE</a>, <a class="el" href="a00019.html#l00183">AT45DBX_MSK_PTR_PAGE</a>, <a class="el" href="a00020.html#l00075">AT45DBX_SECTOR_BITS</a>, <a class="el" href="a00019.html#l00277">at45dbx_wait_ready()</a>, <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>, and <a class="el" href="a00028.html#l00343">spi_write()</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00157">at45dbx_example_test_byte_mem()</a>, <a class="el" href="a00021.html#l00276">at45dbx_example_test_multiple_sector()</a>, <a class="el" href="a00021.html#l00214">at45dbx_example_test_RAM_mem()</a>, <a class="el" href="a00022.html#l00200">at45dbx_ram_2_df()</a>, <a class="el" href="a00022.html#l00143">at45dbx_usb_write_10()</a>, <a class="el" href="a00019.html#l00475">at45dbx_write_byte()</a>, and <a class="el" href="a00019.html#l00596">at45dbx_write_sector_from_ram()</a>.<div class="fragment"><pre class="fragment"><a name="l00352"></a>00352 {
<a name="l00353"></a>00353   U32 addr;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355   <span class="comment">// Set the global memory pointer to a byte address.</span>
<a name="l00356"></a>00356   <a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> = sector &lt;&lt; <a class="code" href="a00009.html#f403d899ed2618ee9541443f49034266">AT45DBX_SECTOR_BITS</a>; <span class="comment">// gl_ptr_mem = sector * AT45DBX_SECTOR_SIZE.</span>
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="comment">// If the DF memory is busy, wait until it's ready.</span>
<a name="l00359"></a>00359   <span class="keywordflow">if</span> (<a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a>) <a class="code" href="a00008.html#fea61230b05b90f7212b52ca07ce7322">at45dbx_wait_ready</a>();
<a name="l00360"></a>00360   <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = FALSE;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="preprocessor">#if AT45DBX_PAGE_SIZE &gt; AT45DBX_SECTOR_SIZE</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>  <span class="comment">// Select the DF memory gl_ptr_mem points to.</span>
<a name="l00364"></a>00364   <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, TRUE);
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   <span class="comment">// Transfer the content of the current page to buffer 1.</span>
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="comment">// Send the Main Memory Page to Buffer 1 Transfer command.</span>
<a name="l00369"></a>00369   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, <a class="code" href="a00008.html#c8a008936b3f2669c34c15a5e9ef728a">AT45DBX_CMDB_XFR_PAGE_TO_BUF1</a>);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="comment">// Send the three address bytes, which comprise:</span>
<a name="l00372"></a>00372   <span class="comment">//  - (24 - (AT45DBX_PAGE_ADDR_BITS + AT45DBX_BYTE_ADDR_BITS)) reserved bits;</span>
<a name="l00373"></a>00373   <span class="comment">//  - then AT45DBX_PAGE_ADDR_BITS bits specifying the page in main memory to be read;</span>
<a name="l00374"></a>00374   <span class="comment">//  - then AT45DBX_BYTE_ADDR_BITS don't care bits.</span>
<a name="l00375"></a>00375   <span class="comment">// NOTE: The bits of gl_ptr_mem above the AT45DBX_MEM_SIZE bits are useless for the local</span>
<a name="l00376"></a>00376   <span class="comment">// DF addressing. They are used for DF discrimination when there are several DFs.</span>
<a name="l00377"></a>00377   addr = Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#62fa0a60ee145ddf54dbe65d3b786105">AT45DBX_MSK_PTR_PAGE</a>) &lt;&lt; AT45DBX_BYTE_ADDR_BITS;
<a name="l00378"></a>00378   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB2W(addr));
<a name="l00379"></a>00379   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB1W(addr));
<a name="l00380"></a>00380   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB0W(addr));
<a name="l00381"></a>00381 
<a name="l00382"></a>00382   <span class="comment">// Unselect the DF memory gl_ptr_mem points to.</span>
<a name="l00383"></a>00383   <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, FALSE);
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">// Wait for end of page transfer.</span>
<a name="l00386"></a>00386   <a class="code" href="a00008.html#fea61230b05b90f7212b52ca07ce7322">at45dbx_wait_ready</a>();
<a name="l00387"></a>00387 <span class="preprocessor">#endif</span>
<a name="l00388"></a>00388 <span class="preprocessor"></span>
<a name="l00389"></a>00389   <span class="comment">// Select the DF memory gl_ptr_mem points to.</span>
<a name="l00390"></a>00390   <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, TRUE);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="comment">// Initiate a page write at a given sector.</span>
<a name="l00393"></a>00393 
<a name="l00394"></a>00394   <span class="comment">// Send the Main Memory Page Program through Buffer 1 command.</span>
<a name="l00395"></a>00395   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, <a class="code" href="a00008.html#1ef6a2b0a4055d24fe1769e1699caf89">AT45DBX_CMDB_PR_PAGE_TH_BUF1</a>);
<a name="l00396"></a>00396 
<a name="l00397"></a>00397   <span class="comment">// Send the three address bytes, which comprise:</span>
<a name="l00398"></a>00398   <span class="comment">//  - (24 - (AT45DBX_PAGE_ADDR_BITS + AT45DBX_BYTE_ADDR_BITS)) reserved bits;</span>
<a name="l00399"></a>00399   <span class="comment">//  - then AT45DBX_PAGE_ADDR_BITS bits specifying the page in main memory to be written;</span>
<a name="l00400"></a>00400   <span class="comment">//  - then AT45DBX_BYTE_ADDR_BITS bits specifying the starting byte address within that page.</span>
<a name="l00401"></a>00401   <span class="comment">// NOTE: The bits of gl_ptr_mem above the AT45DBX_MEM_SIZE bits are useless for the local</span>
<a name="l00402"></a>00402   <span class="comment">// DF addressing. They are used for DF discrimination when there are several DFs.</span>
<a name="l00403"></a>00403   addr = (Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#62fa0a60ee145ddf54dbe65d3b786105">AT45DBX_MSK_PTR_PAGE</a>) &lt;&lt; AT45DBX_BYTE_ADDR_BITS) |
<a name="l00404"></a>00404          Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#9fe22bf13aaae864efa1b9d2e14dbc15">AT45DBX_MSK_PTR_BYTE</a>);
<a name="l00405"></a>00405   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB2W(addr));
<a name="l00406"></a>00406   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB1W(addr));
<a name="l00407"></a>00407   <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, LSB0W(addr));
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="keywordflow">return</span> OK;
<a name="l00410"></a>00410 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="203fce44573d526f4fd833d3752ecd67"></a><!-- doxytag: member="at45dbx.h::at45dbx_write_sector_from_ram" ref="203fce44573d526f4fd833d3752ecd67" args="(const void *ram)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool at45dbx_write_sector_from_ram           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>ram</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes 1 DF sector from a RAM buffer. 
<p>
Data flow is: RAM -&gt; DF.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ram</em>&nbsp;</td><td>Pointer to RAM buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OK</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KO</em>&nbsp;</td><td>Failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>First call must be preceded by a call to the <a class="el" href="a00009.html#e5630db4f5d2a58f14b1247e8701c588">at45dbx_write_open</a> function. </dd></dl>

<p>
Definition at line <a class="el" href="a00019.html#l00596">596</a> of file <a class="el" href="a00019.html">at45dbx.c</a>.
<p>
References <a class="el" href="a00019.html#l00195">at45dbx_busy</a>, <a class="el" href="a00019.html#l00231">at45dbx_chipselect_df()</a>, <a class="el" href="a00025.html#l00062">AT45DBX_MEM_SIZE</a>, <a class="el" href="a00019.html#l00180">AT45DBX_MSK_PTR_BYTE</a>, <a class="el" href="a00020.html#l00075">AT45DBX_SECTOR_BITS</a>, <a class="el" href="a00020.html#l00078">AT45DBX_SECTOR_SIZE</a>, <a class="el" href="a00019.html#l00351">at45dbx_write_open()</a>, <a class="el" href="a00019.html#l00198">gl_ptr_mem</a>, and <a class="el" href="a00028.html#l00343">spi_write()</a>.
<p>
Referenced by <a class="el" href="a00021.html#l00214">at45dbx_example_test_RAM_mem()</a>, <a class="el" href="a00022.html#l00200">at45dbx_ram_2_df()</a>, and <a class="el" href="a00019.html#l00527">at45dbx_write_multiple_sector()</a>.<div class="fragment"><pre class="fragment"><a name="l00597"></a>00597 {
<a name="l00598"></a>00598   <span class="keyword">const</span> U8 *_ram = ram;
<a name="l00599"></a>00599   U16 i;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   <span class="comment">// Memory busy.</span>
<a name="l00602"></a>00602   <span class="keywordflow">if</span> (<a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a>)
<a name="l00603"></a>00603   {
<a name="l00604"></a>00604     <span class="comment">// Being here, we know that we previously launched a page programming.</span>
<a name="l00605"></a>00605     <span class="comment">// =&gt; We have to access the next page.</span>
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     <span class="comment">// Eventually select the next DF and open the next page.</span>
<a name="l00608"></a>00608     <span class="comment">// NOTE: at45dbx_write_open input parameter is a sector.</span>
<a name="l00609"></a>00609     <a class="code" href="a00008.html#e5630db4f5d2a58f14b1247e8701c588">at45dbx_write_open</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00009.html#f403d899ed2618ee9541443f49034266">AT45DBX_SECTOR_BITS</a>); <span class="comment">// gl_ptr_mem / AT45DBX_SECTOR_SIZE.</span>
<a name="l00610"></a>00610   }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="comment">// Write the next sector.</span>
<a name="l00613"></a>00613   <span class="keywordflow">for</span> (i = <a class="code" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>; i; i--)
<a name="l00614"></a>00614   {
<a name="l00615"></a>00615     <span class="comment">// Write the next data byte.</span>
<a name="l00616"></a>00616     <a class="code" href="a00017.html#b3042652094d721c82a120dd8b4cebe9">spi_write</a>(AT45DBX_SPI, *_ram++);
<a name="l00617"></a>00617   }
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   <span class="comment">// Update the memory pointer.</span>
<a name="l00620"></a>00620   <a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> += <a class="code" href="a00009.html#e29e3481c115b344aa2d45f0751c4ab9">AT45DBX_SECTOR_SIZE</a>;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="preprocessor">#if AT45DBX_PAGE_SIZE &gt; AT45DBX_SECTOR_SIZE</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span>  <span class="comment">// If end of page reached,</span>
<a name="l00624"></a>00624   <span class="keywordflow">if</span> (!Rd_bitfield(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a>, <a class="code" href="a00008.html#9fe22bf13aaae864efa1b9d2e14dbc15">AT45DBX_MSK_PTR_BYTE</a>))
<a name="l00625"></a>00625 #endif
<a name="l00626"></a>00626   {
<a name="l00627"></a>00627     <span class="comment">// unselect the DF memory gl_ptr_mem points to in order to program the page.</span>
<a name="l00628"></a>00628     <a class="code" href="a00008.html#e92675f93f3d6936a40805cc2d2689b6">at45dbx_chipselect_df</a>(<a class="code" href="a00008.html#a73e3f4f0baa520941bc1145cfd9b034">gl_ptr_mem</a> &gt;&gt; <a class="code" href="a00014.html#6d2ae3a60b2a81a1ea0816e654f1bb16">AT45DBX_MEM_SIZE</a>, FALSE);
<a name="l00629"></a>00629 
<a name="l00630"></a>00630     <span class="comment">// Memory busy.</span>
<a name="l00631"></a>00631     <a class="code" href="a00008.html#0d389c9734fa8ed682986d8d2674c3b0">at45dbx_busy</a> = TRUE;
<a name="l00632"></a>00632   }
<a name="l00633"></a>00633 
<a name="l00634"></a>00634   <span class="keywordflow">return</span> OK;
<a name="l00635"></a>00635 }
</pre></div>
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Sep 20 12:16:45 2007 for AVR32 - AT45DBX Data Flash Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
