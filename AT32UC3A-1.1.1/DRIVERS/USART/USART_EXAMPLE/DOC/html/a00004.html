<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR32 UC3 - USART Driver: usart.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>usart.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
USART driver for AVR32 UC3. 
<p>
This file contains basic functions for the AVR32 USART, with support for all modes, settings and clock speeds.<p>
<ul>
<li>Compiler: IAR EWAVR32 and GNU GCC for AVR32</li><li>Supported devices: All AVR32 devices with a USART module can be used.</li><li>AppNote:</li></ul>
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support and FAQ: <a href="http://support.atmel.no/">http://support.atmel.no/</a> </dd></dl>

<p>
Definition in file <a class="el" href="a00007.html">usart.c</a>.
<p>
<code>#include &quot;<a class="el" href="a00008.html">usart.h</a>&quot;</code><br>

<p>
<a href="a00007.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Transmit/Receive Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#c11b2593b4bd1950ccbd35fe07e582f8">usart_get_echo_line</a> (volatile avr32_usart_t *usart)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets and echoes characters until end of line.  <a href="#c11b2593b4bd1950ccbd35fe07e582f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#a751e180b091943b684b48c581aaef3e">usart_getchar</a> (volatile avr32_usart_t *usart)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until a character is received, and returns it.  <a href="#a751e180b091943b684b48c581aaef3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a> (volatile avr32_usart_t *usart, int c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a character with the USART.  <a href="#2ff96c7ceba22b5663bee08da4633ed9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#b73fc2f42bd6fe66c03d598b0158436d">usart_read_char</a> (volatile avr32_usart_t *usart, int *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks the RX buffer for a received character, and stores it at the given memory location.  <a href="#b73fc2f42bd6fe66c03d598b0158436d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#9f2429a7b9d05f100052dd791fb499df">usart_send_address</a> (volatile avr32_usart_t *usart, int address)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Addresses a receiver.  <a href="#9f2429a7b9d05f100052dd791fb499df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#0c36f4b2ec5445212642ee7f94672805">usart_write_char</a> (volatile avr32_usart_t *usart, int c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the given character to the TX buffer if the transmitter is ready.  <a href="#0c36f4b2ec5445212642ee7f94672805"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#2090c77f008cbbde81b5047b91a9826d">usart_write_line</a> (volatile avr32_usart_t *usart, const char *string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes one character string to the USART.  <a href="#2090c77f008cbbde81b5047b91a9826d"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#dfacf6f496aa8131fbb5587ff4a2594c">usart_init_hw_handshaking</a> (volatile avr32_usart_t *usart, const <a class="el" href="a00002.html">usart_options_t</a> *opt, long pba_hz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the USART to use hardware handshaking.  <a href="#dfacf6f496aa8131fbb5587ff4a2594c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#91b8eae5a6df18a73c16f86fe4109a61">usart_init_IrDA</a> (volatile avr32_usart_t *usart, const <a class="el" href="a00002.html">usart_options_t</a> *opt, long pba_hz, unsigned char irda_filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the USART to use the IrDA protocol.  <a href="#91b8eae5a6df18a73c16f86fe4109a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#ad48e7e51e5af8393794d15f0c5e5c75">usart_init_iso7816</a> (volatile avr32_usart_t *usart, const <a class="el" href="a00001.html">iso7816_options_t</a> *opt, int t, long pba_hz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the USART to use the ISO7816 T=0 or T=1 smartcard protocols.  <a href="#ad48e7e51e5af8393794d15f0c5e5c75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#528f0115991d4e9e15b4ccb44e7bf225">usart_init_modem</a> (volatile avr32_usart_t *usart, const <a class="el" href="a00002.html">usart_options_t</a> *opt, long pba_hz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the USART to use the modem protocol, activating dedicated inputs/outputs.  <a href="#528f0115991d4e9e15b4ccb44e7bf225"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a> (volatile avr32_usart_t *usart, const <a class="el" href="a00002.html">usart_options_t</a> *opt, long pba_hz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the USART to use the standard RS232 protocol.  <a href="#f8b81384234af455b491c44447d896f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#31249a0033e1c21e42271f482ab81e22">usart_init_rs485</a> (volatile avr32_usart_t *usart, const <a class="el" href="a00002.html">usart_options_t</a> *opt, long pba_hz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the USART to use the RS485 protocol.  <a href="#31249a0033e1c21e42271f482ab81e22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#31cf4d67fd204fb4684fff9d7994cb4c">usart_reset</a> (volatile avr32_usart_t *usart)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the USART and disables TX and RX.  <a href="#31cf4d67fd204fb4684fff9d7994cb4c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static __inline__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#ab614b60efcf070b5db36d2b92632e30">usart_mode_is_multidrop</a> (volatile avr32_usart_t *usart)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the USART is in multidrop mode.  <a href="#ab614b60efcf070b5db36d2b92632e30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html#7fbc9a9a50b67071a735edd78ec2601e">usart_set_baudrate</a> (volatile avr32_usart_t *usart, unsigned int baudrate, long pba_hz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates a clock divider (<em>CD</em>) that gets the USART as close to a wanted baudrate as possible.  <a href="#7fbc9a9a50b67071a735edd78ec2601e"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c11b2593b4bd1950ccbd35fe07e582f8"></a><!-- doxytag: member="usart.c::usart_get_echo_line" ref="c11b2593b4bd1950ccbd35fe07e582f8" args="(volatile avr32_usart_t *usart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_get_echo_line           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets and echoes characters until end of line. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_FAILURE</em>&nbsp;</td><td>ETX character received. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00417">417</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00057">USART_FAILURE</a>, <a class="el" href="a00007.html#l00397">usart_getchar()</a>, <a class="el" href="a00007.html#l00354">usart_putchar()</a>, <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>, and <a class="el" href="a00007.html#l00410">usart_write_line()</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00117">main()</a>.<div class="fragment"><pre class="fragment"><a name="l00418"></a>00418 {
<a name="l00419"></a>00419   <span class="keywordtype">int</span> rx_char;
<a name="l00420"></a>00420   <span class="keywordtype">int</span> retval = <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="keywordflow">while</span> (1)
<a name="l00423"></a>00423   {
<a name="l00424"></a>00424     rx_char = <a class="code" href="a00004.html#a751e180b091943b684b48c581aaef3e">usart_getchar</a>(usart);
<a name="l00425"></a>00425     <span class="keywordflow">if</span> (rx_char == <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       <a class="code" href="a00004.html#2090c77f008cbbde81b5047b91a9826d">usart_write_line</a>(usart, <span class="stringliteral">"Error!!!\n"</span>);
<a name="l00428"></a>00428       <span class="keywordflow">break</span>;
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430     <span class="keywordflow">if</span> (rx_char == '\x03')
<a name="l00431"></a>00431     {
<a name="l00432"></a>00432       retval = <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00433"></a>00433       <span class="keywordflow">break</span>;
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435     <a class="code" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a>(usart, rx_char);
<a name="l00436"></a>00436     <span class="keywordflow">if</span> (rx_char == <span class="charliteral">'\r'</span>)
<a name="l00437"></a>00437     {
<a name="l00438"></a>00438       <a class="code" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a>(usart, <span class="charliteral">'\n'</span>);
<a name="l00439"></a>00439       <span class="keywordflow">break</span>;
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441   }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="keywordflow">return</span> retval;
<a name="l00444"></a>00444 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a751e180b091943b684b48c581aaef3e"></a><!-- doxytag: member="usart.c::usart_getchar" ref="a751e180b091943b684b48c581aaef3e" args="(volatile avr32_usart_t *usart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_getchar           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits until a character is received, and returns it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The received character, or <a class="el" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a> upon error. </dd></dl>

<p>
Definition at line <a class="el" href="a00007.html#l00397">397</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00057">USART_FAILURE</a>, <a class="el" href="a00007.html#l00377">usart_read_char()</a>, <a class="el" href="a00008.html#l00061">USART_RX_EMPTY</a>, and <a class="el" href="a00008.html#l00062">USART_RX_ERROR</a>.
<p>
Referenced by <a class="el" href="a00007.html#l00417">usart_get_echo_line()</a>.<div class="fragment"><pre class="fragment"><a name="l00398"></a>00398 {
<a name="l00399"></a>00399   <span class="keywordtype">int</span> c, ret;
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <span class="keywordflow">while</span> ((ret = <a class="code" href="a00004.html#b73fc2f42bd6fe66c03d598b0158436d">usart_read_char</a>(usart, &amp;c)) == <a class="code" href="a00005.html#deb9432170d2d09a4ffbb098a1b4335e">USART_RX_EMPTY</a>);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (ret == <a class="code" href="a00005.html#ffa1a7abf4e6ce54c0b64cc0826f8b4d">USART_RX_ERROR</a>)
<a name="l00404"></a>00404     <span class="keywordflow">return</span> <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="keywordflow">return</span> c;
<a name="l00407"></a>00407 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dfacf6f496aa8131fbb5587ff4a2594c"></a><!-- doxytag: member="usart.c::usart_init_hw_handshaking" ref="dfacf6f496aa8131fbb5587ff4a2594c" args="(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_init_hw_handshaking           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00002.html">usart_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the USART to use hardware handshaking. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Options needed to set up RS232 communication (see <a class="el" href="a00002.html">usart_options_t</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>USART module input clock frequency (PBA clock, Hz).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Mode successfully initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_INVALID_INPUT</em>&nbsp;</td><td>One or more of the arguments is out of valid range.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="a00005.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a> does not need to be invoked before this function. </dd></dl>

<p>
Definition at line <a class="el" href="a00007.html#l00207">207</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00007.html#l00156">usart_init_rs232()</a>, <a class="el" href="a00008.html#l00058">USART_INVALID_INPUT</a>, <a class="el" href="a00008.html#l00085">USART_MODE_HW_HSH</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00208"></a>00208 {
<a name="l00209"></a>00209   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00210"></a>00210   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00211"></a>00211     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="comment">// Clear previous mode.</span>
<a name="l00214"></a>00214   usart-&gt;mr &amp;= ~AVR32_USART_MR_MODE_MASK;
<a name="l00215"></a>00215   <span class="comment">// Hardware handshaking.</span>
<a name="l00216"></a>00216   usart-&gt;mr |= <a class="code" href="a00005.html#20f58bd59d4177ad2981c8fa338a95af">USART_MODE_HW_HSH</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00219"></a>00219 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="91b8eae5a6df18a73c16f86fe4109a61"></a><!-- doxytag: member="usart.c::usart_init_IrDA" ref="91b8eae5a6df18a73c16f86fe4109a61" args="(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz, unsigned char irda_filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_init_IrDA           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00002.html">usart_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>irda_filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the USART to use the IrDA protocol. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Options needed to set up RS232 communication (see <a class="el" href="a00002.html">usart_options_t</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>USART module input clock frequency (PBA clock, Hz). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>irda_filter</em>&nbsp;</td><td>Counter used to distinguish received ones from zeros.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Mode successfully initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_INVALID_INPUT</em>&nbsp;</td><td>One or more of the arguments is out of valid range. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00222">222</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00007.html#l00156">usart_init_rs232()</a>, <a class="el" href="a00008.html#l00058">USART_INVALID_INPUT</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00224"></a>00224 {
<a name="l00225"></a>00225   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00226"></a>00226   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00227"></a>00227     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   <span class="comment">// Set IrDA counter.</span>
<a name="l00230"></a>00230   usart-&gt;ifr = irda_filter;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">// Activate "low-pass filtering" of input.</span>
<a name="l00233"></a>00233   usart-&gt;mr |= AVR32_USART_MR_FILTER_MASK;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00236"></a>00236 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ad48e7e51e5af8393794d15f0c5e5c75"></a><!-- doxytag: member="usart.c::usart_init_iso7816" ref="ad48e7e51e5af8393794d15f0c5e5c75" args="(volatile avr32_usart_t *usart, const iso7816_options_t *opt, int t, long pba_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_init_iso7816           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00001.html">iso7816_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the USART to use the ISO7816 T=0 or T=1 smartcard protocols. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Options needed to set up ISO7816 communication (see <a class="el" href="a00001.html">iso7816_options_t</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>ISO7816 mode to use (T=0 or T=1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>USART module input clock frequency (PBA clock, Hz).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Mode successfully initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_INVALID_INPUT</em>&nbsp;</td><td>One or more of the arguments is out of valid range. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00269">269</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00165">iso7816_options_t::bit_order</a>, <a class="el" href="a00008.html#l00157">iso7816_options_t::dis_suc_nack</a>, <a class="el" href="a00008.html#l00144">iso7816_options_t::fidi_ratio</a>, <a class="el" href="a00008.html#l00151">iso7816_options_t::inhibit_nack</a>, <a class="el" href="a00008.html#l00140">iso7816_options_t::iso7816_hz</a>, <a class="el" href="a00008.html#l00160">iso7816_options_t::max_iterations</a>, <a class="el" href="a00008.html#l00058">USART_INVALID_INPUT</a>, <a class="el" href="a00008.html#l00087">USART_MODE_ISO7816_T0</a>, <a class="el" href="a00008.html#l00088">USART_MODE_ISO7816_T1</a>, <a class="el" href="a00007.html#l00133">usart_reset()</a>, <a class="el" href="a00007.html#l00087">usart_set_baudrate()</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00270"></a>00270 {
<a name="l00271"></a>00271   <span class="comment">// Reset the USART and shutdown TX and RX.</span>
<a name="l00272"></a>00272   <a class="code" href="a00004.html#31cf4d67fd204fb4684fff9d7994cb4c">usart_reset</a>(usart);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="comment">// Check input values.</span>
<a name="l00275"></a>00275   <span class="keywordflow">if</span> (!opt) <span class="comment">// Null pointer.</span>
<a name="l00276"></a>00276     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keywordflow">if</span> (t == 0)
<a name="l00279"></a>00279   {
<a name="l00280"></a>00280     <span class="comment">// Set USART mode to ISO7816, T=0.</span>
<a name="l00281"></a>00281     <span class="comment">// The T=0 protocol always uses 2 stop bits.</span>
<a name="l00282"></a>00282     usart-&gt;mr = (<a class="code" href="a00005.html#af44f2a4560d84b228624189aad26d5e">USART_MODE_ISO7816_T0</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET) |
<a name="l00283"></a>00283                 (AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET) |
<a name="l00284"></a>00284                 (opt-&gt;<a class="code" href="a00001.html#96af893cd6275fd35a063a235f489a82">bit_order</a> &lt;&lt; AVR32_USART_MR_MSBF_OFFSET); <span class="comment">// Allow MSBF in T=0.</span>
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t == 1)
<a name="l00287"></a>00287   {
<a name="l00288"></a>00288     <span class="comment">// Only LSB first in the T=1 protocol.</span>
<a name="l00289"></a>00289     <span class="comment">// max_iterations field is only used in T=0 mode.</span>
<a name="l00290"></a>00290     <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00001.html#96af893cd6275fd35a063a235f489a82">bit_order</a> != 0 ||
<a name="l00291"></a>00291         opt-&gt;<a class="code" href="a00001.html#4c74df529ed76d2962f54cd1f0f5027f">max_iterations</a> != 0)
<a name="l00292"></a>00292       <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00293"></a>00293     <span class="comment">// Set USART mode to ISO7816, T=1.</span>
<a name="l00294"></a>00294     <span class="comment">// The T=1 protocol always uses 1 stop bit.</span>
<a name="l00295"></a>00295     usart-&gt;mr = (<a class="code" href="a00005.html#20cc4cd0b851232cd6b3680713792a44">USART_MODE_ISO7816_T1</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET) |
<a name="l00296"></a>00296                 (AVR32_USART_MR_NBSTOP_1 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET);
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298   <span class="keywordflow">else</span>
<a name="l00299"></a>00299     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#7fbc9a9a50b67071a735edd78ec2601e">usart_set_baudrate</a>(usart, opt-&gt;<a class="code" href="a00001.html#6670bdcae159decd3ff5c00f6f3f4fcc">iso7816_hz</a>, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00302"></a>00302     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="comment">// Set FIDI register: bit rate = selected clock/FI_DI_ratio/16.</span>
<a name="l00305"></a>00305   usart-&gt;fidi = opt-&gt;<a class="code" href="a00001.html#bf0d2900a6f8f97c0163176f2600551c">fidi_ratio</a>;
<a name="l00306"></a>00306   <span class="comment">// Set ISO7816 spesific options in the MODE register.</span>
<a name="l00307"></a>00307   usart-&gt;mr |= (opt-&gt;<a class="code" href="a00001.html#128f4d404bb0369177a591eb8a0a9269">inhibit_nack</a> &lt;&lt; AVR32_USART_MR_INACK_OFFSET) |
<a name="l00308"></a>00308                (opt-&gt;<a class="code" href="a00001.html#b8d335e18629f4fcf625e1a7e23e35be">dis_suc_nack</a> &lt;&lt; AVR32_USART_MR_DSNACK_OFFSET) |
<a name="l00309"></a>00309                (opt-&gt;<a class="code" href="a00001.html#4c74df529ed76d2962f54cd1f0f5027f">max_iterations</a> &lt;&lt; AVR32_USART_MR_MAX_ITERATION_OFFSET) |
<a name="l00310"></a>00310                AVR32_USART_MR_CLKO_MASK;  <span class="comment">// Enable clock output.</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312   <span class="comment">// Setup complete; enable input.</span>
<a name="l00313"></a>00313   <span class="comment">// Leave TX disabled for now.</span>
<a name="l00314"></a>00314   usart-&gt;cr |= AVR32_USART_CR_RXEN_MASK;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00317"></a>00317 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="528f0115991d4e9e15b4ccb44e7bf225"></a><!-- doxytag: member="usart.c::usart_init_modem" ref="528f0115991d4e9e15b4ccb44e7bf225" args="(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_init_modem           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00002.html">usart_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the USART to use the modem protocol, activating dedicated inputs/outputs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Options needed to set up RS232 communication (see <a class="el" href="a00002.html">usart_options_t</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>USART module input clock frequency (PBA clock, Hz).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Mode successfully initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_INVALID_INPUT</em>&nbsp;</td><td>One or more of the arguments is out of valid range. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00239">239</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00007.html#l00156">usart_init_rs232()</a>, <a class="el" href="a00008.html#l00058">USART_INVALID_INPUT</a>, <a class="el" href="a00008.html#l00086">USART_MODE_MODEM</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00240"></a>00240 {
<a name="l00241"></a>00241   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00242"></a>00242   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00243"></a>00243     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   <span class="comment">// Clear previous mode.</span>
<a name="l00246"></a>00246   usart-&gt;mr &amp;= ~AVR32_USART_MR_MODE_MASK;
<a name="l00247"></a>00247   <span class="comment">// Set modem mode.</span>
<a name="l00248"></a>00248   usart-&gt;mr |= <a class="code" href="a00005.html#e01dfbdf6f2d1c148b0320e19f8fa98e">USART_MODE_MODEM</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00251"></a>00251 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f8b81384234af455b491c44447d896f1"></a><!-- doxytag: member="usart.c::usart_init_rs232" ref="f8b81384234af455b491c44447d896f1" args="(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_init_rs232           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00002.html">usart_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the USART to use the standard RS232 protocol. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Options needed to set up RS232 communication (see <a class="el" href="a00002.html">usart_options_t</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>USART module input clock frequency (PBA clock, Hz).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Mode successfully initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_INVALID_INPUT</em>&nbsp;</td><td>One or more of the arguments is out of valid range. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00156">156</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00116">usart_options_t::baudrate</a>, <a class="el" href="a00008.html#l00133">usart_options_t::channelmode</a>, <a class="el" href="a00008.html#l00119">usart_options_t::charlength</a>, <a class="el" href="a00008.html#l00124">usart_options_t::paritytype</a>, <a class="el" href="a00008.html#l00129">usart_options_t::stopbits</a>, <a class="el" href="a00008.html#l00108">USART_2_STOPBITS</a>, <a class="el" href="a00008.html#l00058">USART_INVALID_INPUT</a>, <a class="el" href="a00007.html#l00133">usart_reset()</a>, <a class="el" href="a00007.html#l00087">usart_set_baudrate()</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00117">main()</a>, <a class="el" href="a00007.html#l00207">usart_init_hw_handshaking()</a>, <a class="el" href="a00007.html#l00222">usart_init_IrDA()</a>, <a class="el" href="a00007.html#l00239">usart_init_modem()</a>, and <a class="el" href="a00007.html#l00254">usart_init_rs485()</a>.<div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158   <span class="comment">// Reset the USART and shutdown TX and RX.</span>
<a name="l00159"></a>00159   <a class="code" href="a00004.html#31cf4d67fd204fb4684fff9d7994cb4c">usart_reset</a>(usart);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="comment">// Check input values.</span>
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (!opt) <span class="comment">// Null pointer.</span>
<a name="l00163"></a>00163     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> &lt; 5 || opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> &gt; 9 ||
<a name="l00165"></a>00165       opt-&gt;<a class="code" href="a00002.html#85401f7a6f516a5883adc0538dc27f8e">paritytype</a> &gt; 7 ||
<a name="l00166"></a>00166       opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> &gt; 2 + 255 ||
<a name="l00167"></a>00167       opt-&gt;<a class="code" href="a00002.html#0dc365b8779891743180e9b69116f5ea">channelmode</a> &gt; 3)
<a name="l00168"></a>00168     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#7fbc9a9a50b67071a735edd78ec2601e">usart_set_baudrate</a>(usart, opt-&gt;<a class="code" href="a00002.html#276ad428776a25b8247762bd2c82b35b">baudrate</a>, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00171"></a>00171     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> == 9)
<a name="l00174"></a>00174   {
<a name="l00175"></a>00175     <span class="comment">// Character length set to 9 bits. MODE9 dominates CHRL.</span>
<a name="l00176"></a>00176     usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
<a name="l00177"></a>00177   }
<a name="l00178"></a>00178   <span class="keywordflow">else</span>
<a name="l00179"></a>00179   {
<a name="l00180"></a>00180     <span class="comment">// CHRL gives the character length (- 5) when MODE9 = 0.</span>
<a name="l00181"></a>00181     usart-&gt;mr |= (opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   usart-&gt;mr |= (opt-&gt;<a class="code" href="a00002.html#0dc365b8779891743180e9b69116f5ea">channelmode</a> &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET) |
<a name="l00185"></a>00185                (opt-&gt;<a class="code" href="a00002.html#85401f7a6f516a5883adc0538dc27f8e">paritytype</a> &lt;&lt; AVR32_USART_MR_PAR_OFFSET);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> &gt; <a class="code" href="a00005.html#33058202439211b539aa2e9478f785bd">USART_2_STOPBITS</a>)
<a name="l00188"></a>00188   {
<a name="l00189"></a>00189     <span class="comment">// Set two stop bits</span>
<a name="l00190"></a>00190     usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
<a name="l00191"></a>00191     <span class="comment">// and a timeguard period gives the rest.</span>
<a name="l00192"></a>00192     usart-&gt;ttgr = opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> - <a class="code" href="a00005.html#33058202439211b539aa2e9478f785bd">USART_2_STOPBITS</a>;
<a name="l00193"></a>00193   }
<a name="l00194"></a>00194   <span class="keywordflow">else</span>
<a name="l00195"></a>00195     <span class="comment">// Insert 1, 1.5 or 2 stop bits.</span>
<a name="l00196"></a>00196     usart-&gt;mr |= opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="comment">// Setup complete; enable communication.</span>
<a name="l00199"></a>00199   <span class="comment">// Enable input and output.</span>
<a name="l00200"></a>00200   usart-&gt;cr |= AVR32_USART_CR_TXEN_MASK |
<a name="l00201"></a>00201                AVR32_USART_CR_RXEN_MASK;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00204"></a>00204 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="31249a0033e1c21e42271f482ab81e22"></a><!-- doxytag: member="usart.c::usart_init_rs485" ref="31249a0033e1c21e42271f482ab81e22" args="(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_init_rs485           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00002.html">usart_options_t</a> *&nbsp;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the USART to use the RS485 protocol. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>Options needed to set up RS232 communication (see <a class="el" href="a00002.html">usart_options_t</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>USART module input clock frequency (PBA clock, Hz).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Mode successfully initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_INVALID_INPUT</em>&nbsp;</td><td>One or more of the arguments is out of valid range. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00254">254</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00007.html#l00156">usart_init_rs232()</a>, <a class="el" href="a00008.html#l00058">USART_INVALID_INPUT</a>, <a class="el" href="a00008.html#l00084">USART_MODE_RS485</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00255"></a>00255 {
<a name="l00256"></a>00256   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00257"></a>00257   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00258"></a>00258     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260   <span class="comment">// Clear previous mode.</span>
<a name="l00261"></a>00261   usart-&gt;mr &amp;= ~AVR32_USART_MR_MODE_MASK;
<a name="l00262"></a>00262   <span class="comment">// Set RS485 mode.</span>
<a name="l00263"></a>00263   usart-&gt;mr |= <a class="code" href="a00005.html#a2946a63275da85d3b578044a88bbd7d">USART_MODE_RS485</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00266"></a>00266 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ab614b60efcf070b5db36d2b92632e30"></a><!-- doxytag: member="usart.c::usart_mode_is_multidrop" ref="ab614b60efcf070b5db36d2b92632e30" args="(volatile avr32_usart_t *usart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ int usart_mode_is_multidrop           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the USART is in multidrop mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>1</code> if the USART is in multidrop mode, otherwise <code>0</code>. </dd></dl>

<p>
Definition at line <a class="el" href="a00007.html#l00064">64</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
Referenced by <a class="el" href="a00007.html#l00327">usart_send_address()</a>.<div class="fragment"><pre class="fragment"><a name="l00065"></a>00065 {
<a name="l00066"></a>00066   <span class="keywordflow">return</span> ((usart-&gt;mr &gt;&gt; AVR32_USART_MR_PAR_OFFSET) &amp; AVR32_USART_MR_PAR_MULTI) == AVR32_USART_MR_PAR_MULTI;
<a name="l00067"></a>00067 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ff96c7ceba22b5663bee08da4633ed9"></a><!-- doxytag: member="usart.c::usart_putchar" ref="2ff96c7ceba22b5663bee08da4633ed9" args="(volatile avr32_usart_t *usart, int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_putchar           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a character with the USART. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Character to write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>The character was written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_FAILURE</em>&nbsp;</td><td>The function timed out before the USART transmitter became ready to send. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00354">354</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00067">USART_DEFAULT_TIMEOUT</a>, <a class="el" href="a00008.html#l00057">USART_FAILURE</a>, <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>, and <a class="el" href="a00007.html#l00342">usart_write_char()</a>.
<p>
Referenced by <a class="el" href="a00007.html#l00417">usart_get_echo_line()</a>, and <a class="el" href="a00007.html#l00410">usart_write_line()</a>.<div class="fragment"><pre class="fragment"><a name="l00355"></a>00355 {
<a name="l00356"></a>00356   <span class="keywordtype">int</span> timeout = <a class="code" href="a00005.html#c8dc7a35914ec78bd7382630499bd856">USART_DEFAULT_TIMEOUT</a>;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="keywordflow">if</span> (c == <span class="charliteral">'\n'</span>)
<a name="l00359"></a>00359   {
<a name="l00360"></a>00360     <span class="keywordflow">do</span>
<a name="l00361"></a>00361     {
<a name="l00362"></a>00362       <span class="keywordflow">if</span> (!timeout--) <span class="keywordflow">return</span> <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00363"></a>00363     } <span class="keywordflow">while</span> (<a class="code" href="a00004.html#0c36f4b2ec5445212642ee7f94672805">usart_write_char</a>(usart, <span class="charliteral">'\r'</span>) != <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     timeout = <a class="code" href="a00005.html#c8dc7a35914ec78bd7382630499bd856">USART_DEFAULT_TIMEOUT</a>;
<a name="l00366"></a>00366   }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="keywordflow">do</span>
<a name="l00369"></a>00369   {
<a name="l00370"></a>00370     <span class="keywordflow">if</span> (!timeout--) <span class="keywordflow">return</span> <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00371"></a>00371   } <span class="keywordflow">while</span> (<a class="code" href="a00004.html#0c36f4b2ec5445212642ee7f94672805">usart_write_char</a>(usart, c) != <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>);
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00374"></a>00374 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b73fc2f42bd6fe66c03d598b0158436d"></a><!-- doxytag: member="usart.c::usart_read_char" ref="b73fc2f42bd6fe66c03d598b0158436d" args="(volatile avr32_usart_t *usart, int *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_read_char           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks the RX buffer for a received character, and stores it at the given memory location. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Pointer to the where the read character should be stored (must be at least short in order to accept 9-bit characters).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>The character was read successfully. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_RX_EMPTY</em>&nbsp;</td><td>The RX buffer was empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_RX_ERROR</em>&nbsp;</td><td>An error was deteceted. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00377">377</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00061">USART_RX_EMPTY</a>, <a class="el" href="a00008.html#l00062">USART_RX_ERROR</a>, <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>, and <a class="el" href="a00008.html#l00445">usart_test_hit()</a>.
<p>
Referenced by <a class="el" href="a00007.html#l00397">usart_getchar()</a>.<div class="fragment"><pre class="fragment"><a name="l00378"></a>00378 {
<a name="l00379"></a>00379   <span class="comment">// Check for errors: frame, parity and overrun. In RS485 mode, a parity error</span>
<a name="l00380"></a>00380   <span class="comment">// would mean that an address char has been received.</span>
<a name="l00381"></a>00381   <span class="keywordflow">if</span> (usart-&gt;csr &amp; (AVR32_USART_CSR_OVRE_MASK |
<a name="l00382"></a>00382                     AVR32_USART_CSR_FRAME_MASK |
<a name="l00383"></a>00383                     AVR32_USART_CSR_PARE_MASK))
<a name="l00384"></a>00384     <span class="keywordflow">return</span> <a class="code" href="a00005.html#ffa1a7abf4e6ce54c0b64cc0826f8b4d">USART_RX_ERROR</a>;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="comment">// No error; if we really did receive a char, read it and return SUCCESS.</span>
<a name="l00387"></a>00387   <span class="keywordflow">if</span> (<a class="code" href="a00005.html#19cf203f3919a6358eb831d513b0ee1c">usart_test_hit</a>(usart))
<a name="l00388"></a>00388   {
<a name="l00389"></a>00389     *c = (<span class="keywordtype">unsigned</span> short)usart-&gt;rhr;
<a name="l00390"></a>00390     <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00391"></a>00391   }
<a name="l00392"></a>00392   <span class="keywordflow">else</span>
<a name="l00393"></a>00393     <span class="keywordflow">return</span> <a class="code" href="a00005.html#deb9432170d2d09a4ffbb098a1b4335e">USART_RX_EMPTY</a>;
<a name="l00394"></a>00394 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="31cf4d67fd204fb4684fff9d7994cb4c"></a><!-- doxytag: member="usart.c::usart_reset" ref="31cf4d67fd204fb4684fff9d7994cb4c" args="(volatile avr32_usart_t *usart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usart_reset           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the USART and disables TX and RX. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00133">133</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
Referenced by <a class="el" href="a00007.html#l00269">usart_init_iso7816()</a>, and <a class="el" href="a00007.html#l00156">usart_init_rs232()</a>.<div class="fragment"><pre class="fragment"><a name="l00134"></a>00134 {
<a name="l00135"></a>00135   <span class="comment">// Disable all USART interrupts.</span>
<a name="l00136"></a>00136   <span class="comment">// Interrupts needed should be set explicitly on every reset.</span>
<a name="l00137"></a>00137   usart-&gt;idr = 0xFFFFFFFF;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   <span class="comment">// Reset mode and other registers that could cause unpredictable behavior after reset.</span>
<a name="l00140"></a>00140   usart-&gt;mr = 0;
<a name="l00141"></a>00141   usart-&gt;rtor = 0;
<a name="l00142"></a>00142   usart-&gt;ttgr = 0;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="comment">// Shutdown TX and RX (will be re-enabled when setup has successfully completed),</span>
<a name="l00145"></a>00145   <span class="comment">// reset status bits and turn off DTR and RTS.</span>
<a name="l00146"></a>00146   usart-&gt;cr = AVR32_USART_CR_RSTRX_MASK   |
<a name="l00147"></a>00147               AVR32_USART_CR_RSTTX_MASK   |
<a name="l00148"></a>00148               AVR32_USART_CR_RSTSTA_MASK  |
<a name="l00149"></a>00149               AVR32_USART_CR_RSTIT_MASK   |
<a name="l00150"></a>00150               AVR32_USART_CR_RSTNACK_MASK |
<a name="l00151"></a>00151               AVR32_USART_CR_DTRDIS_MASK  |
<a name="l00152"></a>00152               AVR32_USART_CR_RTSDIS_MASK;
<a name="l00153"></a>00153 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9f2429a7b9d05f100052dd791fb499df"></a><!-- doxytag: member="usart.c::usart_send_address" ref="9f2429a7b9d05f100052dd791fb499df" args="(volatile avr32_usart_t *usart, int address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_send_address           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Addresses a receiver. 
<p>
While in RS485 mode, receivers only accept data addressed to them. A packet/char with the address tag set has to precede any data. This function is used to address a receiver. This receiver should read all the following data, until an address packet addresses another receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Address of the target device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Address successfully sent (if current mode is RS485). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_MODE_FAULT</em>&nbsp;</td><td>Wrong operating mode. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00327">327</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00420">usart_bw_write_char()</a>, <a class="el" href="a00008.html#l00063">USART_MODE_FAULT</a>, <a class="el" href="a00007.html#l00064">usart_mode_is_multidrop()</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.<div class="fragment"><pre class="fragment"><a name="l00328"></a>00328 {
<a name="l00329"></a>00329   <span class="comment">// Check if USART is in multidrop / RS485 mode.</span>
<a name="l00330"></a>00330   <span class="keywordflow">if</span> (!<a class="code" href="a00004.html#ab614b60efcf070b5db36d2b92632e30">usart_mode_is_multidrop</a>(usart)) <span class="keywordflow">return</span> <a class="code" href="a00005.html#e4cc0f3559c44ca2c72a8bd3a340b480">USART_MODE_FAULT</a>;
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="comment">// Prepare to send an address.</span>
<a name="l00333"></a>00333   usart-&gt;cr |= AVR32_USART_CR_SENDA_MASK;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="comment">// Write the address to TX.</span>
<a name="l00336"></a>00336   <a class="code" href="a00005.html#929bd6ebffb90048b1928a4e9467610a">usart_bw_write_char</a>(usart, address);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00339"></a>00339 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7fbc9a9a50b67071a735edd78ec2601e"></a><!-- doxytag: member="usart.c::usart_set_baudrate" ref="7fbc9a9a50b67071a735edd78ec2601e" args="(volatile avr32_usart_t *usart, unsigned int baudrate, long pba_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int usart_set_baudrate           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>pba_hz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates a clock divider (<em>CD</em>) that gets the USART as close to a wanted baudrate as possible. 
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>manage the FP fractal part to avoid big errors</dd></dl>
Baudrate calculation: <img class="formulaInl" alt="$ baudrate = \frac{Selected Clock}{16 \times CD} $" src="form_0.png"> with 16x oversampling or <img class="formulaInl" alt="$ baudrate = \frac{Selected Clock}{8 \times CD} $" src="form_1.png"> with 8x oversampling or <img class="formulaInl" alt="$ baudrate = \frac{Selected Clock}{CD} $" src="form_2.png"> with SYNC bit set to allow high speed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baudrate</em>&nbsp;</td><td>Wanted baudrate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pba_hz</em>&nbsp;</td><td>USART module input clock frequency (PBA clock, Hz).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>Baudrate successfully initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_INVALID_INPUT</em>&nbsp;</td><td>Wanted baudrate is impossible with given clock speed. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00087">87</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00058">USART_INVALID_INPUT</a>, and <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>.
<p>
Referenced by <a class="el" href="a00007.html#l00269">usart_init_iso7816()</a>, and <a class="el" href="a00007.html#l00156">usart_init_rs232()</a>.<div class="fragment"><pre class="fragment"><a name="l00088"></a>00088 {
<a name="l00089"></a>00089   <span class="comment">// Clock divider.</span>
<a name="l00090"></a>00090   <span class="keywordtype">int</span> cd;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="comment">// Baudrate calculation.</span>
<a name="l00093"></a>00093   <span class="keywordflow">if</span> (baudrate &lt; pba_hz / 16)
<a name="l00094"></a>00094   {
<a name="l00095"></a>00095     <span class="comment">// Use 16x oversampling, clear SYNC bit.</span>
<a name="l00096"></a>00096     usart-&gt;mr &amp;=~ (AVR32_USART_MR_OVER_MASK | AVR32_USART_MR_SYNC_MASK);
<a name="l00097"></a>00097     cd = (pba_hz + 8 * baudrate) / (16 * baudrate); 
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="keywordflow">if</span> ((cd &gt;65535)) <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00100"></a>00100   }
<a name="l00101"></a>00101   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (baudrate &lt; pba_hz / 8)
<a name="l00102"></a>00102   {
<a name="l00103"></a>00103     <span class="comment">// Use 8x oversampling.</span>
<a name="l00104"></a>00104     usart-&gt;mr |= AVR32_USART_MR_OVER_MASK;
<a name="l00105"></a>00105     <span class="comment">// clear SYNC bit</span>
<a name="l00106"></a>00106     usart-&gt;mr &amp;=~ AVR32_USART_MR_SYNC_MASK;
<a name="l00107"></a>00107         
<a name="l00108"></a>00108     cd = (pba_hz + 4 * baudrate) / (8 * baudrate);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     <span class="keywordflow">if</span> ((cd &lt; 1)||(cd &gt;65535)) <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112   <span class="keywordflow">else</span>
<a name="l00113"></a>00113   {
<a name="l00114"></a>00114     <span class="comment">// set SYNC to 1 </span>
<a name="l00115"></a>00115     usart-&gt;mr |= AVR32_USART_MR_SYNC_MASK;
<a name="l00116"></a>00116     <span class="comment">// use PBA/BaudRate</span>
<a name="l00117"></a>00117     cd = (pba_hz / baudrate);    
<a name="l00118"></a>00118   }
<a name="l00119"></a>00119   usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00122"></a>00122 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0c36f4b2ec5445212642ee7f94672805"></a><!-- doxytag: member="usart.c::usart_write_char" ref="0c36f4b2ec5445212642ee7f94672805" args="(volatile avr32_usart_t *usart, int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usart_write_char           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given character to the TX buffer if the transmitter is ready. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The character (up to 9 bits) to transmit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>USART_SUCCESS</em>&nbsp;</td><td>The transmitter was ready. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>USART_TX_BUSY</em>&nbsp;</td><td>The transmitter was busy. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00342">342</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00008.html#l00056">USART_SUCCESS</a>, <a class="el" href="a00008.html#l00060">USART_TX_BUSY</a>, and <a class="el" href="a00008.html#l00463">usart_tx_ready()</a>.
<p>
Referenced by <a class="el" href="a00008.html#l00420">usart_bw_write_char()</a>, and <a class="el" href="a00007.html#l00354">usart_putchar()</a>.<div class="fragment"><pre class="fragment"><a name="l00343"></a>00343 {
<a name="l00344"></a>00344   <span class="keywordflow">if</span> (<a class="code" href="a00005.html#c5af9fda2bfa202a386a83c3c4a92289">usart_tx_ready</a>(usart))
<a name="l00345"></a>00345   {
<a name="l00346"></a>00346     usart-&gt;thr = c;
<a name="l00347"></a>00347     <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00348"></a>00348   }
<a name="l00349"></a>00349   <span class="keywordflow">else</span>
<a name="l00350"></a>00350     <span class="keywordflow">return</span> <a class="code" href="a00005.html#481df5bfed5fec78ff5697b335ab5947">USART_TX_BUSY</a>;
<a name="l00351"></a>00351 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2090c77f008cbbde81b5047b91a9826d"></a><!-- doxytag: member="usart.c::usart_write_line" ref="2090c77f008cbbde81b5047b91a9826d" args="(volatile avr32_usart_t *usart, const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usart_write_line           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_usart_t *&nbsp;</td>
          <td class="paramname"> <em>usart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes one character string to the USART. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usart</em>&nbsp;</td><td>Base address of the USART instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>String to be written. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00007.html#l00410">410</a> of file <a class="el" href="a00007.html">usart.c</a>.
<p>
References <a class="el" href="a00007.html#l00354">usart_putchar()</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00117">main()</a>, and <a class="el" href="a00007.html#l00417">usart_get_echo_line()</a>.<div class="fragment"><pre class="fragment"><a name="l00411"></a>00411 {
<a name="l00412"></a>00412   <span class="keywordflow">while</span> (*string != <span class="charliteral">'\0'</span>)
<a name="l00413"></a>00413     <a class="code" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a>(usart, *string++);
<a name="l00414"></a>00414 }
</pre></div>
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Sep 20 12:16:55 2007 for AVR32 UC3 - USART Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
