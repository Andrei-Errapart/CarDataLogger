<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR32 UC3 - USART Driver: usart.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>usart.c</h1><a href="a00004.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*This file is prepared for Doxygen automatic documentation generation.*/</span>
<a name="l00018"></a>00018 <span class="comment">/* Copyright (c) 2007, Atmel Corporation All rights reserved.</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00021"></a>00021 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023"></a>00023 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
<a name="l00024"></a>00024 <span class="comment"> * this list of conditions and the following disclaimer.</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<a name="l00027"></a>00027 <span class="comment"> * this list of conditions and the following disclaimer in the documentation</span>
<a name="l00028"></a>00028 <span class="comment"> * and/or other materials provided with the distribution.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * 3. The name of ATMEL may not be used to endorse or promote products derived</span>
<a name="l00031"></a>00031 <span class="comment"> * from this software without specific prior written permission.</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED</span>
<a name="l00034"></a>00034 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00035"></a>00035 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND</span>
<a name="l00036"></a>00036 <span class="comment"> * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,</span>
<a name="l00037"></a>00037 <span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<a name="l00038"></a>00038 <span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<a name="l00039"></a>00039 <span class="comment"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<a name="l00040"></a>00040 <span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00041"></a>00041 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a name="l00042"></a>00042 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00043"></a>00043 <span class="comment"> */</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#include "<a class="code" href="a00005.html">usart.h</a>"</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 
<a name="l00061"></a>00061 <span class="preprocessor">#if __GNUC__</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>__attribute__((__always_inline__))
<a name="l00063"></a>00063 <span class="preprocessor">#endif</span>
<a name="l00064"></a><a class="code" href="a00004.html#ab614b60efcf070b5db36d2b92632e30">00064</a> <span class="preprocessor"></span><span class="keyword">static</span> __inline__ <span class="keywordtype">int</span> <a class="code" href="a00004.html#ab614b60efcf070b5db36d2b92632e30">usart_mode_is_multidrop</a>(<span class="keyword">volatile</span> avr32_usart_t *usart)
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066   <span class="keywordflow">return</span> ((usart-&gt;mr &gt;&gt; AVR32_USART_MR_PAR_OFFSET) &amp; AVR32_USART_MR_PAR_MULTI) == AVR32_USART_MR_PAR_MULTI;
<a name="l00067"></a>00067 }
<a name="l00068"></a>00068 
<a name="l00087"></a><a class="code" href="a00004.html#7fbc9a9a50b67071a735edd78ec2601e">00087</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="a00004.html#7fbc9a9a50b67071a735edd78ec2601e">usart_set_baudrate</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baudrate, <span class="keywordtype">long</span> pba_hz)
<a name="l00088"></a>00088 {
<a name="l00089"></a>00089   <span class="comment">// Clock divider.</span>
<a name="l00090"></a>00090   <span class="keywordtype">int</span> cd;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="comment">// Baudrate calculation.</span>
<a name="l00093"></a>00093   <span class="keywordflow">if</span> (baudrate &lt; pba_hz / 16)
<a name="l00094"></a>00094   {
<a name="l00095"></a>00095     <span class="comment">// Use 16x oversampling, clear SYNC bit.</span>
<a name="l00096"></a>00096     usart-&gt;mr &amp;=~ (AVR32_USART_MR_OVER_MASK | AVR32_USART_MR_SYNC_MASK);
<a name="l00097"></a>00097     cd = (pba_hz + 8 * baudrate) / (16 * baudrate); 
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="keywordflow">if</span> ((cd &gt;65535)) <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00100"></a>00100   }
<a name="l00101"></a>00101   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (baudrate &lt; pba_hz / 8)
<a name="l00102"></a>00102   {
<a name="l00103"></a>00103     <span class="comment">// Use 8x oversampling.</span>
<a name="l00104"></a>00104     usart-&gt;mr |= AVR32_USART_MR_OVER_MASK;
<a name="l00105"></a>00105     <span class="comment">// clear SYNC bit</span>
<a name="l00106"></a>00106     usart-&gt;mr &amp;=~ AVR32_USART_MR_SYNC_MASK;
<a name="l00107"></a>00107         
<a name="l00108"></a>00108     cd = (pba_hz + 4 * baudrate) / (8 * baudrate);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110     <span class="keywordflow">if</span> ((cd &lt; 1)||(cd &gt;65535)) <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112   <span class="keywordflow">else</span>
<a name="l00113"></a>00113   {
<a name="l00114"></a>00114     <span class="comment">// set SYNC to 1 </span>
<a name="l00115"></a>00115     usart-&gt;mr |= AVR32_USART_MR_SYNC_MASK;
<a name="l00116"></a>00116     <span class="comment">// use PBA/BaudRate</span>
<a name="l00117"></a>00117     cd = (pba_hz / baudrate);    
<a name="l00118"></a>00118   }
<a name="l00119"></a>00119   usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123 
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00130"></a>00130 <span class="comment"></span>
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 
<a name="l00133"></a><a class="code" href="a00005.html#31cf4d67fd204fb4684fff9d7994cb4c">00133</a> <span class="keywordtype">void</span> <a class="code" href="a00004.html#31cf4d67fd204fb4684fff9d7994cb4c">usart_reset</a>(<span class="keyword">volatile</span> avr32_usart_t *usart)
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135   <span class="comment">// Disable all USART interrupts.</span>
<a name="l00136"></a>00136   <span class="comment">// Interrupts needed should be set explicitly on every reset.</span>
<a name="l00137"></a>00137   usart-&gt;idr = 0xFFFFFFFF;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   <span class="comment">// Reset mode and other registers that could cause unpredictable behavior after reset.</span>
<a name="l00140"></a>00140   usart-&gt;mr = 0;
<a name="l00141"></a>00141   usart-&gt;rtor = 0;
<a name="l00142"></a>00142   usart-&gt;ttgr = 0;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="comment">// Shutdown TX and RX (will be re-enabled when setup has successfully completed),</span>
<a name="l00145"></a>00145   <span class="comment">// reset status bits and turn off DTR and RTS.</span>
<a name="l00146"></a>00146   usart-&gt;cr = AVR32_USART_CR_RSTRX_MASK   |
<a name="l00147"></a>00147               AVR32_USART_CR_RSTTX_MASK   |
<a name="l00148"></a>00148               AVR32_USART_CR_RSTSTA_MASK  |
<a name="l00149"></a>00149               AVR32_USART_CR_RSTIT_MASK   |
<a name="l00150"></a>00150               AVR32_USART_CR_RSTNACK_MASK |
<a name="l00151"></a>00151               AVR32_USART_CR_DTRDIS_MASK  |
<a name="l00152"></a>00152               AVR32_USART_CR_RTSDIS_MASK;
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a><a class="code" href="a00005.html#f8b81384234af455b491c44447d896f1">00156</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keyword">const</span> <a class="code" href="a00002.html">usart_options_t</a> *opt, <span class="keywordtype">long</span> pba_hz)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158   <span class="comment">// Reset the USART and shutdown TX and RX.</span>
<a name="l00159"></a>00159   <a class="code" href="a00004.html#31cf4d67fd204fb4684fff9d7994cb4c">usart_reset</a>(usart);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="comment">// Check input values.</span>
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (!opt) <span class="comment">// Null pointer.</span>
<a name="l00163"></a>00163     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> &lt; 5 || opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> &gt; 9 ||
<a name="l00165"></a>00165       opt-&gt;<a class="code" href="a00002.html#85401f7a6f516a5883adc0538dc27f8e">paritytype</a> &gt; 7 ||
<a name="l00166"></a>00166       opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> &gt; 2 + 255 ||
<a name="l00167"></a>00167       opt-&gt;<a class="code" href="a00002.html#0dc365b8779891743180e9b69116f5ea">channelmode</a> &gt; 3)
<a name="l00168"></a>00168     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#7fbc9a9a50b67071a735edd78ec2601e">usart_set_baudrate</a>(usart, opt-&gt;<a class="code" href="a00002.html#276ad428776a25b8247762bd2c82b35b">baudrate</a>, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00171"></a>00171     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> == 9)
<a name="l00174"></a>00174   {
<a name="l00175"></a>00175     <span class="comment">// Character length set to 9 bits. MODE9 dominates CHRL.</span>
<a name="l00176"></a>00176     usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
<a name="l00177"></a>00177   }
<a name="l00178"></a>00178   <span class="keywordflow">else</span>
<a name="l00179"></a>00179   {
<a name="l00180"></a>00180     <span class="comment">// CHRL gives the character length (- 5) when MODE9 = 0.</span>
<a name="l00181"></a>00181     usart-&gt;mr |= (opt-&gt;<a class="code" href="a00002.html#a6b77cc05829d2e70ee7f96194c6ce23">charlength</a> - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   usart-&gt;mr |= (opt-&gt;<a class="code" href="a00002.html#0dc365b8779891743180e9b69116f5ea">channelmode</a> &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET) |
<a name="l00185"></a>00185                (opt-&gt;<a class="code" href="a00002.html#85401f7a6f516a5883adc0538dc27f8e">paritytype</a> &lt;&lt; AVR32_USART_MR_PAR_OFFSET);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> &gt; <a class="code" href="a00005.html#33058202439211b539aa2e9478f785bd">USART_2_STOPBITS</a>)
<a name="l00188"></a>00188   {
<a name="l00189"></a>00189     <span class="comment">// Set two stop bits</span>
<a name="l00190"></a>00190     usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
<a name="l00191"></a>00191     <span class="comment">// and a timeguard period gives the rest.</span>
<a name="l00192"></a>00192     usart-&gt;ttgr = opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> - <a class="code" href="a00005.html#33058202439211b539aa2e9478f785bd">USART_2_STOPBITS</a>;
<a name="l00193"></a>00193   }
<a name="l00194"></a>00194   <span class="keywordflow">else</span>
<a name="l00195"></a>00195     <span class="comment">// Insert 1, 1.5 or 2 stop bits.</span>
<a name="l00196"></a>00196     usart-&gt;mr |= opt-&gt;<a class="code" href="a00002.html#433a6ede2186d42b4cf19ef4b370cd61">stopbits</a> &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="comment">// Setup complete; enable communication.</span>
<a name="l00199"></a>00199   <span class="comment">// Enable input and output.</span>
<a name="l00200"></a>00200   usart-&gt;cr |= AVR32_USART_CR_TXEN_MASK |
<a name="l00201"></a>00201                AVR32_USART_CR_RXEN_MASK;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00204"></a>00204 }
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 
<a name="l00207"></a><a class="code" href="a00005.html#dfacf6f496aa8131fbb5587ff4a2594c">00207</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#dfacf6f496aa8131fbb5587ff4a2594c">usart_init_hw_handshaking</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keyword">const</span> <a class="code" href="a00002.html">usart_options_t</a> *opt, <span class="keywordtype">long</span> pba_hz)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00210"></a>00210   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00211"></a>00211     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="comment">// Clear previous mode.</span>
<a name="l00214"></a>00214   usart-&gt;mr &amp;= ~AVR32_USART_MR_MODE_MASK;
<a name="l00215"></a>00215   <span class="comment">// Hardware handshaking.</span>
<a name="l00216"></a>00216   usart-&gt;mr |= <a class="code" href="a00005.html#20f58bd59d4177ad2981c8fa338a95af">USART_MODE_HW_HSH</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00219"></a>00219 }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 
<a name="l00222"></a><a class="code" href="a00005.html#91b8eae5a6df18a73c16f86fe4109a61">00222</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#91b8eae5a6df18a73c16f86fe4109a61">usart_init_IrDA</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keyword">const</span> <a class="code" href="a00002.html">usart_options_t</a> *opt,
<a name="l00223"></a>00223                     <span class="keywordtype">long</span> pba_hz, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> irda_filter)
<a name="l00224"></a>00224 {
<a name="l00225"></a>00225   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00226"></a>00226   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00227"></a>00227     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   <span class="comment">// Set IrDA counter.</span>
<a name="l00230"></a>00230   usart-&gt;ifr = irda_filter;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">// Activate "low-pass filtering" of input.</span>
<a name="l00233"></a>00233   usart-&gt;mr |= AVR32_USART_MR_FILTER_MASK;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 
<a name="l00239"></a><a class="code" href="a00005.html#528f0115991d4e9e15b4ccb44e7bf225">00239</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#528f0115991d4e9e15b4ccb44e7bf225">usart_init_modem</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keyword">const</span> <a class="code" href="a00002.html">usart_options_t</a> *opt, <span class="keywordtype">long</span> pba_hz)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00242"></a>00242   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00243"></a>00243     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   <span class="comment">// Clear previous mode.</span>
<a name="l00246"></a>00246   usart-&gt;mr &amp;= ~AVR32_USART_MR_MODE_MASK;
<a name="l00247"></a>00247   <span class="comment">// Set modem mode.</span>
<a name="l00248"></a>00248   usart-&gt;mr |= <a class="code" href="a00005.html#e01dfbdf6f2d1c148b0320e19f8fa98e">USART_MODE_MODEM</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 
<a name="l00254"></a><a class="code" href="a00005.html#31249a0033e1c21e42271f482ab81e22">00254</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#31249a0033e1c21e42271f482ab81e22">usart_init_rs485</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keyword">const</span> <a class="code" href="a00002.html">usart_options_t</a> *opt, <span class="keywordtype">long</span> pba_hz)
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256   <span class="comment">// First: Setup standard RS232.</span>
<a name="l00257"></a>00257   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#f8b81384234af455b491c44447d896f1">usart_init_rs232</a>(usart, opt, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00258"></a>00258     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260   <span class="comment">// Clear previous mode.</span>
<a name="l00261"></a>00261   usart-&gt;mr &amp;= ~AVR32_USART_MR_MODE_MASK;
<a name="l00262"></a>00262   <span class="comment">// Set RS485 mode.</span>
<a name="l00263"></a>00263   usart-&gt;mr |= <a class="code" href="a00005.html#a2946a63275da85d3b578044a88bbd7d">USART_MODE_RS485</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 
<a name="l00269"></a><a class="code" href="a00005.html#ad48e7e51e5af8393794d15f0c5e5c75">00269</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#ad48e7e51e5af8393794d15f0c5e5c75">usart_init_iso7816</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keyword">const</span> <a class="code" href="a00001.html">iso7816_options_t</a> *opt, <span class="keywordtype">int</span> t, <span class="keywordtype">long</span> pba_hz)
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271   <span class="comment">// Reset the USART and shutdown TX and RX.</span>
<a name="l00272"></a>00272   <a class="code" href="a00004.html#31cf4d67fd204fb4684fff9d7994cb4c">usart_reset</a>(usart);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="comment">// Check input values.</span>
<a name="l00275"></a>00275   <span class="keywordflow">if</span> (!opt) <span class="comment">// Null pointer.</span>
<a name="l00276"></a>00276     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keywordflow">if</span> (t == 0)
<a name="l00279"></a>00279   {
<a name="l00280"></a>00280     <span class="comment">// Set USART mode to ISO7816, T=0.</span>
<a name="l00281"></a>00281     <span class="comment">// The T=0 protocol always uses 2 stop bits.</span>
<a name="l00282"></a>00282     usart-&gt;mr = (<a class="code" href="a00005.html#af44f2a4560d84b228624189aad26d5e">USART_MODE_ISO7816_T0</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET) |
<a name="l00283"></a>00283                 (AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET) |
<a name="l00284"></a>00284                 (opt-&gt;<a class="code" href="a00001.html#96af893cd6275fd35a063a235f489a82">bit_order</a> &lt;&lt; AVR32_USART_MR_MSBF_OFFSET); <span class="comment">// Allow MSBF in T=0.</span>
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t == 1)
<a name="l00287"></a>00287   {
<a name="l00288"></a>00288     <span class="comment">// Only LSB first in the T=1 protocol.</span>
<a name="l00289"></a>00289     <span class="comment">// max_iterations field is only used in T=0 mode.</span>
<a name="l00290"></a>00290     <span class="keywordflow">if</span> (opt-&gt;<a class="code" href="a00001.html#96af893cd6275fd35a063a235f489a82">bit_order</a> != 0 ||
<a name="l00291"></a>00291         opt-&gt;<a class="code" href="a00001.html#4c74df529ed76d2962f54cd1f0f5027f">max_iterations</a> != 0)
<a name="l00292"></a>00292       <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00293"></a>00293     <span class="comment">// Set USART mode to ISO7816, T=1.</span>
<a name="l00294"></a>00294     <span class="comment">// The T=1 protocol always uses 1 stop bit.</span>
<a name="l00295"></a>00295     usart-&gt;mr = (<a class="code" href="a00005.html#20cc4cd0b851232cd6b3680713792a44">USART_MODE_ISO7816_T1</a> &lt;&lt; AVR32_USART_MR_MODE_OFFSET) |
<a name="l00296"></a>00296                 (AVR32_USART_MR_NBSTOP_1 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET);
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298   <span class="keywordflow">else</span>
<a name="l00299"></a>00299     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="keywordflow">if</span> (<a class="code" href="a00004.html#7fbc9a9a50b67071a735edd78ec2601e">usart_set_baudrate</a>(usart, opt-&gt;<a class="code" href="a00001.html#6670bdcae159decd3ff5c00f6f3f4fcc">iso7816_hz</a>, pba_hz) == <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>)
<a name="l00302"></a>00302     <span class="keywordflow">return</span> <a class="code" href="a00005.html#50b4e9378f434da8823badca3af2f15d">USART_INVALID_INPUT</a>;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="comment">// Set FIDI register: bit rate = selected clock/FI_DI_ratio/16.</span>
<a name="l00305"></a>00305   usart-&gt;fidi = opt-&gt;<a class="code" href="a00001.html#bf0d2900a6f8f97c0163176f2600551c">fidi_ratio</a>;
<a name="l00306"></a>00306   <span class="comment">// Set ISO7816 spesific options in the MODE register.</span>
<a name="l00307"></a>00307   usart-&gt;mr |= (opt-&gt;<a class="code" href="a00001.html#128f4d404bb0369177a591eb8a0a9269">inhibit_nack</a> &lt;&lt; AVR32_USART_MR_INACK_OFFSET) |
<a name="l00308"></a>00308                (opt-&gt;<a class="code" href="a00001.html#b8d335e18629f4fcf625e1a7e23e35be">dis_suc_nack</a> &lt;&lt; AVR32_USART_MR_DSNACK_OFFSET) |
<a name="l00309"></a>00309                (opt-&gt;<a class="code" href="a00001.html#4c74df529ed76d2962f54cd1f0f5027f">max_iterations</a> &lt;&lt; AVR32_USART_MR_MAX_ITERATION_OFFSET) |
<a name="l00310"></a>00310                AVR32_USART_MR_CLKO_MASK;  <span class="comment">// Enable clock output.</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312   <span class="comment">// Setup complete; enable input.</span>
<a name="l00313"></a>00313   <span class="comment">// Leave TX disabled for now.</span>
<a name="l00314"></a>00314   usart-&gt;cr |= AVR32_USART_CR_RXEN_MASK;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00317"></a>00317 }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00324"></a>00324 <span class="comment"></span>
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 
<a name="l00327"></a><a class="code" href="a00005.html#9f2429a7b9d05f100052dd791fb499df">00327</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#9f2429a7b9d05f100052dd791fb499df">usart_send_address</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keywordtype">int</span> address)
<a name="l00328"></a>00328 {
<a name="l00329"></a>00329   <span class="comment">// Check if USART is in multidrop / RS485 mode.</span>
<a name="l00330"></a>00330   <span class="keywordflow">if</span> (!<a class="code" href="a00004.html#ab614b60efcf070b5db36d2b92632e30">usart_mode_is_multidrop</a>(usart)) <span class="keywordflow">return</span> <a class="code" href="a00005.html#e4cc0f3559c44ca2c72a8bd3a340b480">USART_MODE_FAULT</a>;
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="comment">// Prepare to send an address.</span>
<a name="l00333"></a>00333   usart-&gt;cr |= AVR32_USART_CR_SENDA_MASK;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="comment">// Write the address to TX.</span>
<a name="l00336"></a>00336   <a class="code" href="a00005.html#929bd6ebffb90048b1928a4e9467610a">usart_bw_write_char</a>(usart, address);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00339"></a>00339 }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 
<a name="l00342"></a><a class="code" href="a00005.html#0c36f4b2ec5445212642ee7f94672805">00342</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#0c36f4b2ec5445212642ee7f94672805">usart_write_char</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keywordtype">int</span> c)
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344   <span class="keywordflow">if</span> (<a class="code" href="a00005.html#c5af9fda2bfa202a386a83c3c4a92289">usart_tx_ready</a>(usart))
<a name="l00345"></a>00345   {
<a name="l00346"></a>00346     usart-&gt;thr = c;
<a name="l00347"></a>00347     <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00348"></a>00348   }
<a name="l00349"></a>00349   <span class="keywordflow">else</span>
<a name="l00350"></a>00350     <span class="keywordflow">return</span> <a class="code" href="a00005.html#481df5bfed5fec78ff5697b335ab5947">USART_TX_BUSY</a>;
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 
<a name="l00354"></a><a class="code" href="a00005.html#2ff96c7ceba22b5663bee08da4633ed9">00354</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keywordtype">int</span> c)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356   <span class="keywordtype">int</span> timeout = <a class="code" href="a00005.html#c8dc7a35914ec78bd7382630499bd856">USART_DEFAULT_TIMEOUT</a>;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="keywordflow">if</span> (c == <span class="charliteral">'\n'</span>)
<a name="l00359"></a>00359   {
<a name="l00360"></a>00360     <span class="keywordflow">do</span>
<a name="l00361"></a>00361     {
<a name="l00362"></a>00362       <span class="keywordflow">if</span> (!timeout--) <span class="keywordflow">return</span> <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00363"></a>00363     } <span class="keywordflow">while</span> (<a class="code" href="a00004.html#0c36f4b2ec5445212642ee7f94672805">usart_write_char</a>(usart, <span class="charliteral">'\r'</span>) != <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     timeout = <a class="code" href="a00005.html#c8dc7a35914ec78bd7382630499bd856">USART_DEFAULT_TIMEOUT</a>;
<a name="l00366"></a>00366   }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="keywordflow">do</span>
<a name="l00369"></a>00369   {
<a name="l00370"></a>00370     <span class="keywordflow">if</span> (!timeout--) <span class="keywordflow">return</span> <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00371"></a>00371   } <span class="keywordflow">while</span> (<a class="code" href="a00004.html#0c36f4b2ec5445212642ee7f94672805">usart_write_char</a>(usart, c) != <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>);
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 
<a name="l00377"></a><a class="code" href="a00005.html#b73fc2f42bd6fe66c03d598b0158436d">00377</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#b73fc2f42bd6fe66c03d598b0158436d">usart_read_char</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keywordtype">int</span> *c)
<a name="l00378"></a>00378 {
<a name="l00379"></a>00379   <span class="comment">// Check for errors: frame, parity and overrun. In RS485 mode, a parity error</span>
<a name="l00380"></a>00380   <span class="comment">// would mean that an address char has been received.</span>
<a name="l00381"></a>00381   <span class="keywordflow">if</span> (usart-&gt;csr &amp; (AVR32_USART_CSR_OVRE_MASK |
<a name="l00382"></a>00382                     AVR32_USART_CSR_FRAME_MASK |
<a name="l00383"></a>00383                     AVR32_USART_CSR_PARE_MASK))
<a name="l00384"></a>00384     <span class="keywordflow">return</span> <a class="code" href="a00005.html#ffa1a7abf4e6ce54c0b64cc0826f8b4d">USART_RX_ERROR</a>;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="comment">// No error; if we really did receive a char, read it and return SUCCESS.</span>
<a name="l00387"></a>00387   <span class="keywordflow">if</span> (<a class="code" href="a00005.html#19cf203f3919a6358eb831d513b0ee1c">usart_test_hit</a>(usart))
<a name="l00388"></a>00388   {
<a name="l00389"></a>00389     *c = (<span class="keywordtype">unsigned</span> short)usart-&gt;rhr;
<a name="l00390"></a>00390     <span class="keywordflow">return</span> <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00391"></a>00391   }
<a name="l00392"></a>00392   <span class="keywordflow">else</span>
<a name="l00393"></a>00393     <span class="keywordflow">return</span> <a class="code" href="a00005.html#deb9432170d2d09a4ffbb098a1b4335e">USART_RX_EMPTY</a>;
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 
<a name="l00397"></a><a class="code" href="a00005.html#a751e180b091943b684b48c581aaef3e">00397</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#a751e180b091943b684b48c581aaef3e">usart_getchar</a>(<span class="keyword">volatile</span> avr32_usart_t *usart)
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399   <span class="keywordtype">int</span> c, ret;
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <span class="keywordflow">while</span> ((ret = <a class="code" href="a00004.html#b73fc2f42bd6fe66c03d598b0158436d">usart_read_char</a>(usart, &amp;c)) == <a class="code" href="a00005.html#deb9432170d2d09a4ffbb098a1b4335e">USART_RX_EMPTY</a>);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (ret == <a class="code" href="a00005.html#ffa1a7abf4e6ce54c0b64cc0826f8b4d">USART_RX_ERROR</a>)
<a name="l00404"></a>00404     <span class="keywordflow">return</span> <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="keywordflow">return</span> c;
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 
<a name="l00410"></a><a class="code" href="a00005.html#2090c77f008cbbde81b5047b91a9826d">00410</a> <span class="keywordtype">void</span> <a class="code" href="a00004.html#2090c77f008cbbde81b5047b91a9826d">usart_write_line</a>(<span class="keyword">volatile</span> avr32_usart_t *usart, <span class="keyword">const</span> <span class="keywordtype">char</span> *string)
<a name="l00411"></a>00411 {
<a name="l00412"></a>00412   <span class="keywordflow">while</span> (*string != <span class="charliteral">'\0'</span>)
<a name="l00413"></a>00413     <a class="code" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a>(usart, *string++);
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 
<a name="l00417"></a><a class="code" href="a00005.html#c11b2593b4bd1950ccbd35fe07e582f8">00417</a> <span class="keywordtype">int</span> <a class="code" href="a00004.html#c11b2593b4bd1950ccbd35fe07e582f8">usart_get_echo_line</a>(<span class="keyword">volatile</span> avr32_usart_t *usart)
<a name="l00418"></a>00418 {
<a name="l00419"></a>00419   <span class="keywordtype">int</span> rx_char;
<a name="l00420"></a>00420   <span class="keywordtype">int</span> retval = <a class="code" href="a00005.html#cbf846773f58a382f10f8daf94797059">USART_SUCCESS</a>;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="keywordflow">while</span> (1)
<a name="l00423"></a>00423   {
<a name="l00424"></a>00424     rx_char = <a class="code" href="a00004.html#a751e180b091943b684b48c581aaef3e">usart_getchar</a>(usart);
<a name="l00425"></a>00425     <span class="keywordflow">if</span> (rx_char == <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       <a class="code" href="a00004.html#2090c77f008cbbde81b5047b91a9826d">usart_write_line</a>(usart, <span class="stringliteral">"Error!!!\n"</span>);
<a name="l00428"></a>00428       <span class="keywordflow">break</span>;
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430     <span class="keywordflow">if</span> (rx_char == '\x03')
<a name="l00431"></a>00431     {
<a name="l00432"></a>00432       retval = <a class="code" href="a00005.html#9d2a7464c1aa83a18da59130765036b2">USART_FAILURE</a>;
<a name="l00433"></a>00433       <span class="keywordflow">break</span>;
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435     <a class="code" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a>(usart, rx_char);
<a name="l00436"></a>00436     <span class="keywordflow">if</span> (rx_char == <span class="charliteral">'\r'</span>)
<a name="l00437"></a>00437     {
<a name="l00438"></a>00438       <a class="code" href="a00004.html#2ff96c7ceba22b5663bee08da4633ed9">usart_putchar</a>(usart, <span class="charliteral">'\n'</span>);
<a name="l00439"></a>00439       <span class="keywordflow">break</span>;
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441   }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="keywordflow">return</span> retval;
<a name="l00444"></a>00444 }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Sep 20 12:16:52 2007 for AVR32 UC3 - USART Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
