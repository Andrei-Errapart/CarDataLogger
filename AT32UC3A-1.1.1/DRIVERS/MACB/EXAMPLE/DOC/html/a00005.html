<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR32 - MACB Driver: macb.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>macb.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
MACB driver for EVK1100 board. 
<p>
This file defines a useful set of functions for the MACB interface on AVR32 devices.<p>
<ul>
<li>Compiler: IAR EWAVR32 and GNU GCC for AVR32</li><li>Supported devices: All AVR32 devices with a MACB module can be used.</li><li>AppNote:</li></ul>
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br>
 Support and FAQ: <a href="http://support.atmel.no/">http://support.atmel.no/</a> </dd></dl>

<p>
Definition in file <a class="el" href="a00009.html">macb.c</a>.
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;avr32/io.h&gt;</code><br>
<code>#include &quot;<a class="el" href="a00010.html">macb.h</a>&quot;</code><br>
<code>#include &quot;gpio.h&quot;</code><br>
<code>#include &quot;<a class="el" href="a00008.html">conf_eth.h</a>&quot;</code><br>
<code>#include &quot;intc.h&quot;</code><br>

<p>
<a href="a00009.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#8115a0b9bd8f9ac9254fc78e524df10e">ADDRESS_MASK</a>&nbsp;&nbsp;&nbsp;( ( unsigned long ) 0xFFFFFFFC )</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#ccf5e1be79912b54d4c23875f712cee8">BUFFER_WAIT_DELAY</a>&nbsp;&nbsp;&nbsp;( 2 )</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#507969035dc4ab0c36567f4ea783dc68">portENTER_CRITICAL</a>&nbsp;&nbsp;&nbsp;Disable_global_interrupt</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#b11b1d42d76d38c238249f758072d0a6">portENTER_SWITCHING_ISR</a>()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#e2bb7a15725e564859fe12447d5263da">portEXIT_CRITICAL</a>&nbsp;&nbsp;&nbsp;Enable_global_interrupt</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#70d03a5614513ae52a53c49dbf8e80fd">portEXIT_SWITCHING_ISR</a>()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#739a2a1a0047c98ac1b18ecd25dac092">RX_BUFFER_SIZE</a>&nbsp;&nbsp;&nbsp;128</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#67aa14be90f8368a8691adb4f7a42ed4">RX_WRAP_BIT</a>&nbsp;&nbsp;&nbsp;( ( unsigned long ) 0x02 )</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#a175adc5adb27c4a00feefb6c935ecc8">lMACBSend</a> (volatile avr32_macb_t *macb, char *pcFrom, unsigned long ulLength, long lEndOfFrame)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send ulLength bytes from pcFrom.  <a href="#a175adc5adb27c4a00feefb6c935ecc8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#73c602fbe6d30d664f0ad0bfb82861f8">prvMACB_ISR_NonNakedBehaviour</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#df8f5fd0f5dbf215ef9fc50a5dc5d684">prvProbePHY</a> (volatile avr32_macb_t *macb)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#0f1265d1ebfb3d16f5f46c0b4ea34104">prvSetupDescriptors</a> (volatile avr32_macb_t *macb)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#6764d5a231109b1d2c32c7729de47dfe">prvSetupMACAddress</a> (volatile avr32_macb_t *macb)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#b6b8506f7336a338e517a758031be605">prvSetupMACBInterrupt</a> (volatile avr32_macb_t *macb)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#b9aba6f90d51b2e50e71efc4d40715c8">ulMACBInputLength</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to get length of the next frame in the receive buffers.  <a href="#b9aba6f90d51b2e50e71efc4d40715c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a> (volatile avr32_macb_t *macb, unsigned short usAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#072ec0a505ca0139e7cef8ee79683068">vClearMACBTxBuffer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the Tx interrupt, this function traverses the buffers used to hold the frame that has just completed transmission and marks each as free again.  <a href="#072ec0a505ca0139e7cef8ee79683068"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#e73b91041abc3ea1ee1e91ac1349b69e">vDisableMACBOperations</a> (volatile avr32_macb_t *macb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable MACB operations (Tx and Rx).  <a href="#e73b91041abc3ea1ee1e91ac1349b69e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#4dbe868aa329c90577824aefd3139cef">vMACB_ISR</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#4ca1fe9983732c3de6b2618bec0bfe40">vMACBRead</a> (char *pcTo, unsigned long ulSectionLength, unsigned long ulTotalFrameLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frames can be read from the MACB in multiple sections.  <a href="#4ca1fe9983732c3de6b2618bec0bfe40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#5e67bec889bd6c46ccd3b5cedacf259b">vMACBSetMACAddress</a> (const char *MACAddress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MACB Physical address (SA1B &amp; SA1T registers).  <a href="#5e67bec889bd6c46ccd3b5cedacf259b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#cd68f9f9df0f6c5d03bf43ecfa141fab">vMACBWaitForInput</a> (unsigned long ulTimeOut)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend on a semaphore waiting either for the semaphore to be obtained or a timeout.  <a href="#cd68f9f9df0f6c5d03bf43ecfa141fab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#e9572d576d76d11615804f9892da6cbb">vWriteMDIO</a> (volatile avr32_macb_t *macb, unsigned short usAddress, unsigned short usValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#f84c12942936a4771e62b7503bc6a887">xMACBInit</a> (volatile avr32_macb_t *macb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise the MACB driver.  <a href="#f84c12942936a4771e62b7503bc6a887"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a> [6] = { ETHERNET_CONF_ETHADDR0,ETHERNET_CONF_ETHADDR1,ETHERNET_CONF_ETHADDR2,ETHERNET_CONF_ETHADDR3,ETHERNET_CONF_ETHADDR4,ETHERNET_CONF_ETHADDR5 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#bc6333a566548724a292e47b3d823b9b">DataToRead</a> = FALSE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#7731c709cc48903c1b506003943b1d8d">pcRxBuffer</a> [ETHERNET_CONF_NB_RX_BUFFERS *RX_BUFFER_SIZE]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#409288c455b7adefd2d89455ce0eb6dd">pcTxBuffer</a> [ETHERNET_CONF_NB_TX_BUFFERS *ETHERNET_CONF_TX_BUFFER_SIZE]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">volatile unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile <a class="el" href="a00001.html">AVR32_RxTdDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a> [ETHERNET_CONF_NB_RX_BUFFERS]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static volatile <a class="el" href="a00002.html">AVR32_TxTdDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a> [ETHERNET_CONF_NB_TX_BUFFERS]</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="8115a0b9bd8f9ac9254fc78e524df10e"></a><!-- doxytag: member="macb.c::ADDRESS_MASK" ref="8115a0b9bd8f9ac9254fc78e524df10e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDRESS_MASK&nbsp;&nbsp;&nbsp;( ( unsigned long ) 0xFFFFFFFC )          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00069">69</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00530">prvSetupDescriptors()</a>, and <a class="el" href="a00009.html#l00316">vMACBRead()</a>.
</div>
</div><p>
<a class="anchor" name="ccf5e1be79912b54d4c23875f712cee8"></a><!-- doxytag: member="macb.c::BUFFER_WAIT_DELAY" ref="ccf5e1be79912b54d4c23875f712cee8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFER_WAIT_DELAY&nbsp;&nbsp;&nbsp;( 2 )          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00077">77</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00191">lMACBSend()</a>.
</div>
</div><p>
<a class="anchor" name="507969035dc4ab0c36567f4ea783dc68"></a><!-- doxytag: member="macb.c::portENTER_CRITICAL" ref="507969035dc4ab0c36567f4ea783dc68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define portENTER_CRITICAL&nbsp;&nbsp;&nbsp;Disable_global_interrupt          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00080">80</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00191">lMACBSend()</a>, <a class="el" href="a00009.html#l00898">prvMACB_ISR_NonNakedBehaviour()</a>, <a class="el" href="a00009.html#l00831">vMACBWaitForInput()</a>, and <a class="el" href="a00009.html#l00425">xMACBInit()</a>.
</div>
</div><p>
<a class="anchor" name="b11b1d42d76d38c238249f758072d0a6"></a><!-- doxytag: member="macb.c::portENTER_SWITCHING_ISR" ref="b11b1d42d76d38c238249f758072d0a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define portENTER_SWITCHING_ISR          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00082">82</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00876">vMACB_ISR()</a>.
</div>
</div><p>
<a class="anchor" name="e2bb7a15725e564859fe12447d5263da"></a><!-- doxytag: member="macb.c::portEXIT_CRITICAL" ref="e2bb7a15725e564859fe12447d5263da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define portEXIT_CRITICAL&nbsp;&nbsp;&nbsp;Enable_global_interrupt          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00081">81</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00191">lMACBSend()</a>, <a class="el" href="a00009.html#l00898">prvMACB_ISR_NonNakedBehaviour()</a>, <a class="el" href="a00009.html#l00831">vMACBWaitForInput()</a>, and <a class="el" href="a00009.html#l00425">xMACBInit()</a>.
</div>
</div><p>
<a class="anchor" name="70d03a5614513ae52a53c49dbf8e80fd"></a><!-- doxytag: member="macb.c::portEXIT_SWITCHING_ISR" ref="70d03a5614513ae52a53c49dbf8e80fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define portEXIT_SWITCHING_ISR          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00083">83</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00876">vMACB_ISR()</a>.
</div>
</div><p>
<a class="anchor" name="739a2a1a0047c98ac1b18ecd25dac092"></a><!-- doxytag: member="macb.c::RX_BUFFER_SIZE" ref="739a2a1a0047c98ac1b18ecd25dac092" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RX_BUFFER_SIZE&nbsp;&nbsp;&nbsp;128          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00063">63</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00530">prvSetupDescriptors()</a>, and <a class="el" href="a00009.html#l00316">vMACBRead()</a>.
</div>
</div><p>
<a class="anchor" name="67aa14be90f8368a8691adb4f7a42ed4"></a><!-- doxytag: member="macb.c::RX_WRAP_BIT" ref="67aa14be90f8368a8691adb4f7a42ed4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RX_WRAP_BIT&nbsp;&nbsp;&nbsp;( ( unsigned long ) 0x02 )          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00073">73</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00530">prvSetupDescriptors()</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a175adc5adb27c4a00feefb6c935ecc8"></a><!-- doxytag: member="macb.c::lMACBSend" ref="a175adc5adb27c4a00feefb6c935ecc8" args="(volatile avr32_macb_t *macb, char *pcFrom, unsigned long ulLength, long lEndOfFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lMACBSend           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pcFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ulLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lEndOfFrame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send ulLength bytes from pcFrom. 
<p>
This copies the buffer to one of the MACB Tx buffers, then indicates to the MACB that the buffer is ready. If lEndOfFrame is true then the data being copied is the end of the frame and the frame can be transmitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*macb</em>&nbsp;</td><td>Base address of the MACB </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>*pcFrom</em>&nbsp;</td><td>Address of the data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ulLength</em>&nbsp;</td><td>Length of the frame </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lEndOfFrame</em>&nbsp;</td><td>Flag for End Of Frame</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>length sent. </dd></dl>

<p>
Definition at line <a class="el" href="a00009.html#l00191">191</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00010.html#l00342">AVR32_LAST_BUFFER</a>, <a class="el" href="a00010.html#l00331">AVR32_LENGTH_FRAME</a>, <a class="el" href="a00010.html#l00336">AVR32_TRANSMIT_OK</a>, <a class="el" href="a00010.html#l00337">AVR32_TRANSMIT_WRAP</a>, <a class="el" href="a00009.html#l00077">BUFFER_WAIT_DELAY</a>, <a class="el" href="a00008.html#l00059">ETHERNET_CONF_NB_TX_BUFFERS</a>, <a class="el" href="a00008.html#l00062">ETHERNET_CONF_TX_BUFFER_SIZE</a>, <a class="el" href="a00009.html#l00080">portENTER_CRITICAL</a>, <a class="el" href="a00009.html#l00081">portEXIT_CRITICAL</a>, <a class="el" href="a00010.html#l00292">_AVR32_TxTdDescriptor::status</a>, <a class="el" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">_AVR32_TxTdDescriptor::U_Status</a>, and <a class="el" href="a00009.html#l00108">xTxDescriptors</a>.
<p>
Referenced by <a class="el" href="a00011.html#l00215">macb_example_receive_packet()</a>, <a class="el" href="a00011.html#l00276">macb_example_send_ARP_request()</a>, and <a class="el" href="a00011.html#l00173">macb_example_send_ping_response()</a>.<div class="fragment"><pre class="fragment"><a name="l00192"></a>00192 {
<a name="l00193"></a>00193 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> uxTxBufferIndex = 0;
<a name="l00194"></a>00194 <span class="keywordtype">char</span> *pcBuffer;
<a name="l00195"></a>00195 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulLastBuffer, ulDataBuffered = 0, ulDataRemainingToSend, ulLengthToSend;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="comment">/* If the length of data to be transmitted is greater than each individual</span>
<a name="l00199"></a>00199 <span class="comment">  transmit buffer then the data will be split into more than one buffer.</span>
<a name="l00200"></a>00200 <span class="comment">  Loop until the entire length has been buffered. */</span>
<a name="l00201"></a>00201   <span class="keywordflow">while</span>( ulDataBuffered &lt; ulLength )
<a name="l00202"></a>00202   {
<a name="l00203"></a>00203     <span class="comment">// Is a buffer available ?</span>
<a name="l00204"></a>00204     <span class="keywordflow">while</span>( !( <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ uxTxBufferIndex ].U_Status.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> &amp; <a class="code" href="a00006.html#0c925bc304416e1b04c033cfee1b79d3">AVR32_TRANSMIT_OK</a> ) )
<a name="l00205"></a>00205     {
<a name="l00206"></a>00206       <span class="comment">// There is no room to write the Tx data to the Tx buffer.  </span>
<a name="l00207"></a>00207       <span class="comment">// Wait a short while, then try again.</span>
<a name="l00208"></a>00208 <span class="preprocessor">#ifdef FREERTOS_USED</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>      vTaskDelay( <a class="code" href="a00005.html#ccf5e1be79912b54d4c23875f712cee8">BUFFER_WAIT_DELAY</a> );
<a name="l00210"></a>00210 <span class="preprocessor">#else</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>      __asm__ __volatile__ (<span class="stringliteral">"nop"</span>);      
<a name="l00212"></a>00212 <span class="preprocessor">#endif</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>    }
<a name="l00214"></a>00214   
<a name="l00215"></a>00215     <a class="code" href="a00005.html#507969035dc4ab0c36567f4ea783dc68">portENTER_CRITICAL</a>();
<a name="l00216"></a>00216     {
<a name="l00217"></a>00217       <span class="comment">// Get the address of the buffer from the descriptor, </span>
<a name="l00218"></a>00218       <span class="comment">// then copy the data into the buffer.</span>
<a name="l00219"></a>00219       pcBuffer = ( <span class="keywordtype">char</span> * ) <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ uxTxBufferIndex ].addr;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221       <span class="comment">// How much can we write to the buffer ?</span>
<a name="l00222"></a>00222       ulDataRemainingToSend = ulLength - ulDataBuffered;
<a name="l00223"></a>00223       <span class="keywordflow">if</span>( ulDataRemainingToSend &lt;= <a class="code" href="a00004.html#8b1ddb8402abef501c15c0517dbde60d">ETHERNET_CONF_TX_BUFFER_SIZE</a> )
<a name="l00224"></a>00224       {
<a name="l00225"></a>00225         <span class="comment">// We can write all the remaining bytes.</span>
<a name="l00226"></a>00226         ulLengthToSend = ulDataRemainingToSend;
<a name="l00227"></a>00227       }
<a name="l00228"></a>00228       <span class="keywordflow">else</span>
<a name="l00229"></a>00229       {
<a name="l00230"></a>00230         <span class="comment">// We can't write more than ETH_TX_BUFFER_SIZE in one go.</span>
<a name="l00231"></a>00231         ulLengthToSend = <a class="code" href="a00004.html#8b1ddb8402abef501c15c0517dbde60d">ETHERNET_CONF_TX_BUFFER_SIZE</a>;
<a name="l00232"></a>00232       }
<a name="l00233"></a>00233       <span class="comment">// Copy the data into the buffer.</span>
<a name="l00234"></a>00234       memcpy( ( <span class="keywordtype">void</span> * ) pcBuffer, ( <span class="keywordtype">void</span> * ) &amp;( pcFrom[ ulDataBuffered ] ), ulLengthToSend );
<a name="l00235"></a>00235       ulDataBuffered += ulLengthToSend;
<a name="l00236"></a>00236       <span class="comment">// Is this the last data for the frame ? </span>
<a name="l00237"></a>00237       <span class="keywordflow">if</span>( lEndOfFrame &amp;&amp; ( ulDataBuffered &gt;= ulLength ) )
<a name="l00238"></a>00238       {
<a name="l00239"></a>00239         <span class="comment">// No more data remains for this frame so we can start the transmission.</span>
<a name="l00240"></a>00240         ulLastBuffer = <a class="code" href="a00006.html#51f3e88d73c11f80e143e5633493eb21">AVR32_LAST_BUFFER</a>;
<a name="l00241"></a>00241       }
<a name="l00242"></a>00242       <span class="keywordflow">else</span>
<a name="l00243"></a>00243       {
<a name="l00244"></a>00244         <span class="comment">// More data to come for this frame.</span>
<a name="l00245"></a>00245         ulLastBuffer = 0;
<a name="l00246"></a>00246       }
<a name="l00247"></a>00247       <span class="comment">// Fill out the necessary in the descriptor to get the data sent,</span>
<a name="l00248"></a>00248       <span class="comment">// then move to the next descriptor, wrapping if necessary.</span>
<a name="l00249"></a>00249       <span class="keywordflow">if</span>( uxTxBufferIndex &gt;= ( <a class="code" href="a00004.html#50d350cf7d3d470318d90dbce66756f7">ETHERNET_CONF_NB_TX_BUFFERS</a> - 1 ) )
<a name="l00250"></a>00250       {
<a name="l00251"></a>00251         <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ uxTxBufferIndex ].<a class="code" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">U_Status</a>.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> =   ( ulLengthToSend &amp; ( <span class="keywordtype">unsigned</span> long ) <a class="code" href="a00006.html#60f03dcd701da7595aadab25e2ace3be">AVR32_LENGTH_FRAME</a> )
<a name="l00252"></a>00252                                     | ulLastBuffer
<a name="l00253"></a>00253                                     | <a class="code" href="a00006.html#eff87d3909016f0a6a336037d7637ff0">AVR32_TRANSMIT_WRAP</a>;
<a name="l00254"></a>00254         uxTxBufferIndex = 0;
<a name="l00255"></a>00255       }
<a name="l00256"></a>00256       <span class="keywordflow">else</span>
<a name="l00257"></a>00257       {
<a name="l00258"></a>00258         <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ uxTxBufferIndex ].<a class="code" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">U_Status</a>.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> =   ( ulLengthToSend &amp; ( <span class="keywordtype">unsigned</span> long ) <a class="code" href="a00006.html#60f03dcd701da7595aadab25e2ace3be">AVR32_LENGTH_FRAME</a> )
<a name="l00259"></a>00259                                     | ulLastBuffer;
<a name="l00260"></a>00260         uxTxBufferIndex++;
<a name="l00261"></a>00261       }
<a name="l00262"></a>00262       <span class="comment">/* If this is the last buffer to be sent for this frame we can</span>
<a name="l00263"></a>00263 <span class="comment">         start the transmission. */</span>
<a name="l00264"></a>00264       <span class="keywordflow">if</span>( ulLastBuffer )
<a name="l00265"></a>00265       {
<a name="l00266"></a>00266         macb-&gt;ncr |=  AVR32_MACB_TSTART_MASK;
<a name="l00267"></a>00267       }
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269     <a class="code" href="a00005.html#e2bb7a15725e564859fe12447d5263da">portEXIT_CRITICAL</a>();
<a name="l00270"></a>00270   }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="keywordflow">return</span> PASS;
<a name="l00273"></a>00273 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="73c602fbe6d30d664f0ad0bfb82861f8"></a><!-- doxytag: member="macb.c::prvMACB_ISR_NonNakedBehaviour" ref="73c602fbe6d30d664f0ad0bfb82861f8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static long prvMACB_ISR_NonNakedBehaviour           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00898">898</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00009.html#l00080">portENTER_CRITICAL</a>, <a class="el" href="a00009.html#l00081">portEXIT_CRITICAL</a>, and <a class="el" href="a00009.html#l00495">vClearMACBTxBuffer()</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00876">vMACB_ISR()</a>.<div class="fragment"><pre class="fragment"><a name="l00899"></a>00899 {
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <span class="comment">// Variable definitions can be made now.</span>
<a name="l00902"></a>00902   <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulIntStatus, ulEventStatus;
<a name="l00903"></a>00903   <span class="keywordtype">long</span> xSwitchRequired = FALSE;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905   <span class="comment">// Find the cause of the interrupt.</span>
<a name="l00906"></a>00906   ulIntStatus = AVR32_MACB.isr;
<a name="l00907"></a>00907   ulEventStatus = AVR32_MACB.rsr;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   <span class="keywordflow">if</span>( ( ulIntStatus &amp; AVR32_MACB_IDR_RCOMP_MASK ) || ( ulEventStatus &amp; AVR32_MACB_REC_MASK ) )
<a name="l00910"></a>00910   {
<a name="l00911"></a>00911     <span class="comment">// A frame has been received, signal the IP task so it can process</span>
<a name="l00912"></a>00912     <span class="comment">// the Rx descriptors.</span>
<a name="l00913"></a>00913     <a class="code" href="a00005.html#507969035dc4ab0c36567f4ea783dc68">portENTER_CRITICAL</a>();
<a name="l00914"></a>00914 <span class="preprocessor">#ifdef FREERTOS_USED</span>
<a name="l00915"></a>00915 <span class="preprocessor"></span>    xSwitchRequired = xSemaphoreGiveFromISR( xSemaphore, FALSE );
<a name="l00916"></a>00916 <span class="preprocessor">#else</span>
<a name="l00917"></a>00917 <span class="preprocessor"></span>    <a class="code" href="a00005.html#bc6333a566548724a292e47b3d823b9b">DataToRead</a> = TRUE;   
<a name="l00918"></a>00918 <span class="preprocessor">#endif      </span>
<a name="l00919"></a>00919 <span class="preprocessor"></span>    <a class="code" href="a00005.html#e2bb7a15725e564859fe12447d5263da">portEXIT_CRITICAL</a>();
<a name="l00920"></a>00920     AVR32_MACB.rsr =  AVR32_MACB_REC_MASK;
<a name="l00921"></a>00921     AVR32_MACB.rsr;
<a name="l00922"></a>00922   }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="keywordflow">if</span>( ulIntStatus &amp; AVR32_MACB_TCOMP_MASK )
<a name="l00925"></a>00925   {
<a name="l00926"></a>00926     <span class="comment">// A frame has been transmitted.  Mark all the buffers used by the</span>
<a name="l00927"></a>00927     <span class="comment">// frame just transmitted as free again.</span>
<a name="l00928"></a>00928     <a class="code" href="a00005.html#072ec0a505ca0139e7cef8ee79683068">vClearMACBTxBuffer</a>();
<a name="l00929"></a>00929     AVR32_MACB.tsr =  AVR32_MACB_TSR_COMP_MASK;
<a name="l00930"></a>00930     AVR32_MACB.tsr;
<a name="l00931"></a>00931   }
<a name="l00932"></a>00932 
<a name="l00933"></a>00933   <span class="keywordflow">return</span> ( xSwitchRequired );
<a name="l00934"></a>00934 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="df8f5fd0f5dbf215ef9fc50a5dc5d684"></a><!-- doxytag: member="macb.c::prvProbePHY" ref="df8f5fd0f5dbf215ef9fc50a5dc5d684" args="(volatile avr32_macb_t *macb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Bool prvProbePHY           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00694">694</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00010.html#l00166">ADVERTISE_100FULL</a>, <a class="el" href="a00010.html#l00164">ADVERTISE_100HALF</a>, <a class="el" href="a00010.html#l00162">ADVERTISE_10FULL</a>, <a class="el" href="a00010.html#l00160">ADVERTISE_10HALF</a>, <a class="el" href="a00010.html#l00178">ADVERTISE_ALL</a>, <a class="el" href="a00010.html#l00159">ADVERTISE_CSMA</a>, <a class="el" href="a00010.html#l00129">BMCR_ANENABLE</a>, <a class="el" href="a00010.html#l00126">BMCR_ANRESTART</a>, <a class="el" href="a00010.html#l00125">BMCR_FULLDPLX</a>, <a class="el" href="a00010.html#l00130">BMCR_SPEED100</a>, <a class="el" href="a00010.html#l00140">BMSR_LSTATUS</a>, <a class="el" href="a00008.html#l00105">ETHERNET_CONF_PHY_ID</a>, <a class="el" href="a00010.html#l00191">LPA_100FULL</a>, <a class="el" href="a00010.html#l00189">LPA_100HALF</a>, <a class="el" href="a00010.html#l00187">LPA_10FULL</a>, <a class="el" href="a00010.html#l00104">PHY_ADVERTISE</a>, <a class="el" href="a00010.html#l00100">PHY_BMCR</a>, <a class="el" href="a00010.html#l00101">PHY_BMSR</a>, <a class="el" href="a00010.html#l00105">PHY_LPA</a>, <a class="el" href="a00010.html#l00115">PHY_PHYCR</a>, <a class="el" href="a00010.html#l00102">PHY_PHYSID1</a>, <a class="el" href="a00010.html#l00103">PHY_PHYSID2</a>, <a class="el" href="a00010.html#l00112">PHY_RBR</a>, <a class="el" href="a00010.html#l00237">PHYCR_MDIX_EN</a>, <a class="el" href="a00010.html#l00238">PHYCR_MDIX_FORCE</a>, <a class="el" href="a00010.html#l00207">RBR_RMII</a>, <a class="el" href="a00009.html#l00641">ulReadMDIO()</a>, and <a class="el" href="a00009.html#l00673">vWriteMDIO()</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00425">xMACBInit()</a>.<div class="fragment"><pre class="fragment"><a name="l00695"></a>00695 {
<a name="l00696"></a>00696 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mii_status, phy_ctrl;
<a name="l00697"></a>00697 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> config;
<a name="l00698"></a>00698 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> upper, lower, mode, advertise, lpa;
<a name="l00699"></a>00699 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> physID;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   <span class="comment">// Read Phy Identifier register 1 &amp; 2</span>
<a name="l00702"></a>00702   lower = <a class="code" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a>(macb, <a class="code" href="a00006.html#4a5d76c96aca0781c49a50b733a88f9b">PHY_PHYSID2</a>);
<a name="l00703"></a>00703   upper = <a class="code" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a>(macb, <a class="code" href="a00006.html#bedb91f1cc4ab632148aafaafd6dce9b">PHY_PHYSID1</a>);
<a name="l00704"></a>00704   <span class="comment">// get Phy ID, ignore Revision</span>
<a name="l00705"></a>00705   physID = ((upper &lt;&lt; 16) &amp; 0xFFFF0000) | (lower &amp; 0xFFF0);
<a name="l00706"></a>00706   <span class="comment">// check if it match config</span>
<a name="l00707"></a>00707   <span class="keywordflow">if</span> (physID == <a class="code" href="a00004.html#5069f84904fb580e53a842997baade93">ETHERNET_CONF_PHY_ID</a>)
<a name="l00708"></a>00708   {
<a name="l00709"></a>00709     <span class="comment">// read RBR</span>
<a name="l00710"></a>00710     mode = <a class="code" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a>(macb, <a class="code" href="a00006.html#e877615c3b6b9977de39efebb868a6c3">PHY_RBR</a>);
<a name="l00711"></a>00711     <span class="comment">// set RMII mode if not done</span>
<a name="l00712"></a>00712     <span class="keywordflow">if</span> ((mode &amp; <a class="code" href="a00006.html#d963b4d3875f21bc3ae325d5d46362ce">RBR_RMII</a>) != RBR_RMII)
<a name="l00713"></a>00713     {
<a name="l00714"></a>00714       <span class="comment">// force RMII flag if strap options are wrong</span>
<a name="l00715"></a>00715       mode |= RBR_RMII;
<a name="l00716"></a>00716       <a class="code" href="a00005.html#e9572d576d76d11615804f9892da6cbb">vWriteMDIO</a>(macb, <a class="code" href="a00006.html#e877615c3b6b9977de39efebb868a6c3">PHY_RBR</a>, mode);
<a name="l00717"></a>00717     }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719     <span class="comment">// set advertise register</span>
<a name="l00720"></a>00720 <span class="preprocessor">#if ETHERNET_CONF_AN_ENABLE == 1</span>
<a name="l00721"></a>00721 <span class="preprocessor"></span>    advertise = <a class="code" href="a00006.html#b647449bae73adb5490eb984f9543236">ADVERTISE_CSMA</a> | <a class="code" href="a00006.html#8a3aba4a0b468093806a925a512aa0f9">ADVERTISE_ALL</a>;
<a name="l00722"></a>00722 <span class="preprocessor">#else</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span>    advertise = <a class="code" href="a00006.html#b647449bae73adb5490eb984f9543236">ADVERTISE_CSMA</a>;
<a name="l00724"></a>00724 <span class="preprocessor">    #if ETHERNET_CONF_USE_100MB</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span><span class="preprocessor">      #if ETHERNET_CONF_USE_FULL_DUPLEX</span>
<a name="l00726"></a>00726 <span class="preprocessor"></span>        advertise |= <a class="code" href="a00006.html#5975a54c6b9e81091550081dec5f0a8e">ADVERTISE_100FULL</a>;
<a name="l00727"></a>00727 <span class="preprocessor">      #else</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>        advertise |= <a class="code" href="a00006.html#c6672f1b0898b616cb59f6b3bcacebae">ADVERTISE_100HALF</a>;
<a name="l00729"></a>00729 <span class="preprocessor">      #endif</span>
<a name="l00730"></a>00730 <span class="preprocessor"></span><span class="preprocessor">    #else</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span><span class="preprocessor">      #if ETHERNET_CONF_USE_FULL_DUPLEX</span>
<a name="l00732"></a>00732 <span class="preprocessor"></span>        advertise |= <a class="code" href="a00006.html#b1a970ef866fd7e4f6c903c5a4112614">ADVERTISE_10FULL</a>;
<a name="l00733"></a>00733 <span class="preprocessor">      #else</span>
<a name="l00734"></a>00734 <span class="preprocessor"></span>        advertise |= <a class="code" href="a00006.html#4c4bffe063b77c10a09d5f9dbb2df4d9">ADVERTISE_10HALF</a>;
<a name="l00735"></a>00735 <span class="preprocessor">      #endif</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00738"></a>00738 <span class="preprocessor"></span>    <span class="comment">// write advertise register</span>
<a name="l00739"></a>00739     <a class="code" href="a00005.html#e9572d576d76d11615804f9892da6cbb">vWriteMDIO</a>(macb, <a class="code" href="a00006.html#667948a31a52d75afc374551ef1fd49a">PHY_ADVERTISE</a>, advertise);
<a name="l00740"></a>00740     <span class="comment">// read Control register</span>
<a name="l00741"></a>00741     config = <a class="code" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a>(macb, <a class="code" href="a00006.html#f621c7a972033d0ec01d9e37bcea6d70">PHY_BMCR</a>);
<a name="l00742"></a>00742     <span class="comment">// read Phy Control register</span>
<a name="l00743"></a>00743     phy_ctrl = <a class="code" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a>(macb, <a class="code" href="a00006.html#d59f97ea0c0c4401cd441c8edbb1f576">PHY_PHYCR</a>);
<a name="l00744"></a>00744 <span class="preprocessor">#if ETHERNET_CONF_AN_ENABLE</span>
<a name="l00745"></a>00745 <span class="preprocessor"></span><span class="preprocessor">  #if ETHERNET_CONF_AUTO_CROSS_ENABLE</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span>    <span class="comment">// enable Auto MDIX</span>
<a name="l00747"></a>00747     phy_ctrl |= <a class="code" href="a00006.html#e9e8d01e784edeb9f97821692170a373">PHYCR_MDIX_EN</a>;
<a name="l00748"></a>00748 <span class="preprocessor">  #else</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span>    <span class="comment">// disable Auto MDIX</span>
<a name="l00750"></a>00750     phy_ctrl &amp;= ~<a class="code" href="a00006.html#e9e8d01e784edeb9f97821692170a373">PHYCR_MDIX_EN</a>;
<a name="l00751"></a>00751 <span class="preprocessor">    #if ETHERNET_CONF_CROSSED_LINK</span>
<a name="l00752"></a>00752 <span class="preprocessor"></span>      <span class="comment">// force direct link = Use crossed RJ45 cable</span>
<a name="l00753"></a>00753       phy_ctrl &amp;= ~<a class="code" href="a00006.html#782cfd35a5a53b8b6eebcc3efa5df13a">PHYCR_MDIX_FORCE</a>;
<a name="l00754"></a>00754 <span class="preprocessor">    #else</span>
<a name="l00755"></a>00755 <span class="preprocessor"></span>      <span class="comment">// force crossed link = Use direct RJ45 cable</span>
<a name="l00756"></a>00756       phy_ctrl |= <a class="code" href="a00006.html#782cfd35a5a53b8b6eebcc3efa5df13a">PHYCR_MDIX_FORCE</a>;
<a name="l00757"></a>00757 <span class="preprocessor">    #endif</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span><span class="preprocessor">  #endif</span>
<a name="l00759"></a>00759 <span class="preprocessor"></span>  <span class="comment">// reset auto-negociation capability</span>
<a name="l00760"></a>00760   config |= (<a class="code" href="a00006.html#af6ee3d37d3a0900c1d4f111d6e46a0d">BMCR_ANRESTART</a> | <a class="code" href="a00006.html#bbb374cfa7418178076e49275342bb30">BMCR_ANENABLE</a>);
<a name="l00761"></a>00761 <span class="preprocessor">#else</span>
<a name="l00762"></a>00762 <span class="preprocessor"></span>  <span class="comment">// disable Auto MDIX</span>
<a name="l00763"></a>00763   phy_ctrl &amp;= ~<a class="code" href="a00006.html#e9e8d01e784edeb9f97821692170a373">PHYCR_MDIX_EN</a>;
<a name="l00764"></a>00764 <span class="preprocessor">  #if ETHERNET_CONF_CROSSED_LINK</span>
<a name="l00765"></a>00765 <span class="preprocessor"></span>    <span class="comment">// force direct link = Use crossed RJ45 cable</span>
<a name="l00766"></a>00766     phy_ctrl &amp;= ~<a class="code" href="a00006.html#782cfd35a5a53b8b6eebcc3efa5df13a">PHYCR_MDIX_FORCE</a>;
<a name="l00767"></a>00767 <span class="preprocessor">  #else</span>
<a name="l00768"></a>00768 <span class="preprocessor"></span>    <span class="comment">// force crossed link = Use direct RJ45 cable</span>
<a name="l00769"></a>00769     phy_ctrl |= <a class="code" href="a00006.html#782cfd35a5a53b8b6eebcc3efa5df13a">PHYCR_MDIX_FORCE</a>;
<a name="l00770"></a>00770 <span class="preprocessor">  #endif</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>  <span class="comment">// clear AN bit</span>
<a name="l00772"></a>00772   config &amp;= ~<a class="code" href="a00006.html#bbb374cfa7418178076e49275342bb30">BMCR_ANENABLE</a>;
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="preprocessor">  #if ETHERNET_CONF_USE_100MB</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span>    config |= <a class="code" href="a00006.html#1f472360951f531b07ec2b518103af3d">BMCR_SPEED100</a>;
<a name="l00776"></a>00776 <span class="preprocessor">  #else</span>
<a name="l00777"></a>00777 <span class="preprocessor"></span>    config &amp;= ~<a class="code" href="a00006.html#1f472360951f531b07ec2b518103af3d">BMCR_SPEED100</a>;
<a name="l00778"></a>00778 <span class="preprocessor">  #endif</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span><span class="preprocessor">  #if ETHERNET_CONF_USE_FULL_DUPLEX</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span>    config |= <a class="code" href="a00006.html#f7c53f29b474b34aa738012d9b867cef">BMCR_FULLDPLX</a>;
<a name="l00781"></a>00781 <span class="preprocessor">  #else</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span>    config &amp;= ~<a class="code" href="a00006.html#f7c53f29b474b34aa738012d9b867cef">BMCR_FULLDPLX</a>;
<a name="l00783"></a>00783 <span class="preprocessor">  #endif</span>
<a name="l00784"></a>00784 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>    <span class="comment">// update Phy ctrl register</span>
<a name="l00786"></a>00786     <a class="code" href="a00005.html#e9572d576d76d11615804f9892da6cbb">vWriteMDIO</a>(macb, <a class="code" href="a00006.html#d59f97ea0c0c4401cd441c8edbb1f576">PHY_PHYCR</a>, phy_ctrl);
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     <span class="comment">// update ctrl register</span>
<a name="l00789"></a>00789     <a class="code" href="a00005.html#e9572d576d76d11615804f9892da6cbb">vWriteMDIO</a>(macb, <a class="code" href="a00006.html#f621c7a972033d0ec01d9e37bcea6d70">PHY_BMCR</a>, config);
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     <span class="comment">// loop while link status isn't OK</span>
<a name="l00792"></a>00792     <span class="keywordflow">do</span> {
<a name="l00793"></a>00793       mii_status = <a class="code" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a>(macb, <a class="code" href="a00006.html#fd55dbb80e961541a12f3532ddb1b545">PHY_BMSR</a>);
<a name="l00794"></a>00794     } <span class="keywordflow">while</span> (!(mii_status &amp; <a class="code" href="a00006.html#f02d15c97090d7661a935578ec441cdb">BMSR_LSTATUS</a>));
<a name="l00795"></a>00795 
<a name="l00796"></a>00796     <span class="comment">// read the LPA configuration of the PHY</span>
<a name="l00797"></a>00797     lpa = <a class="code" href="a00005.html#a2a9e100cc6c86a5978c7d8e0dbad854">ulReadMDIO</a>(macb, <a class="code" href="a00006.html#7d998db26ac8453e5dd5e4dc402d8599">PHY_LPA</a>);
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     <span class="comment">// read the MACB config register</span>
<a name="l00800"></a>00800     config = AVR32_MACB.ncfgr;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802     <span class="comment">// if 100MB needed</span>
<a name="l00803"></a>00803     <span class="keywordflow">if</span> ((lpa &amp; advertise) &amp; (<a class="code" href="a00006.html#3c87fb559291a5f246625c35de269c3b">LPA_100HALF</a> | <a class="code" href="a00006.html#c7a44db79d58da734c5eee0ecd2f5a62">LPA_100FULL</a>))
<a name="l00804"></a>00804     {
<a name="l00805"></a>00805       config |= AVR32_MACB_SPD_MASK;
<a name="l00806"></a>00806     }
<a name="l00807"></a>00807     <span class="keywordflow">else</span>
<a name="l00808"></a>00808     {
<a name="l00809"></a>00809       config &amp;= ~(AVR32_MACB_SPD_MASK);
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     <span class="comment">// if FULL DUPLEX needed</span>
<a name="l00813"></a>00813     <span class="keywordflow">if</span> ((lpa &amp; advertise) &amp; (<a class="code" href="a00006.html#8621e2d5de73517aa4555ef9a7c8a333">LPA_10FULL</a> | <a class="code" href="a00006.html#c7a44db79d58da734c5eee0ecd2f5a62">LPA_100FULL</a>))
<a name="l00814"></a>00814     {
<a name="l00815"></a>00815       config |= AVR32_MACB_FD_MASK;
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817     <span class="keywordflow">else</span>
<a name="l00818"></a>00818     {
<a name="l00819"></a>00819       config &amp;= ~(AVR32_MACB_FD_MASK);
<a name="l00820"></a>00820     }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822     <span class="comment">// write the MACB config register</span>
<a name="l00823"></a>00823     macb-&gt;ncfgr = config;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825     <span class="keywordflow">return</span> TRUE;
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827   <span class="keywordflow">return</span> FALSE;
<a name="l00828"></a>00828 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0f1265d1ebfb3d16f5f46c0b4ea34104"></a><!-- doxytag: member="macb.c::prvSetupDescriptors" ref="0f1265d1ebfb3d16f5f46c0b4ea34104" args="(volatile avr32_macb_t *macb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void prvSetupDescriptors           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00530">530</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00010.html#l00289">_AVR32_TxTdDescriptor::addr</a>, <a class="el" href="a00010.html#l00256">_AVR32_RxTdDescriptor::addr</a>, <a class="el" href="a00009.html#l00069">ADDRESS_MASK</a>, <a class="el" href="a00010.html#l00336">AVR32_TRANSMIT_OK</a>, <a class="el" href="a00010.html#l00337">AVR32_TRANSMIT_WRAP</a>, <a class="el" href="a00008.html#l00052">ETHERNET_CONF_NB_RX_BUFFERS</a>, <a class="el" href="a00008.html#l00059">ETHERNET_CONF_NB_TX_BUFFERS</a>, <a class="el" href="a00008.html#l00062">ETHERNET_CONF_TX_BUFFER_SIZE</a>, <a class="el" href="a00009.html#l00063">RX_BUFFER_SIZE</a>, <a class="el" href="a00009.html#l00073">RX_WRAP_BIT</a>, <a class="el" href="a00010.html#l00292">_AVR32_TxTdDescriptor::status</a>, <a class="el" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">_AVR32_TxTdDescriptor::U_Status</a>, <a class="el" href="a00009.html#l00109">xRxDescriptors</a>, and <a class="el" href="a00009.html#l00108">xTxDescriptors</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00425">xMACBInit()</a>.<div class="fragment"><pre class="fragment"><a name="l00531"></a>00531 {
<a name="l00532"></a>00532 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> xIndex;
<a name="l00533"></a>00533 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulAddress;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <span class="comment">// Initialise xRxDescriptors descriptor.</span>
<a name="l00536"></a>00536   <span class="keywordflow">for</span>( xIndex = 0; xIndex &lt; <a class="code" href="a00004.html#acf0da3d04be8620c04c0fcc73915799">ETHERNET_CONF_NB_RX_BUFFERS</a>; ++xIndex )
<a name="l00537"></a>00537   {
<a name="l00538"></a>00538     <span class="comment">// Calculate the address of the nth buffer within the array.</span>
<a name="l00539"></a>00539     ulAddress = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> )( <a class="code" href="a00005.html#7731c709cc48903c1b506003943b1d8d">pcRxBuffer</a> + ( xIndex * <a class="code" href="a00005.html#739a2a1a0047c98ac1b18ecd25dac092">RX_BUFFER_SIZE</a> ) );
<a name="l00540"></a>00540 
<a name="l00541"></a>00541     <span class="comment">// Write the buffer address into the descriptor.  </span>
<a name="l00542"></a>00542     <span class="comment">// The DMA will place the data at this address when this descriptor is being used.</span>
<a name="l00543"></a>00543     <span class="comment">// Mask off the bottom bits of the address as these have special meaning.</span>
<a name="l00544"></a>00544     <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ xIndex ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a> = ulAddress &amp; <a class="code" href="a00005.html#8115a0b9bd8f9ac9254fc78e524df10e">ADDRESS_MASK</a>;
<a name="l00545"></a>00545   }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <span class="comment">// The last buffer has the wrap bit set so the MACB knows to wrap back</span>
<a name="l00548"></a>00548   <span class="comment">// to the first buffer.</span>
<a name="l00549"></a>00549   <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ ETHERNET_CONF_NB_RX_BUFFERS - 1 ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a> |= <a class="code" href="a00005.html#67aa14be90f8368a8691adb4f7a42ed4">RX_WRAP_BIT</a>;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   <span class="comment">// Initialise xTxDescriptors.</span>
<a name="l00552"></a>00552   <span class="keywordflow">for</span>( xIndex = 0; xIndex &lt; <a class="code" href="a00004.html#50d350cf7d3d470318d90dbce66756f7">ETHERNET_CONF_NB_TX_BUFFERS</a>; ++xIndex )
<a name="l00553"></a>00553   {
<a name="l00554"></a>00554     <span class="comment">// Calculate the address of the nth buffer within the array.</span>
<a name="l00555"></a>00555     ulAddress = ( <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> )( <a class="code" href="a00005.html#409288c455b7adefd2d89455ce0eb6dd">pcTxBuffer</a> + ( xIndex * <a class="code" href="a00004.html#8b1ddb8402abef501c15c0517dbde60d">ETHERNET_CONF_TX_BUFFER_SIZE</a> ) );
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <span class="comment">// Write the buffer address into the descriptor.  </span>
<a name="l00558"></a>00558     <span class="comment">// The DMA will read data from here when the descriptor is being used.</span>
<a name="l00559"></a>00559     <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ xIndex ].<a class="code" href="a00002.html#d892fbffc0c3883b9c233f0e848cf2ca">addr</a> = ulAddress &amp; <a class="code" href="a00005.html#8115a0b9bd8f9ac9254fc78e524df10e">ADDRESS_MASK</a>;
<a name="l00560"></a>00560     <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ xIndex ].<a class="code" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">U_Status</a>.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> = <a class="code" href="a00006.html#0c925bc304416e1b04c033cfee1b79d3">AVR32_TRANSMIT_OK</a>;
<a name="l00561"></a>00561   }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   <span class="comment">// The last buffer has the wrap bit set so the MACB knows to wrap back</span>
<a name="l00564"></a>00564   <span class="comment">// to the first buffer.</span>
<a name="l00565"></a>00565   <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ ETHERNET_CONF_NB_TX_BUFFERS - 1 ].<a class="code" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">U_Status</a>.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> = <a class="code" href="a00006.html#eff87d3909016f0a6a336037d7637ff0">AVR32_TRANSMIT_WRAP</a> | <a class="code" href="a00006.html#0c925bc304416e1b04c033cfee1b79d3">AVR32_TRANSMIT_OK</a>;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="comment">// Tell the MACB where to find the descriptors.</span>
<a name="l00568"></a>00568   macb-&gt;rbqp =   ( <span class="keywordtype">unsigned</span> long )<a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>;
<a name="l00569"></a>00569   macb-&gt;tbqp =   ( <span class="keywordtype">unsigned</span> long )<a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <span class="comment">// Enable the copy of data into the buffers, ignore broadcasts,</span>
<a name="l00572"></a>00572   <span class="comment">// and don't copy FCS.</span>
<a name="l00573"></a>00573   macb-&gt;ncfgr |= (AVR32_MACB_CAF_MASK |  AVR32_MACB_NBC_MASK | AVR32_MACB_NCFGR_DRFCS_MASK);
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 } 
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6764d5a231109b1d2c32c7729de47dfe"></a><!-- doxytag: member="macb.c::prvSetupMACAddress" ref="6764d5a231109b1d2c32c7729de47dfe" args="(volatile avr32_macb_t *macb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void prvSetupMACAddress           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00577">577</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00425">xMACBInit()</a>.<div class="fragment"><pre class="fragment"><a name="l00578"></a>00578 {
<a name="l00579"></a>00579   <span class="comment">// Must be written SA1L then SA1H.</span>
<a name="l00580"></a>00580   macb-&gt;sa1b =  ( ( <span class="keywordtype">unsigned</span> long ) <a class="code" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>[ 3 ] &lt;&lt; 24 ) |
<a name="l00581"></a>00581                 ( ( <span class="keywordtype">unsigned</span> long ) <a class="code" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>[ 2 ] &lt;&lt; 16 ) |
<a name="l00582"></a>00582                 ( ( <span class="keywordtype">unsigned</span> long ) <a class="code" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>[ 1 ] &lt;&lt; 8  ) |
<a name="l00583"></a>00583                                     <a class="code" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>[ 0 ];
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   macb-&gt;sa1t =  ( ( <span class="keywordtype">unsigned</span> long ) <a class="code" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>[ 5 ] &lt;&lt; 8 ) |
<a name="l00586"></a>00586                                     <a class="code" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>[ 4 ];
<a name="l00587"></a>00587 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b6b8506f7336a338e517a758031be605"></a><!-- doxytag: member="macb.c::prvSetupMACBInterrupt" ref="b6b8506f7336a338e517a758031be605" args="(volatile avr32_macb_t *macb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void prvSetupMACBInterrupt           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00589">589</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00010.html#l00211">MICR_INTEN</a>, <a class="el" href="a00010.html#l00212">MICR_INTOE</a>, <a class="el" href="a00010.html#l00219">MISR_LINK_INT_EN</a>, <a class="el" href="a00010.html#l00113">PHY_MICR</a>, <a class="el" href="a00010.html#l00114">PHY_MISR</a>, <a class="el" href="a00009.html#l00876">vMACB_ISR()</a>, and <a class="el" href="a00009.html#l00673">vWriteMDIO()</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00425">xMACBInit()</a>.<div class="fragment"><pre class="fragment"><a name="l00590"></a>00590 {
<a name="l00591"></a>00591 <span class="preprocessor">#ifdef FREERTOS_USED</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span>  <span class="comment">// Create the semaphore used to trigger the MACB task. </span>
<a name="l00593"></a>00593   <span class="keywordflow">if</span> (xSemaphore == NULL)
<a name="l00594"></a>00594   {
<a name="l00595"></a>00595     vSemaphoreCreateBinary( xSemaphore );
<a name="l00596"></a>00596   }
<a name="l00597"></a>00597 <span class="preprocessor">#else </span>
<a name="l00598"></a>00598 <span class="preprocessor"></span>  <span class="comment">// Create the flag used to trigger the MACB polling task. </span>
<a name="l00599"></a>00599   <a class="code" href="a00005.html#bc6333a566548724a292e47b3d823b9b">DataToRead</a> = FALSE;
<a name="l00600"></a>00600 <span class="preprocessor">#endif</span>
<a name="l00601"></a>00601 <span class="preprocessor"></span>
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="preprocessor">#ifdef FREERTOS_USED</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( xSemaphore != NULL)
<a name="l00605"></a>00605   {
<a name="l00606"></a>00606     <span class="comment">// We start by 'taking' the semaphore so the ISR can 'give' it when the</span>
<a name="l00607"></a>00607     <span class="comment">// first interrupt occurs.</span>
<a name="l00608"></a>00608     xSemaphoreTake( xSemaphore, 0 );
<a name="l00609"></a>00609 <span class="preprocessor">#endif</span>
<a name="l00610"></a>00610 <span class="preprocessor"></span>    <span class="comment">// Setup the interrupt for MACB.</span>
<a name="l00611"></a>00611     <span class="comment">// Register the interrupt handler to the interrupt controller at interrupt level 2</span>
<a name="l00612"></a>00612     INTC_register_interrupt((__int_handler)&amp;<a class="code" href="a00005.html#4dbe868aa329c90577824aefd3139cef">vMACB_ISR</a>, AVR32_MACB_IRQ, INT2);
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 <span class="preprocessor">#if ETHERNET_CONF_USE_PHY_IT</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span>    <span class="comment">/* GPIO enable interrupt upon rising edge */</span>
<a name="l00616"></a>00616     gpio_enable_pin_interrupt(MACB_INTERRUPT_PIN, GPIO_FALLING_EDGE);
<a name="l00617"></a>00617     <span class="comment">// Setup the interrupt for PHY.</span>
<a name="l00618"></a>00618     <span class="comment">// Register the interrupt handler to the interrupt controller at interrupt level 2</span>
<a name="l00619"></a>00619     INTC_register_interrupt((__int_handler)&amp;vPHY_ISR, (AVR32_GPIO_IRQ_0 + (MACB_INTERRUPT_PIN/8)), INT2);
<a name="l00620"></a>00620     <span class="comment">/* enable interrupts on INT pin */</span>
<a name="l00621"></a>00621     <a class="code" href="a00005.html#e9572d576d76d11615804f9892da6cbb">vWriteMDIO</a>( macb, <a class="code" href="a00006.html#c4d8c2e6c2509a9bdaf214b24deafea7">PHY_MICR</a> , ( <a class="code" href="a00006.html#7c8b69ab5f99ba6ed3a9373efff430e9">MICR_INTEN</a> | <a class="code" href="a00006.html#f53eadd7286a9ab7847273fb041a0067">MICR_INTOE</a> ));
<a name="l00622"></a>00622     <span class="comment">/* enable "link change" interrupt for Phy */</span>
<a name="l00623"></a>00623     <a class="code" href="a00005.html#e9572d576d76d11615804f9892da6cbb">vWriteMDIO</a>( macb, <a class="code" href="a00006.html#81d36e97e4a9da33f2a7e142b01964f6">PHY_MISR</a> , <a class="code" href="a00006.html#aa22c8e6ded7d83f142bf70d43896d81">MISR_LINK_INT_EN</a> );
<a name="l00624"></a>00624 <span class="preprocessor">#endif</span>
<a name="l00625"></a>00625 <span class="preprocessor"></span>
<a name="l00626"></a>00626     <span class="comment">// We want to interrupt on Rx and Tx events</span>
<a name="l00627"></a>00627     macb-&gt;ier = AVR32_MACB_IER_RCOMP_MASK | AVR32_MACB_IER_TCOMP_MASK;
<a name="l00628"></a>00628 <span class="preprocessor">#ifdef FREERTOS_USED</span>
<a name="l00629"></a>00629 <span class="preprocessor"></span>  }
<a name="l00630"></a>00630 <span class="preprocessor">#endif</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span>}
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b9aba6f90d51b2e50e71efc4d40715c8"></a><!-- doxytag: member="macb.c::ulMACBInputLength" ref="b9aba6f90d51b2e50e71efc4d40715c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long ulMACBInputLength           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to get length of the next frame in the receive buffers. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the length of the next frame in the receive buffers. </dd></dl>

<p>
Definition at line <a class="el" href="a00009.html#l00276">276</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00010.html#l00256">_AVR32_RxTdDescriptor::addr</a>, <a class="el" href="a00010.html#l00331">AVR32_LENGTH_FRAME</a>, <a class="el" href="a00010.html#l00310">AVR32_OWNERSHIP_BIT</a>, <a class="el" href="a00010.html#l00329">AVR32_SOF</a>, <a class="el" href="a00008.html#l00052">ETHERNET_CONF_NB_RX_BUFFERS</a>, <a class="el" href="a00010.html#l00259">_AVR32_RxTdDescriptor::status</a>, <a class="el" href="a00001.html#817784770738de8325e0b85c83e423bf">_AVR32_RxTdDescriptor::U_Status</a>, and <a class="el" href="a00009.html#l00109">xRxDescriptors</a>.
<p>
Referenced by <a class="el" href="a00011.html#l00339">main()</a>.<div class="fragment"><pre class="fragment"><a name="l00277"></a>00277 {
<a name="l00278"></a>00278 <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulIndex , ulLength = 0;
<a name="l00279"></a>00279 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiTemp;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   <span class="comment">// Skip any fragments.  We are looking for the first buffer that contains</span>
<a name="l00282"></a>00282   <span class="comment">// data and has the SOF (start of frame) bit set.</span>
<a name="l00283"></a>00283   <span class="keywordflow">while</span>( ( <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].addr &amp; <a class="code" href="a00006.html#aa8a9870e3f7e0b183d9cdae71949845">AVR32_OWNERSHIP_BIT</a> ) &amp;&amp; !( <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].U_Status.<a class="code" href="a00001.html#55b15dba3f5d942c45804cdb1a592a15">status</a> &amp; <a class="code" href="a00006.html#e2a38da8f39552ecf65daee335c71bac">AVR32_SOF</a> ) )
<a name="l00284"></a>00284   {
<a name="l00285"></a>00285     <span class="comment">// Ignoring this buffer.  Mark it as free again.</span>
<a name="l00286"></a>00286     uiTemp = <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a>;
<a name="l00287"></a>00287     <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a> = uiTemp &amp; ~( AVR32_OWNERSHIP_BIT );
<a name="l00288"></a>00288     <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a>++;
<a name="l00289"></a>00289     <span class="keywordflow">if</span>( <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> &gt;= <a class="code" href="a00004.html#acf0da3d04be8620c04c0fcc73915799">ETHERNET_CONF_NB_RX_BUFFERS</a> )
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291       <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> = 0;
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293   }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   <span class="comment">// We are going to walk through the descriptors that make up this frame,</span>
<a name="l00296"></a>00296   <span class="comment">// but don't want to alter ulNextRxBuffer as this would prevent vMACBRead()</span>
<a name="l00297"></a>00297   <span class="comment">// from finding the data.  Therefore use a copy of ulNextRxBuffer instead. </span>
<a name="l00298"></a>00298   ulIndex = <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a>;
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="comment">// Walk through the descriptors until we find the last buffer for this frame.</span>
<a name="l00301"></a>00301   <span class="comment">// The last buffer will give us the length of the entire frame.</span>
<a name="l00302"></a>00302   <span class="keywordflow">while</span>( ( <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ ulIndex ].addr &amp; AVR32_OWNERSHIP_BIT ) &amp;&amp; !ulLength )
<a name="l00303"></a>00303   {
<a name="l00304"></a>00304     ulLength = <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ ulIndex ].<a class="code" href="a00001.html#817784770738de8325e0b85c83e423bf">U_Status</a>.<a class="code" href="a00001.html#55b15dba3f5d942c45804cdb1a592a15">status</a> &amp; <a class="code" href="a00006.html#60f03dcd701da7595aadab25e2ace3be">AVR32_LENGTH_FRAME</a>;
<a name="l00305"></a>00305     <span class="comment">// Increment to the next buffer, wrapping if necessary.</span>
<a name="l00306"></a>00306     ulIndex++;
<a name="l00307"></a>00307     <span class="keywordflow">if</span>( ulIndex &gt;= <a class="code" href="a00004.html#acf0da3d04be8620c04c0fcc73915799">ETHERNET_CONF_NB_RX_BUFFERS</a> )
<a name="l00308"></a>00308     {
<a name="l00309"></a>00309       ulIndex = 0;
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311   }
<a name="l00312"></a>00312   <span class="keywordflow">return</span> ulLength;
<a name="l00313"></a>00313 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a2a9e100cc6c86a5978c7d8e0dbad854"></a><!-- doxytag: member="macb.c::ulReadMDIO" ref="a2a9e100cc6c86a5978c7d8e0dbad854" args="(volatile avr32_macb_t *macb, unsigned short usAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long ulReadMDIO           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>usAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a register on MDIO bus (access to the PHY) This function is looping until PHY gets ready<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>macb</em>&nbsp;</td><td>Input. instance of the MACB to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usAddress</em>&nbsp;</td><td>Input. register to set.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>unsigned long data that has been read </dd></dl>

<p>
Definition at line <a class="el" href="a00009.html#l00641">641</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00008.html#l00102">ETHERNET_CONF_PHY_ADDR</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00694">prvProbePHY()</a>.<div class="fragment"><pre class="fragment"><a name="l00642"></a>00642 {
<a name="l00643"></a>00643 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value, status;
<a name="l00644"></a>00644 
<a name="l00645"></a>00645   <span class="comment">// initiate transaction : enable management port</span>
<a name="l00646"></a>00646   macb-&gt;ncr |= AVR32_MACB_NCR_MPE_MASK;
<a name="l00647"></a>00647   <span class="comment">// Write the PHY configuration frame to the MAN register</span>
<a name="l00648"></a>00648   macb-&gt;man = (AVR32_MACB_SOF_MASK &amp; (0x01&lt;&lt;AVR32_MACB_SOF_OFFSET))  <span class="comment">// SOF</span>
<a name="l00649"></a>00649             | (2 &lt;&lt; AVR32_MACB_CODE_OFFSET)                          <span class="comment">// Code</span>
<a name="l00650"></a>00650             | (2 &lt;&lt; AVR32_MACB_RW_OFFSET)                            <span class="comment">// Read operation</span>
<a name="l00651"></a>00651             | ((<a class="code" href="a00004.html#d528bcfb00c80659fc8c4c9cd0cbbc5d">ETHERNET_CONF_PHY_ADDR</a> &amp; 0x1f) &lt;&lt; AVR32_MACB_PHYA_OFFSET)  <span class="comment">// Phy Add</span>
<a name="l00652"></a>00652             | (usAddress &lt;&lt; AVR32_MACB_REGA_OFFSET);                 <span class="comment">// Reg Add</span>
<a name="l00653"></a>00653   <span class="comment">// wait for PHY to be ready</span>
<a name="l00654"></a>00654   <span class="keywordflow">do</span> {
<a name="l00655"></a>00655     status = macb-&gt;nsr;
<a name="l00656"></a>00656   } <span class="keywordflow">while</span> (!(status &amp; AVR32_MACB_NSR_IDLE_MASK));
<a name="l00657"></a>00657   <span class="comment">// read the register value in maintenance register</span>
<a name="l00658"></a>00658   value = macb-&gt;man &amp; 0x0000ffff;
<a name="l00659"></a>00659   <span class="comment">// disable management port</span>
<a name="l00660"></a>00660   macb-&gt;ncr &amp;= ~AVR32_MACB_NCR_MPE_MASK;
<a name="l00661"></a>00661   <span class="comment">// return the read value</span>
<a name="l00662"></a>00662   <span class="keywordflow">return</span> (value);
<a name="l00663"></a>00663 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="072ec0a505ca0139e7cef8ee79683068"></a><!-- doxytag: member="macb.c::vClearMACBTxBuffer" ref="072ec0a505ca0139e7cef8ee79683068" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vClearMACBTxBuffer           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the Tx interrupt, this function traverses the buffers used to hold the frame that has just completed transmission and marks each as free again. 
<p>

<p>
Definition at line <a class="el" href="a00009.html#l00495">495</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00010.html#l00342">AVR32_LAST_BUFFER</a>, <a class="el" href="a00010.html#l00336">AVR32_TRANSMIT_OK</a>, <a class="el" href="a00008.html#l00059">ETHERNET_CONF_NB_TX_BUFFERS</a>, <a class="el" href="a00010.html#l00292">_AVR32_TxTdDescriptor::status</a>, <a class="el" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">_AVR32_TxTdDescriptor::U_Status</a>, and <a class="el" href="a00009.html#l00108">xTxDescriptors</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00898">prvMACB_ISR_NonNakedBehaviour()</a>.<div class="fragment"><pre class="fragment"><a name="l00496"></a>00496 {
<a name="l00497"></a>00497 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> uxNextBufferToClear = 0;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <span class="comment">// Called on Tx interrupt events to set the AVR32_TRANSMIT_OK bit in each</span>
<a name="l00500"></a>00500   <span class="comment">// Tx buffer within the frame just transmitted.  This marks all the buffers</span>
<a name="l00501"></a>00501   <span class="comment">// as available again.</span>
<a name="l00502"></a>00502 
<a name="l00503"></a>00503   <span class="comment">// The first buffer in the frame should have the bit set automatically. */</span>
<a name="l00504"></a>00504   <span class="keywordflow">if</span>( <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ uxNextBufferToClear ].U_Status.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> &amp; <a class="code" href="a00006.html#0c925bc304416e1b04c033cfee1b79d3">AVR32_TRANSMIT_OK</a> )
<a name="l00505"></a>00505   {
<a name="l00506"></a>00506     <span class="comment">// Loop through the other buffers in the frame.</span>
<a name="l00507"></a>00507     <span class="keywordflow">while</span>( !( <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ uxNextBufferToClear ].U_Status.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> &amp; <a class="code" href="a00006.html#51f3e88d73c11f80e143e5633493eb21">AVR32_LAST_BUFFER</a> ) )
<a name="l00508"></a>00508     {
<a name="l00509"></a>00509       uxNextBufferToClear++;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511       <span class="keywordflow">if</span>( uxNextBufferToClear &gt;= <a class="code" href="a00004.html#50d350cf7d3d470318d90dbce66756f7">ETHERNET_CONF_NB_TX_BUFFERS</a> )
<a name="l00512"></a>00512       {
<a name="l00513"></a>00513         uxNextBufferToClear = 0;
<a name="l00514"></a>00514       }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516       <a class="code" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ uxNextBufferToClear ].<a class="code" href="a00002.html#73e21bb03299cc24e0867dbae929b08b">U_Status</a>.<a class="code" href="a00002.html#24fed21756b02554c1c6a598f914c82e">status</a> |= AVR32_TRANSMIT_OK;
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     <span class="comment">// Start with the next buffer the next time a Tx interrupt is called.</span>
<a name="l00520"></a>00520     uxNextBufferToClear++;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522     <span class="comment">// Do we need to wrap back to the first buffer? </span>
<a name="l00523"></a>00523     <span class="keywordflow">if</span>( uxNextBufferToClear &gt;= <a class="code" href="a00004.html#50d350cf7d3d470318d90dbce66756f7">ETHERNET_CONF_NB_TX_BUFFERS</a> )
<a name="l00524"></a>00524     {
<a name="l00525"></a>00525       uxNextBufferToClear = 0;
<a name="l00526"></a>00526     }
<a name="l00527"></a>00527   }
<a name="l00528"></a>00528 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e73b91041abc3ea1ee1e91ac1349b69e"></a><!-- doxytag: member="macb.c::vDisableMACBOperations" ref="e73b91041abc3ea1ee1e91ac1349b69e" args="(volatile avr32_macb_t *macb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vDisableMACBOperations           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable MACB operations (Tx and Rx). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*macb</em>&nbsp;</td><td>Base address of the MACB </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00009.html#l00479">479</a> of file <a class="el" href="a00009.html">macb.c</a>.<div class="fragment"><pre class="fragment"><a name="l00480"></a>00480 {
<a name="l00481"></a>00481 <span class="preprocessor">#if ETHERNET_CONF_USE_PHY_IT</span>
<a name="l00482"></a>00482 <span class="preprocessor"></span><span class="keyword">volatile</span> avr32_gpio_t *gpio = &amp;AVR32_GPIO;
<a name="l00483"></a>00483 <span class="keyword">volatile</span> avr32_gpio_port_t *gpio_port = &amp;gpio-&gt;port[MACB_INTERRUPT_PIN/32];
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   gpio_port-&gt;ierc =  1 &lt;&lt; (MACB_INTERRUPT_PIN%32);
<a name="l00486"></a>00486 <span class="preprocessor">#endif</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>
<a name="l00488"></a>00488   <span class="comment">// write the MACB control register : disable Tx &amp; Rx</span>
<a name="l00489"></a>00489   macb-&gt;ncr &amp;= ~((1 &lt;&lt; AVR32_MACB_RE_OFFSET) | (1 &lt;&lt; AVR32_MACB_TE_OFFSET));
<a name="l00490"></a>00490   <span class="comment">// We no more want to interrupt on Rx and Tx events.</span>
<a name="l00491"></a>00491   macb-&gt;idr = AVR32_MACB_IER_RCOMP_MASK | AVR32_MACB_IER_TCOMP_MASK;
<a name="l00492"></a>00492 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4dbe868aa329c90577824aefd3139cef"></a><!-- doxytag: member="macb.c::vMACB_ISR" ref="4dbe868aa329c90577824aefd3139cef" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vMACB_ISR           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00876">876</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00009.html#l00082">portENTER_SWITCHING_ISR</a>, <a class="el" href="a00009.html#l00083">portEXIT_SWITCHING_ISR</a>, and <a class="el" href="a00009.html#l00898">prvMACB_ISR_NonNakedBehaviour()</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00589">prvSetupMACBInterrupt()</a>.<div class="fragment"><pre class="fragment"><a name="l00877"></a>00877 {
<a name="l00878"></a>00878   <span class="comment">// This ISR can cause a context switch, so the first statement must be a</span>
<a name="l00879"></a>00879   <span class="comment">// call to the portENTER_SWITCHING_ISR() macro.  This must be BEFORE any</span>
<a name="l00880"></a>00880   <span class="comment">// variable declarations. </span>
<a name="l00881"></a>00881   <a class="code" href="a00005.html#b11b1d42d76d38c238249f758072d0a6">portENTER_SWITCHING_ISR</a>();
<a name="l00882"></a>00882 
<a name="l00883"></a>00883   <span class="comment">// the return value is used by FreeRTOS to change the context if needed after rete instruction</span>
<a name="l00884"></a>00884   <span class="comment">// in standalone use, this value should be ignored </span>
<a name="l00885"></a>00885   <a class="code" href="a00005.html#73c602fbe6d30d664f0ad0bfb82861f8">prvMACB_ISR_NonNakedBehaviour</a>();
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   <span class="comment">// Exit the ISR.  If a task was woken by either a character being received</span>
<a name="l00888"></a>00888   <span class="comment">// or transmitted then a context switch will occur.</span>
<a name="l00889"></a>00889   <a class="code" href="a00005.html#70d03a5614513ae52a53c49dbf8e80fd">portEXIT_SWITCHING_ISR</a>();
<a name="l00890"></a>00890 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4ca1fe9983732c3de6b2618bec0bfe40"></a><!-- doxytag: member="macb.c::vMACBRead" ref="4ca1fe9983732c3de6b2618bec0bfe40" args="(char *pcTo, unsigned long ulSectionLength, unsigned long ulTotalFrameLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vMACBRead           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pcTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ulSectionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ulTotalFrameLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frames can be read from the MACB in multiple sections. 
<p>
Read ulSectionLength bytes from the MACB receive buffers to pcTo. ulTotalFrameLength is the size of the entire frame. Generally vMACBRead will be repetedly called until the sum of all the ulSectionLenths totals the value of ulTotalFrameLength.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*pcTo</em>&nbsp;</td><td>Address of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ulSectionLength</em>&nbsp;</td><td>Length of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ulTotalFrameLength</em>&nbsp;</td><td>Length of the frame </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00009.html#l00316">316</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00010.html#l00256">_AVR32_RxTdDescriptor::addr</a>, <a class="el" href="a00009.html#l00069">ADDRESS_MASK</a>, <a class="el" href="a00010.html#l00310">AVR32_OWNERSHIP_BIT</a>, <a class="el" href="a00008.html#l00052">ETHERNET_CONF_NB_RX_BUFFERS</a>, <a class="el" href="a00009.html#l00063">RX_BUFFER_SIZE</a>, and <a class="el" href="a00009.html#l00109">xRxDescriptors</a>.
<p>
Referenced by <a class="el" href="a00011.html#l00339">main()</a>.<div class="fragment"><pre class="fragment"><a name="l00317"></a>00317 {
<a name="l00318"></a>00318 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulSectionBytesReadSoFar = 0, ulBufferPosition = 0, ulFameBytesReadSoFar = 0;
<a name="l00319"></a>00319 <span class="keyword">static</span> <span class="keywordtype">char</span> *pcSource;
<a name="l00320"></a>00320 <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulBytesRemainingInBuffer, ulRemainingSectionBytes;
<a name="l00321"></a>00321 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiTemp;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <span class="comment">// Read ulSectionLength bytes from the Rx buffers. </span>
<a name="l00324"></a>00324   <span class="comment">// This is not necessarily any correspondence between the length of our Rx buffers, </span>
<a name="l00325"></a>00325   <span class="comment">// and the length of the data we are returning or the length of the data being requested.</span>
<a name="l00326"></a>00326   <span class="comment">// Therefore, between calls  we have to remember not only which buffer we are currently</span>
<a name="l00327"></a>00327   <span class="comment">// processing, but our position within that buffer.  </span>
<a name="l00328"></a>00328   <span class="comment">// This would be greatly simplified if PBUF_POOL_BUFSIZE could be guaranteed to be greater </span>
<a name="l00329"></a>00329   <span class="comment">// than the size of each Rx buffer, and that memory fragmentation did not occur.</span>
<a name="l00330"></a>00330   
<a name="l00331"></a>00331   <span class="comment">// This function should only be called after a call to ulMACBInputLength().</span>
<a name="l00332"></a>00332   <span class="comment">// This will ensure ulNextRxBuffer is set to the correct buffer. */</span>
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <span class="comment">// vMACBRead is called with pcTo set to NULL to indicate that we are about</span>
<a name="l00335"></a>00335   <span class="comment">// to read a new frame.  Any fragments remaining in the frame we were</span>
<a name="l00336"></a>00336   <span class="comment">// processing during the last call should be dropped.</span>
<a name="l00337"></a>00337   <span class="keywordflow">if</span>( pcTo == NULL )
<a name="l00338"></a>00338   {
<a name="l00339"></a>00339     <span class="comment">// How many bytes are indicated as being in this buffer?  </span>
<a name="l00340"></a>00340     <span class="comment">// If none then the buffer is completely full and the frame is contained within more</span>
<a name="l00341"></a>00341     <span class="comment">// than one buffer.</span>
<a name="l00342"></a>00342     <span class="comment">// Reset our state variables ready for the next read from this buffer.</span>
<a name="l00343"></a>00343     pcSource = ( <span class="keywordtype">char</span> * )( <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].addr &amp; <a class="code" href="a00005.html#8115a0b9bd8f9ac9254fc78e524df10e">ADDRESS_MASK</a> );
<a name="l00344"></a>00344     ulFameBytesReadSoFar = ( <span class="keywordtype">unsigned</span> long ) 0;
<a name="l00345"></a>00345     ulBufferPosition = ( <span class="keywordtype">unsigned</span> long ) 0;
<a name="l00346"></a>00346   }
<a name="l00347"></a>00347   <span class="keywordflow">else</span>
<a name="l00348"></a>00348   {
<a name="l00349"></a>00349     <span class="comment">// Loop until we have obtained the required amount of data.</span>
<a name="l00350"></a>00350     ulSectionBytesReadSoFar = 0;
<a name="l00351"></a>00351     <span class="keywordflow">while</span>( ulSectionBytesReadSoFar &lt; ulSectionLength )
<a name="l00352"></a>00352     {
<a name="l00353"></a>00353       <span class="comment">// We may have already read some data from this buffer.</span>
<a name="l00354"></a>00354       <span class="comment">// How much data remains in the buffer?</span>
<a name="l00355"></a>00355       ulBytesRemainingInBuffer = ( <a class="code" href="a00005.html#739a2a1a0047c98ac1b18ecd25dac092">RX_BUFFER_SIZE</a> - ulBufferPosition );
<a name="l00356"></a>00356 
<a name="l00357"></a>00357       <span class="comment">// How many more bytes do we need to read before we have the</span>
<a name="l00358"></a>00358       <span class="comment">// required amount of data?</span>
<a name="l00359"></a>00359       ulRemainingSectionBytes = ulSectionLength - ulSectionBytesReadSoFar;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361       <span class="comment">// Do we want more data than remains in the buffer? </span>
<a name="l00362"></a>00362       <span class="keywordflow">if</span>( ulRemainingSectionBytes &gt; ulBytesRemainingInBuffer )
<a name="l00363"></a>00363       {
<a name="l00364"></a>00364         <span class="comment">// We want more data than remains in the buffer so we can</span>
<a name="l00365"></a>00365         <span class="comment">// write the remains of the buffer to the destination, then move</span>
<a name="l00366"></a>00366         <span class="comment">// onto the next buffer to get the rest.</span>
<a name="l00367"></a>00367         memcpy( &amp;( pcTo[ ulSectionBytesReadSoFar ] ), &amp;( pcSource[ ulBufferPosition ] ), ulBytesRemainingInBuffer );
<a name="l00368"></a>00368         ulSectionBytesReadSoFar += ulBytesRemainingInBuffer;
<a name="l00369"></a>00369         ulFameBytesReadSoFar += ulBytesRemainingInBuffer;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371         <span class="comment">// Mark the buffer as free again.</span>
<a name="l00372"></a>00372         uiTemp = <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a>;
<a name="l00373"></a>00373         <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a> = uiTemp &amp; ~( <a class="code" href="a00006.html#aa8a9870e3f7e0b183d9cdae71949845">AVR32_OWNERSHIP_BIT</a> );
<a name="l00374"></a>00374         <span class="comment">// Move onto the next buffer.</span>
<a name="l00375"></a>00375         <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a>++;
<a name="l00376"></a>00376        
<a name="l00377"></a>00377         <span class="keywordflow">if</span>( <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> &gt;= <a class="code" href="a00004.html#acf0da3d04be8620c04c0fcc73915799">ETHERNET_CONF_NB_RX_BUFFERS</a> )
<a name="l00378"></a>00378         {
<a name="l00379"></a>00379           <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> = ( <span class="keywordtype">unsigned</span> long ) 0;
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381       
<a name="l00382"></a>00382         <span class="comment">// Reset the variables for the new buffer.</span>
<a name="l00383"></a>00383         pcSource = ( <span class="keywordtype">char</span> * )( <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].addr &amp; <a class="code" href="a00005.html#8115a0b9bd8f9ac9254fc78e524df10e">ADDRESS_MASK</a> );
<a name="l00384"></a>00384         ulBufferPosition = ( <span class="keywordtype">unsigned</span> long ) 0;
<a name="l00385"></a>00385       }
<a name="l00386"></a>00386       <span class="keywordflow">else</span>
<a name="l00387"></a>00387       {
<a name="l00388"></a>00388         <span class="comment">// We have enough data in this buffer to send back.</span>
<a name="l00389"></a>00389         <span class="comment">// Read out enough data and remember how far we read up to.</span>
<a name="l00390"></a>00390         memcpy( &amp;( pcTo[ ulSectionBytesReadSoFar ] ), &amp;( pcSource[ ulBufferPosition ] ), ulRemainingSectionBytes );
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         <span class="comment">// There may be more data in this buffer yet.</span>
<a name="l00393"></a>00393         <span class="comment">// Increment our position in this buffer past the data we have just read.</span>
<a name="l00394"></a>00394         ulBufferPosition += ulRemainingSectionBytes;
<a name="l00395"></a>00395         ulSectionBytesReadSoFar += ulRemainingSectionBytes;
<a name="l00396"></a>00396         ulFameBytesReadSoFar += ulRemainingSectionBytes;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398         <span class="comment">// Have we now finished with this buffer?</span>
<a name="l00399"></a>00399         <span class="keywordflow">if</span>( ( ulBufferPosition &gt;= <a class="code" href="a00005.html#739a2a1a0047c98ac1b18ecd25dac092">RX_BUFFER_SIZE</a> ) || ( ulFameBytesReadSoFar &gt;= ulTotalFrameLength ) )
<a name="l00400"></a>00400         {
<a name="l00401"></a>00401           <span class="comment">// Mark the buffer as free again.</span>
<a name="l00402"></a>00402           uiTemp = <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a>;
<a name="l00403"></a>00403           <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].<a class="code" href="a00001.html#3293d4bf927adb845c469d3d2d4b7cca">addr</a> = uiTemp &amp; ~( <a class="code" href="a00006.html#aa8a9870e3f7e0b183d9cdae71949845">AVR32_OWNERSHIP_BIT</a> );
<a name="l00404"></a>00404           <span class="comment">// Move onto the next buffer.</span>
<a name="l00405"></a>00405           <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a>++;
<a name="l00406"></a>00406          
<a name="l00407"></a>00407           <span class="keywordflow">if</span>( <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> &gt;= <a class="code" href="a00004.html#acf0da3d04be8620c04c0fcc73915799">ETHERNET_CONF_NB_RX_BUFFERS</a> )
<a name="l00408"></a>00408           {
<a name="l00409"></a>00409             <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> = 0;
<a name="l00410"></a>00410           }
<a name="l00411"></a>00411        
<a name="l00412"></a>00412           pcSource = ( <span class="keywordtype">char</span> * )( <a class="code" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ <a class="code" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> ].addr &amp; <a class="code" href="a00005.html#8115a0b9bd8f9ac9254fc78e524df10e">ADDRESS_MASK</a> );
<a name="l00413"></a>00413           ulBufferPosition = 0;
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415       }
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417   }
<a name="l00418"></a>00418 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5e67bec889bd6c46ccd3b5cedacf259b"></a><!-- doxytag: member="macb.c::vMACBSetMACAddress" ref="5e67bec889bd6c46ccd3b5cedacf259b" args="(const char *MACAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vMACBSetMACAddress           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>MACAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MACB Physical address (SA1B &amp; SA1T registers). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*MACAddress</em>&nbsp;</td><td>the MAC address to set. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00009.html#l00420">420</a> of file <a class="el" href="a00009.html">macb.c</a>.<div class="fragment"><pre class="fragment"><a name="l00421"></a>00421 {
<a name="l00422"></a>00422   memcpy(<a class="code" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>, MACAddress, <span class="keyword">sizeof</span>(cMACAddress));
<a name="l00423"></a>00423 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cd68f9f9df0f6c5d03bf43ecfa141fab"></a><!-- doxytag: member="macb.c::vMACBWaitForInput" ref="cd68f9f9df0f6c5d03bf43ecfa141fab" args="(unsigned long ulTimeOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vMACBWaitForInput           </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ulTimeOut</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspend on a semaphore waiting either for the semaphore to be obtained or a timeout. 
<p>
The semaphore is used by the MACB ISR to indicate that data has been received and is ready for processing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ulTimeOut</em>&nbsp;</td><td>time to wait for an input </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00009.html#l00831">831</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00009.html#l00080">portENTER_CRITICAL</a>, and <a class="el" href="a00009.html#l00081">portEXIT_CRITICAL</a>.
<p>
Referenced by <a class="el" href="a00011.html#l00339">main()</a>.<div class="fragment"><pre class="fragment"><a name="l00832"></a>00832 {
<a name="l00833"></a>00833 <span class="preprocessor">#ifdef FREERTOS_USED</span>
<a name="l00834"></a>00834 <span class="preprocessor"></span>  <span class="comment">// Just wait until we are signled from an ISR that data is available, or</span>
<a name="l00835"></a>00835   <span class="comment">// we simply time out.</span>
<a name="l00836"></a>00836   xSemaphoreTake( xSemaphore, ulTimeOut );
<a name="l00837"></a>00837 <span class="preprocessor">#else</span>
<a name="l00838"></a>00838 <span class="preprocessor"></span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l00839"></a>00839   gpio_clr_gpio_pin(LED0_GPIO);
<a name="l00840"></a>00840   i = ulTimeOut * 1000;  
<a name="l00841"></a>00841   <span class="comment">// wait for an interrupt to occurs</span>
<a name="l00842"></a>00842   <span class="keywordflow">do</span>
<a name="l00843"></a>00843   {
<a name="l00844"></a>00844     <span class="keywordflow">if</span> ( <a class="code" href="a00005.html#bc6333a566548724a292e47b3d823b9b">DataToRead</a> == TRUE )
<a name="l00845"></a>00845     {
<a name="l00846"></a>00846       <span class="comment">// IT occurs, reset interrupt flag</span>
<a name="l00847"></a>00847       <a class="code" href="a00005.html#507969035dc4ab0c36567f4ea783dc68">portENTER_CRITICAL</a>();
<a name="l00848"></a>00848       <a class="code" href="a00005.html#bc6333a566548724a292e47b3d823b9b">DataToRead</a> = FALSE;    
<a name="l00849"></a>00849       <a class="code" href="a00005.html#e2bb7a15725e564859fe12447d5263da">portEXIT_CRITICAL</a>();
<a name="l00850"></a>00850       <span class="keywordflow">break</span>;    
<a name="l00851"></a>00851     }
<a name="l00852"></a>00852     i--;
<a name="l00853"></a>00853   }
<a name="l00854"></a>00854   <span class="keywordflow">while</span>(i != 0);
<a name="l00855"></a>00855   gpio_set_gpio_pin(LED0_GPIO);  
<a name="l00856"></a>00856 <span class="preprocessor">#endif</span>
<a name="l00857"></a>00857 <span class="preprocessor"></span>}
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e9572d576d76d11615804f9892da6cbb"></a><!-- doxytag: member="macb.c::vWriteMDIO" ref="e9572d576d76d11615804f9892da6cbb" args="(volatile avr32_macb_t *macb, unsigned short usAddress, unsigned short usValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void vWriteMDIO           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>usValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a given value to a register on MDIO bus (access to the PHY) This function is looping until PHY gets ready<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*macb</em>&nbsp;</td><td>Input. instance of the MACB to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usAddress</em>&nbsp;</td><td>Input. register to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usValue</em>&nbsp;</td><td>Input. value to write. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="a00009.html#l00673">673</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00008.html#l00102">ETHERNET_CONF_PHY_ADDR</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00694">prvProbePHY()</a>, and <a class="el" href="a00009.html#l00589">prvSetupMACBInterrupt()</a>.<div class="fragment"><pre class="fragment"><a name="l00674"></a>00674 {
<a name="l00675"></a>00675 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> status;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="comment">// initiate transaction : enable management port</span>
<a name="l00678"></a>00678   macb-&gt;ncr |= AVR32_MACB_NCR_MPE_MASK;
<a name="l00679"></a>00679   <span class="comment">// Write the PHY configuration frame to the MAN register</span>
<a name="l00680"></a>00680   macb-&gt;man = (( AVR32_MACB_SOF_MASK &amp; (0x01&lt;&lt;AVR32_MACB_SOF_OFFSET)) <span class="comment">// SOF</span>
<a name="l00681"></a>00681              | (2 &lt;&lt; AVR32_MACB_CODE_OFFSET)                          <span class="comment">// Code</span>
<a name="l00682"></a>00682              | (1 &lt;&lt; AVR32_MACB_RW_OFFSET)                            <span class="comment">// Write operation</span>
<a name="l00683"></a>00683              | ((<a class="code" href="a00004.html#d528bcfb00c80659fc8c4c9cd0cbbc5d">ETHERNET_CONF_PHY_ADDR</a> &amp; 0x1f) &lt;&lt; AVR32_MACB_PHYA_OFFSET)  <span class="comment">// Phy Add</span>
<a name="l00684"></a>00684              | (usAddress &lt;&lt; AVR32_MACB_REGA_OFFSET))                 <span class="comment">// Reg Add</span>
<a name="l00685"></a>00685              | (usValue &amp; 0xffff);                                    <span class="comment">// Data</span>
<a name="l00686"></a>00686   <span class="comment">// wait for PHY to be ready</span>
<a name="l00687"></a>00687   <span class="keywordflow">do</span> {
<a name="l00688"></a>00688     status = macb-&gt;nsr;
<a name="l00689"></a>00689   } <span class="keywordflow">while</span> (!(status &amp; AVR32_MACB_NSR_IDLE_MASK));
<a name="l00690"></a>00690   <span class="comment">// disable management port</span>
<a name="l00691"></a>00691   macb-&gt;ncr &amp;= ~AVR32_MACB_NCR_MPE_MASK;
<a name="l00692"></a>00692 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f84c12942936a4771e62b7503bc6a887"></a><!-- doxytag: member="macb.c::xMACBInit" ref="f84c12942936a4771e62b7503bc6a887" args="(volatile avr32_macb_t *macb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool xMACBInit           </td>
          <td>(</td>
          <td class="paramtype">volatile avr32_macb_t *&nbsp;</td>
          <td class="paramname"> <em>macb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialise the MACB driver. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>*macb</em>&nbsp;</td><td>Base address of the MACB</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if success, FALSE otherwise. </dd></dl>

<p>
Definition at line <a class="el" href="a00009.html#l00425">425</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
References <a class="el" href="a00009.html#l00080">portENTER_CRITICAL</a>, <a class="el" href="a00009.html#l00081">portEXIT_CRITICAL</a>, <a class="el" href="a00009.html#l00694">prvProbePHY()</a>, <a class="el" href="a00009.html#l00530">prvSetupDescriptors()</a>, <a class="el" href="a00009.html#l00577">prvSetupMACAddress()</a>, and <a class="el" href="a00009.html#l00589">prvSetupMACBInterrupt()</a>.
<p>
Referenced by <a class="el" href="a00011.html#l00339">main()</a>.<div class="fragment"><pre class="fragment"><a name="l00426"></a>00426 {
<a name="l00427"></a>00427 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> status;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">// set up registers</span>
<a name="l00430"></a>00430   macb-&gt;ncr = 0;
<a name="l00431"></a>00431   macb-&gt;tsr = ~0UL;
<a name="l00432"></a>00432   macb-&gt;rsr = ~0UL;
<a name="l00433"></a>00433   macb-&gt;idr = ~0UL;
<a name="l00434"></a>00434   status = macb-&gt;isr;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="preprocessor">#if ETHERNET_CONF_USE_RMII_INTERFACE</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>  <span class="comment">// RMII used, set 0 to the USRIO Register</span>
<a name="l00439"></a>00439   macb-&gt;usrio &amp;= ~AVR32_MACB_RMII_MASK;
<a name="l00440"></a>00440 <span class="preprocessor">#else</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span>  <span class="comment">// RMII not used, set 1 to the USRIO Register</span>
<a name="l00442"></a>00442   macb-&gt;usrio |= AVR32_MACB_RMII_MASK;
<a name="l00443"></a>00443 <span class="preprocessor">#endif</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span>
<a name="l00445"></a>00445   <span class="comment">// Load our MAC address into the MACB. </span>
<a name="l00446"></a>00446   <a class="code" href="a00005.html#6764d5a231109b1d2c32c7729de47dfe">prvSetupMACAddress</a>(macb);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="comment">// Setup the buffers and descriptors.</span>
<a name="l00449"></a>00449   <a class="code" href="a00005.html#0f1265d1ebfb3d16f5f46c0b4ea34104">prvSetupDescriptors</a>(macb);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="preprocessor">#if ETHERNET_CONF_SYSTEM_CLOCK &lt;= 20000000</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>  macb-&gt;ncfgr |= (AVR32_MACB_NCFGR_CLK_DIV8 &lt;&lt; AVR32_MACB_NCFGR_CLK_OFFSET);
<a name="l00453"></a>00453 <span class="preprocessor">#elif ETHERNET_CONF_SYSTEM_CLOCK &lt;= 40000000</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span>  macb-&gt;ncfgr |= (AVR32_MACB_NCFGR_CLK_DIV16 &lt;&lt; AVR32_MACB_NCFGR_CLK_OFFSET);
<a name="l00455"></a>00455 <span class="preprocessor">#elif ETHERNET_CONF_SYSTEM_CLOCK &lt;= 80000000</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span>  macb-&gt;ncfgr |= AVR32_MACB_NCFGR_CLK_DIV32 &lt;&lt; AVR32_MACB_NCFGR_CLK_OFFSET;
<a name="l00457"></a>00457 <span class="preprocessor">#elif ETHERNET_CONF_SYSTEM_CLOCK &lt;= 160000000</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span>  macb-&gt;ncfgr |= AVR32_MACB_NCFGR_CLK_DIV64 &lt;&lt; AVR32_MACB_NCFGR_CLK_OFFSET;
<a name="l00459"></a>00459 <span class="preprocessor">#else</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span><span class="preprocessor"># error System clock too fast</span>
<a name="l00461"></a>00461 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00462"></a>00462 <span class="preprocessor"></span>
<a name="l00463"></a>00463   <span class="comment">// Are we connected?</span>
<a name="l00464"></a>00464   <span class="keywordflow">if</span>( <a class="code" href="a00005.html#df8f5fd0f5dbf215ef9fc50a5dc5d684">prvProbePHY</a>(macb) == TRUE )
<a name="l00465"></a>00465   {
<a name="l00466"></a>00466     <span class="comment">// Enable the interrupt!</span>
<a name="l00467"></a>00467     <a class="code" href="a00005.html#507969035dc4ab0c36567f4ea783dc68">portENTER_CRITICAL</a>();
<a name="l00468"></a>00468     {
<a name="l00469"></a>00469       <a class="code" href="a00005.html#b6b8506f7336a338e517a758031be605">prvSetupMACBInterrupt</a>(macb);
<a name="l00470"></a>00470     }
<a name="l00471"></a>00471     <a class="code" href="a00005.html#e2bb7a15725e564859fe12447d5263da">portEXIT_CRITICAL</a>();
<a name="l00472"></a>00472     <span class="comment">// Enable Rx and Tx, plus the stats register.</span>
<a name="l00473"></a>00473     macb-&gt;ncr = AVR32_MACB_NCR_TE_MASK | AVR32_MACB_NCR_RE_MASK;
<a name="l00474"></a>00474     <span class="keywordflow">return</span> (TRUE);
<a name="l00475"></a>00475   }
<a name="l00476"></a>00476   <span class="keywordflow">return</span> (FALSE);
<a name="l00477"></a>00477 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="e0a09ea38f413f68c0955fb029d3c9a8"></a><!-- doxytag: member="macb.c::cMACAddress" ref="e0a09ea38f413f68c0955fb029d3c9a8" args="[6]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="a00005.html#e0a09ea38f413f68c0955fb029d3c9a8">cMACAddress</a>[6] = { ETHERNET_CONF_ETHADDR0,ETHERNET_CONF_ETHADDR1,ETHERNET_CONF_ETHADDR2,ETHERNET_CONF_ETHADDR3,ETHERNET_CONF_ETHADDR4,ETHERNET_CONF_ETHADDR5 }          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00112">112</a> of file <a class="el" href="a00009.html">macb.c</a>.
</div>
</div><p>
<a class="anchor" name="bc6333a566548724a292e47b3d823b9b"></a><!-- doxytag: member="macb.c::DataToRead" ref="bc6333a566548724a292e47b3d823b9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile Bool <a class="el" href="a00005.html#bc6333a566548724a292e47b3d823b9b">DataToRead</a> = FALSE<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00184">184</a> of file <a class="el" href="a00009.html">macb.c</a>.
</div>
</div><p>
<a class="anchor" name="7731c709cc48903c1b506003943b1d8d"></a><!-- doxytag: member="macb.c::pcRxBuffer" ref="7731c709cc48903c1b506003943b1d8d" args="[ETHERNET_CONF_NB_RX_BUFFERS *RX_BUFFER_SIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile char <a class="el" href="a00005.html#7731c709cc48903c1b506003943b1d8d">pcRxBuffer</a>[ETHERNET_CONF_NB_RX_BUFFERS *RX_BUFFER_SIZE]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00090">90</a> of file <a class="el" href="a00009.html">macb.c</a>.
</div>
</div><p>
<a class="anchor" name="409288c455b7adefd2d89455ce0eb6dd"></a><!-- doxytag: member="macb.c::pcTxBuffer" ref="409288c455b7adefd2d89455ce0eb6dd" args="[ETHERNET_CONF_NB_TX_BUFFERS *ETHERNET_CONF_TX_BUFFER_SIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile char <a class="el" href="a00005.html#409288c455b7adefd2d89455ce0eb6dd">pcTxBuffer</a>[ETHERNET_CONF_NB_TX_BUFFERS *ETHERNET_CONF_TX_BUFFER_SIZE]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00100">100</a> of file <a class="el" href="a00009.html">macb.c</a>.
</div>
</div><p>
<a class="anchor" name="a9a7fda390307e9ed2903750becc5c53"></a><!-- doxytag: member="macb.c::ulNextRxBuffer" ref="a9a7fda390307e9ed2903750becc5c53" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile unsigned long <a class="el" href="a00005.html#a9a7fda390307e9ed2903750becc5c53">ulNextRxBuffer</a> = 0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00188">188</a> of file <a class="el" href="a00009.html">macb.c</a>.
</div>
</div><p>
<a class="anchor" name="9146c19f871603c46a900f8bd1e911b1"></a><!-- doxytag: member="macb.c::xRxDescriptors" ref="9146c19f871603c46a900f8bd1e911b1" args="[ETHERNET_CONF_NB_RX_BUFFERS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="a00001.html">AVR32_RxTdDescriptor</a> <a class="el" href="a00005.html#9146c19f871603c46a900f8bd1e911b1">xRxDescriptors</a>[ETHERNET_CONF_NB_RX_BUFFERS]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00109">109</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00530">prvSetupDescriptors()</a>, <a class="el" href="a00009.html#l00276">ulMACBInputLength()</a>, and <a class="el" href="a00009.html#l00316">vMACBRead()</a>.
</div>
</div><p>
<a class="anchor" name="315547b662b4e7f19e79b559a7a77c93"></a><!-- doxytag: member="macb.c::xTxDescriptors" ref="315547b662b4e7f19e79b559a7a77c93" args="[ETHERNET_CONF_NB_TX_BUFFERS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="a00002.html">AVR32_TxTdDescriptor</a> <a class="el" href="a00005.html#315547b662b4e7f19e79b559a7a77c93">xTxDescriptors</a>[ETHERNET_CONF_NB_TX_BUFFERS]<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="a00009.html#l00108">108</a> of file <a class="el" href="a00009.html">macb.c</a>.
<p>
Referenced by <a class="el" href="a00009.html#l00191">lMACBSend()</a>, <a class="el" href="a00009.html#l00530">prvSetupDescriptors()</a>, and <a class="el" href="a00009.html#l00495">vClearMACBTxBuffer()</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Sep 20 12:16:48 2007 for AVR32 - MACB Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
